<device xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" schemaVersion="1.3" xs:noNamespaceSchemaLocation="CMSIS-SVD_Schema_1_3.xsd">
  <name>RK3399-AP</name>
  <version>1</version>
  <description>Rockchip RK3399 for AP CPU</description>
  <resetMask>0xFFFFFFFF</resetMask>
  <width>64</width>
  <addressUnitBits>8</addressUnitBits>
  <resetValue>0</resetValue>
  <size>32</size>
  <cpu>
    <fpuPresent>1</fpuPresent>
    <mpuPresent>1</mpuPresent>
    <dcachePresent>1</dcachePresent>
    <name>CA7</name>
    <endian>little</endian>
    <vtorPresent>1</vtorPresent>
    <nvicPrioBits>4</nvicPrioBits>
    <vendorSystickConfig>0</vendorSystickConfig>
    <icachePresent>1</icachePresent>
    <revision>r0p1</revision>
    <deviceNumInterrupts>32</deviceNumInterrupts>
  </cpu>
  <peripherals>
    <peripheral>
      <name>CIC</name>
      <version>1.0</version>
      <groupname>CIC</groupname>
      <baseAddress>0xff620000</baseAddress>
      <registers>
        <register>
          <name>CIC_CTRL0</name>
          <description>DDR Controller LP Interface Control Register 0</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>CIC_CTRL1</name>
          <description>DDR Controller LP Interface Control Register 1</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0 can be written by software.
When bit 16=0, bit 0 cannot be written by software;
When bit 17=1, bit 1 can be written by software.
When bit 17=0, bit 1 cannot be written by software;
......
When bit 31=1, bit 15 can be written by software.
When bit 31=0, bit 15 cannot be written by software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SREF_MEMCG_CH1</name>
              <description>Channel 1 memory clock gating in self-refresh
1'b0: memory is not clock gated in external self-refresh
1'b1: memory is clock gated in external self-refresh</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SREF_MEMCG_CH0</name>
              <description>Channel 0 memory clock gating in self-refresh
1'b0: memory is not clock gated in external self-refresh
1'b1: memory is clock gated in external self-refresh</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LP_CMD_PRIO_CH1</name>
              <description>Channel 1 LP command priority in external self-refresh mode
1'b0: don't issue priority request when enter external self-refresh
1'b1: issue priority request when enter external self-refresh</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LP_CMD_PRIO_CH0</name>
              <description>Channel 0 LP command priority in external self-refresh mode
1'b0: don't issue priority request when enter external self-refresh
1'b1: issue priority request when enter external self-refresh</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STDBY_CMD_PRIO_CH1</name>
              <description>Channel 1 LP command priority in standby mode
1'b0: don't issue priority request when enter standby mode
1'b1: issue priority request when enter standby mode</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STDBY_CMD_PRIO_CH0</name>
              <description>Channel 0 LP command priority in standby mode
1'b0: don't issue priority request when enter standby mode
1'b1: issue priority request when enter standby mode</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STDBY_MEMCG_CH1</name>
              <description>Channel 1 memory clock gating in standby mode
1'b0: memory is not clock gated when in standby mode
1'b1: memory is clock gated when in standby mode</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STDBY_MEMCG_CH0</name>
              <description>Channel 0 memory clock gating in standby mode
1'b0: memory is not clock gated when in standby mode
1'b1: memory is clock gated when in standby mode</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STDBY_EN_CH1</name>
              <description>Channel 1 standby mode enable
1'b0: disable
1'b1: enable</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STDBY_EN_CH0</name>
              <description>Channel 0 standby mode enable
1'b0: disable
1'b1: enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CIC_IDLE_TH</name>
          <description>DDR Controller LP Interface Idle Threshold    in standby mode</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IDLE_TH</name>
              <description>Idle counter threshold in standby mode</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CIC_CG_WAIT_TH</name>
          <description>DDR Controller LP Interface CG Wait Threshold in standby mode</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CG_EXIT_TH</name>
              <description>Clock gating exit counter threshold in standby mode</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CG_WAIT_TH</name>
              <description>Clock gating wait counter threshold in standby mode</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CIC_STATUS0</name>
          <description>DDR Controller LP Interface Status Register 0</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>STATE_FC</name>
              <description>Frequency change state machine</description>
              <bitRange>[13:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SREF_DONE_EXT_CH1</name>
              <description>Channel 1 external self-refresh done</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SREF_REQ_EXT_CH1</name>
              <description>Channel 1 external self-refresh request</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SREF_DONE_EXT_CH0</name>
              <description>Channel 0 external self-refresh done</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SREF_REQ_EXT_CH0</name>
              <description>Channel 0 external self-refresh request</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CHG_FREQ_WAIT</name>
              <description>Frequency change wait</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CHG_FAIL</name>
              <description>Frequency change fail</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CHG_DONE</name>
              <description>Frequency change done</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CIC_STATUS1</name>
          <description>DDR Controller LP Interface Status Register 1</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>STATE_CH1</name>
              <description>Channel 1 external self-refresh and standby mode state machine</description>
              <bitRange>[28:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STATE_CH0</name>
              <description>Channel 0 external self-refresh and standby mode state machine</description>
              <bitRange>[12:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CIC_CTRL2</name>
          <description>DDR Controller LP Interface Control Register 2</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0xa0a</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0 can be written by software.
When bit 16=0, bit 0 cannot be written by software;
When bit 17=1, bit 1 can be written by software.
When bit 17=0, bit 1 cannot be written by software;
......
When bit 31=1, bit 15 can be written by software.
When bit 31=0, bit 15 cannot be written by software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LP_CMD_CFG_CH1</name>
              <description>Channel 1 external self-refresh enter command</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LP_CMD_CFG_CH0</name>
              <description>Channel 0 external self-refresh enter command</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CIC_CTRL3</name>
          <description>DDR Controller LP Interface Control Register 3</description>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <resetValue>0x101</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0 can be written by software.
When bit 16=0, bit 0 cannot be written by software;
When bit 17=1, bit 1 can be written by software.
When bit 17=0, bit 1 cannot be written by software;
......
When bit 31=1, bit 15 can be written by software.
When bit 31=0, bit 15 cannot be written by software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LP_CMD_EXIT_CFG_CH1</name>
              <description>Channel 1 external self-refresh exit command</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LP_CMD_EXIT_CFG_CH0</name>
              <description>Channel 0 external self-refresh exit command</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CIC_CTRL4</name>
          <description>DDR Controller LP Interface Control Register 4</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x8a8a</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0 can be written by software.
When bit 16=0, bit 0 cannot be written by software;
When bit 17=1, bit 1 can be written by software.
When bit 17=0, bit 1 cannot be written by software;
......
When bit 31=1, bit 15 can be written by software.
When bit 31=0, bit 15 cannot be written by software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LP_CMD_FCHG_CFG_CH1</name>
              <description>Channel 1 frequency change enter command</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LP_CMD_FCHG_CFG_CH0</name>
              <description>Channel 0 frequency change enter command</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CIC_STATUS2</name>
          <description>DDR Controller LP Interface Status Register 2</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DDR1_CNTRL_FREQ_CHANGE_REQ</name>
              <description>Channel 1 DDR controller frequency change request</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DDR1_CNTRL_FREQ_CHANGE_REQ_TYPE</name>
              <description>Channel 1 DDR controller frequency change request type</description>
              <bitRange>[16:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DDR1_FREQ_CHANGE_REQ</name>
              <description>Channel 1 DDR PHY frequency change request</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DDR1_FREQ_CHANGE_REQ_TYPE</name>
              <description>Channel 1 DDR PHY frequency change request type</description>
              <bitRange>[13:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DDR0_CNTRL_FREQ_CHANGE_REQ</name>
              <description>Channel 0 DDR controller frequency change request</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DDR0_CNTRL_FREQ_CHANGE_REQ_TYPE</name>
              <description>Channel 0 DDR controller frequency change request type</description>
              <bitRange>[7:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DDR0_FREQ_CHANGE_REQ</name>
              <description>Channel 0 DDR PHY frequency change request</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DDR0_FREQ_CHANGE_REQ_TYPE</name>
              <description>Channel 0 DDR PHY frequency change request type
reserved
ip_version
DDR monitor IP version</description>
              <bitRange>[4:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CCI_PROBE_MSCH0</name>
      <version>1.0</version>
      <groupname>PROBE</groupname>
      <baseAddress>0xffa86000</baseAddress>
      <registers>
        <register>
          <name>PROBE_Id_CoreId</name>
          <description>Core ID register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0xd867006</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>PROBE_Id_RevisionId</name>
          <description>Revision ID register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x1aa00</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>PROBE_MainCtl</name>
          <description>Register MainCtl contains probe global control bits.</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>PROBE_CfgCtl</name>
          <description>Register CfgCtl contains global enable and active bits.</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>PROBE_StatPeriod</name>
          <description>Statistics Period</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>PROBE_StatGo</name>
          <description>Statistics start to dump</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>PROBE_Counters_0_Src</name>
          <description>Register CntSrc indicates the event source.</description>
          <addressOffset>0x138</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>PROBE_Counters_0_Val</name>
          <description>Registers Counters_M_Val contain the statistics counter values.</description>
          <addressOffset>0x13c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>PROBE_Counters_1_Src</name>
          <description>Register CntSrc indicates the event source.</description>
          <addressOffset>0x14c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>PROBE_Counters_1_Val</name>
          <description>Registers Counters_M_Val contain the statistics counter values.</description>
          <addressOffset>0x150</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>PROBE_Counters_2_Src</name>
          <description>Register CntSrc indicates the event source.</description>
          <addressOffset>0x160</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>PROBE_Counters_2_Val</name>
          <description>Registers Counters_M_Val contain the statistics counter values.</description>
          <addressOffset>0x164</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>PROBE_Counters_3_Src</name>
          <description>Register CntSrc indicates the event source.</description>
          <addressOffset>0x174</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>PROBE_Counters_3_Val</name>
          <description>Registers Counters_M_Val contain the statistics counter values.</description>
          <addressOffset>0x178</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="CCI_PROBE_MSCH0">
      <name>GPU_PROBE_MSCH0E</name>
      <version>1.0</version>
      <groupname>PROBE</groupname>
      <baseAddress>0xffa86400</baseAddress>
    </peripheral>
    <peripheral derivedFrom="CCI_PROBE_MSCH0">
      <name>PERIHP_PROBE_MSCH0</name>
      <version>1.0</version>
      <groupname>PROBE</groupname>
      <baseAddress>0xffa86800</baseAddress>
    </peripheral>
    <peripheral derivedFrom="CCI_PROBE_MSCH0">
      <name>PERILP_PROBE_MSCH0</name>
      <version>1.0</version>
      <groupname>PROBE</groupname>
      <baseAddress>0xffa86c00</baseAddress>
    </peripheral>
    <peripheral derivedFrom="CCI_PROBE_MSCH0">
      <name>VIDEO_PROBE_MSCH0</name>
      <version>1.0</version>
      <groupname>PROBE</groupname>
      <baseAddress>0xffa87000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="CCI_PROBE_MSCH0">
      <name>VIO0_PROBE_MSCH0</name>
      <version>1.0</version>
      <groupname>PROBE</groupname>
      <baseAddress>0xffa87400</baseAddress>
    </peripheral>
    <peripheral derivedFrom="CCI_PROBE_MSCH0">
      <name>VIO1_PROBE_MSCH0</name>
      <version>1.0</version>
      <groupname>PROBE</groupname>
      <baseAddress>0xffa87800</baseAddress>
    </peripheral>
    <peripheral derivedFrom="CCI_PROBE_MSCH0">
      <name>CCI_PROBE_MSCH1</name>
      <version>1.0</version>
      <groupname>PROBE</groupname>
      <baseAddress>0xffa8e000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="CCI_PROBE_MSCH0">
      <name>GPU_PROBE_MSCH1</name>
      <version>1.0</version>
      <groupname>PROBE</groupname>
      <baseAddress>0xffa8e400</baseAddress>
    </peripheral>
    <peripheral derivedFrom="CCI_PROBE_MSCH0">
      <name>PERIHP_PROBE_MSCH1</name>
      <version>1.0</version>
      <groupname>PROBE</groupname>
      <baseAddress>0xffa8e800</baseAddress>
    </peripheral>
    <peripheral derivedFrom="CCI_PROBE_MSCH0">
      <name>PERILP_PROBE_MSCH1</name>
      <version>1.0</version>
      <groupname>PROBE</groupname>
      <baseAddress>0xffa8ec00</baseAddress>
    </peripheral>
    <peripheral derivedFrom="CCI_PROBE_MSCH0">
      <name>VIDEO_PROBE_MSCH1</name>
      <version>1.0</version>
      <groupname>PROBE</groupname>
      <baseAddress>0xffa8f000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="CCI_PROBE_MSCH0">
      <name>VIO0_PROBE_MSCH1</name>
      <version>1.0</version>
      <groupname>PROBE</groupname>
      <baseAddress>0xffa8f400</baseAddress>
    </peripheral>
    <peripheral derivedFrom="CCI_PROBE_MSCH0">
      <name>VIO1_PROBE_MSCH1</name>
      <version>1.0</version>
      <groupname>PROBE</groupname>
      <baseAddress>0xffa8f800</baseAddress>
    </peripheral>
    <peripheral>
      <name>CRU</name>
      <version>1.0</version>
      <groupname>CRU</groupname>
      <baseAddress>0xff760000</baseAddress>
      <registers>
        <register>
          <name>CRU_LPLL_CON0</name>
          <description>LPLL configuration register0</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x96</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>FBDIV</name>
              <description>Feedback Divide Value
Valid divider settings are:
[16, 3200] in integer mode
[20, 320] in fractional mode
Tips: no plus one operation</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_LPLL_CON1</name>
          <description>LPLL configuration register1</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x1202</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>POSTDIV2</name>
              <description>Second Post Divide Value
(1-7)</description>
              <bitRange>[14:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POSTDIV1</name>
              <description>First Post Divide Value
(1-7)</description>
              <bitRange>[10:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REFDIV</name>
              <description>Reference Clock Divide Value
(1-63)</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_LPLL_CON2</name>
          <description>LPLL configuration register2</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x31f</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PLL_LOCK</name>
              <description>PLL lock status
1'b0: unlock
1'b1: lock</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FRACDIV</name>
              <description>Fractional part of feedback divide
(fraction = FRAC/2^24)</description>
              <bitRange>[23:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_LPLL_CON3</name>
          <description>LPLL configuration register3</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x8</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PLL_WORK_MODE</name>
              <description>PLL work mode select
2'b00: Slow mode, clock from external 24MHz/26MHz OSC
(default)
2'b01: Normal mode, clock from PLL output
2'b10: Deep slow mode, clock from external 32.768kHz</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FOUT4PHASEPD</name>
              <description>Power down 4-phase clocks and 2X, 3X, 4X clocks
1'b0: no power down
1'b1: power down</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FOUTVCOPD</name>
              <description>Power down buffered VCO clock
1'b0: no power down
1'b1: power down</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FOUTPOSTDIVPD</name>
              <description>Power down all outputs except for buffered VCO clock
1'b0: no power down
1'b1: power down</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSMPD</name>
              <description>PLL saturation behavior enable
1'b0: no power down
1'b1: power down
DSMPD = 1'b1 ( modulator is disabled, "integer mode")</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DACPD</name>
              <description>Power down quantization noise cancellation DAC
1'b0: no power down
1'b1: power down</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BYPASS</name>
              <description>PLL Bypass.    FREF bypasses PLL to FOUTPOSTDIV
1'b0: no bypass
1'b1: bypass</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POWER_DOWN</name>
              <description>Global power down
1'b0: no power down
1'b1: power down</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_LPLL_CON4</name>
          <description>LPLL configuration register4</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x7</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>SSMOD_SPREAD</name>
              <description>spread amplitude
% = 0.1 * SPREAD[4:0]</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSMOD_DIVVAL</name>
              <description>Divider required to set the modulation frequency
Divider required to set the modulation frequency</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSMOD_DOWNSPREAD</name>
              <description>Selects center spread or downs pread
1'b0: center spread
1'b1: down spread</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSMOD_RESET</name>
              <description>Reset modulator state
1'b0: no reset
1'b1: reset</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSMOD_DISABLE_SSCG</name>
              <description>Bypass SSMOD by module
1'b0: no bypass
1'b1: bypass</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSMOD_BP</name>
              <description>Bypass SSMOD by integration
1'b0: no bypass
1'b1: bypass</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_LPLL_CON5</name>
          <description>LPLL configuration register5</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x7f00</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>SSMOD_EXT_MAXADDR</name>
              <description>External wave table data inputs
(0-255)</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSMOD_SEL_EXT_WAVE</name>
              <description>select external wave
1'b0: no select ext_wave
1'b1: select ext_wave</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_BPLL_CON0</name>
          <description>BPLL configuration register0</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x64</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>FBDIV</name>
              <description>Feedback Divide Value
Valid divider settings are:
[16, 3200] in integer mode
[20, 320] in fractional mode
Tips: no plus one operation</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_BPLL_CON1</name>
          <description>BPLL configuration register1</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x1201</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>POSTDIV2</name>
              <description>Second Post Divide Value
(1-7)</description>
              <bitRange>[14:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POSTDIV1</name>
              <description>First Post Divide Value
(1-7)</description>
              <bitRange>[10:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REFDIV</name>
              <description>Reference Clock Divide Value
(1-63)</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_BPLL_CON2</name>
          <description>BPLL configuration register2</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x31f</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PLL_LOCK</name>
              <description>PLL lock status
1'b0: unlock
1'b1: lock</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FRACDIV</name>
              <description>Fractional part of feedback divide
(fraction = FRAC/2^24)</description>
              <bitRange>[23:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_BPLL_CON3</name>
          <description>BPLL configuration register3</description>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <resetValue>0x8</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PLL_WORK_MODE</name>
              <description>PLL work mode select
2'b00: Slow mode, clock from external 24MHz/26MHz OSC
(default)
2'b01: Normal mode, clock from PLL output
2'b10: Deep slow mode, clock from external 32.768kHz</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FOUT4PHASEPD</name>
              <description>Power down 4-phase clocks and 2X, 3X, 4X clocks
1'b0: no power down
1'b1: power down</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FOUTVCOPD</name>
              <description>Power down buffered VCO clock
1'b0: no power down
1'b1: power down</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FOUTPOSTDIVPD</name>
              <description>Power down all outputs except for buffered VCO clock
1'b0: no power down
1'b1: power down</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSMPD</name>
              <description>PLL saturation behavior enable
1'b0: no power down
1'b1: power down
DSMPD = 1'b1 ( modulator is disabled, "integer mode")</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DACPD</name>
              <description>Power down quantization noise cancellation DAC
1'b0: no power down
1'b1: power down</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BYPASS</name>
              <description>PLL Bypass.    FREF bypasses PLL to FOUTPOSTDIV
1'b0: no bypass
1'b1: bypass</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POWER_DOWN</name>
              <description>Global power down
1'b0: no power down
1'b1: power down</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_BPLL_CON4</name>
          <description>BPLL configuration register4</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <resetValue>0x7</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>SSMOD_SPREAD</name>
              <description>spread amplitude
% = 0.1 * SPREAD[4:0]</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSMOD_DIVVAL</name>
              <description>Divider required to set the modulation frequency
Divider required to set the modulation frequency</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSMOD_DOWNSPREAD</name>
              <description>Selects center spread or downs pread
1'b0: center spread
1'b1: down spread</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSMOD_RESET</name>
              <description>Reset modulator state
1'b0: no reset
1'b1: reset</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSMOD_DISABLE_SSCG</name>
              <description>Bypass SSMOD by module
1'b0: no bypass
1'b1: bypass</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSMOD_BP</name>
              <description>Bypass SSMOD by integration
1'b0: no bypass
1'b1: bypass</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_BPLL_CON5</name>
          <description>BPLL configuration register5</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <resetValue>0x7f00</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>SSMOD_EXT_MAXADDR</name>
              <description>External wave table data inputs
(0-255)</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSMOD_SEL_EXT_WAVE</name>
              <description>select external wave
1'b0: no select ext_wave
1'b1: select ext_wave</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_DPLL_CON0</name>
          <description>DPLL configuration register0</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <resetValue>0x64</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>FBDIV</name>
              <description>Feedback Divide Value
Valid divider settings are:
[16, 3200] in integer mode
[20, 320] in fractional mode
Tips: no plus one operation</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_DPLL_CON1</name>
          <description>DPLL configuration register1</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <resetValue>0x1301</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>POSTDIV2</name>
              <description>Second Post Divide Value
(1-7)</description>
              <bitRange>[14:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POSTDIV1</name>
              <description>First Post Divide Value
(1-7)</description>
              <bitRange>[10:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REFDIV</name>
              <description>Reference Clock Divide Value
(1-63)</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_DPLL_CON2</name>
          <description>DPLL configuration register2</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <resetValue>0x31f</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PLL_LOCK</name>
              <description>PLL lock status
1'b0: unlock
1'b1: lock</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FRACDIV</name>
              <description>Fractional part of feedback divide
(fraction = FRAC/2^24)</description>
              <bitRange>[23:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_DPLL_CON3</name>
          <description>DPLL configuration register3</description>
          <addressOffset>0x4c</addressOffset>
          <size>32</size>
          <resetValue>0x8</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PLL_WORK_MODE</name>
              <description>PLL work mode select
2'b00: Slow mode, clock from external 24MHz/26MHz OSC
(default)
2'b01: Normal mode, clock from PLL output
2'b10: Deep slow mode, clock from external 32.768kHz</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FOUT4PHASEPD</name>
              <description>Power down 4-phase clocks and 2X, 3X, 4X clocks
1'b0: no power down
1'b1: power down</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FOUTVCOPD</name>
              <description>Power down buffered VCO clock
1'b0: no power down
1'b1: power down</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FOUTPOSTDIVPD</name>
              <description>Power down all outputs except for buffered VCO clock
1'b0: no power down
1'b1: power down</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSMPD</name>
              <description>PLL saturation behavior enable
1'b0: no power down
1'b1: power down
DSMPD = 1'b1 ( modulator is disabled, "integer mode")</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DACPD</name>
              <description>Power down quantization noise cancellation DAC
1'b0: no power down
1'b1: power down</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BYPASS</name>
              <description>PLL Bypass.    FREF bypasses PLL to FOUTPOSTDIV
1'b0: no bypass
1'b1: bypass</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POWER_DOWN</name>
              <description>Global power down
1'b0: no power down
1'b1: power down</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_DPLL_CON4</name>
          <description>DPLL configuration register4</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <resetValue>0x7</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>SSMOD_SPREAD</name>
              <description>spread amplitude
% = 0.1 * SPREAD[4:0]</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSMOD_DIVVAL</name>
              <description>Divider required to set the modulation frequency
Divider required to set the modulation frequency</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSMOD_DOWNSPREAD</name>
              <description>Selects center spread or downs pread
1'b0: center spread
1'b1: down spread</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSMOD_RESET</name>
              <description>Reset modulator state
1'b0: no reset
1'b1: reset</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSMOD_DISABLE_SSCG</name>
              <description>Bypass SSMOD by module
1'b0: no bypass
1'b1: bypass</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSMOD_BP</name>
              <description>Bypass SSMOD by integration
1'b0: no bypass
1'b1: bypass</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_DPLL_CON5</name>
          <description>DPLL configuration register5</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <resetValue>0x7f00</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>SSMOD_EXT_MAXADDR</name>
              <description>External wave table data inputs
(0-255)</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSMOD_SEL_EXT_WAVE</name>
              <description>select external wave
1'b0: no select ext_wave
1'b1: select ext_wave</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CPLL_CON0</name>
          <description>CPLL configuration register0</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <resetValue>0xc0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>FBDIV</name>
              <description>Feedback Divide Value
Valid divider settings are:
[16, 3200] in integer mode
[20, 320] in fractional mode
Tips: no plus one operation</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CPLL_CON1</name>
          <description>CPLL configuration register1</description>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <resetValue>0x1302</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>POSTDIV2</name>
              <description>Second Post Divide Value
(1-7)</description>
              <bitRange>[14:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POSTDIV1</name>
              <description>First Post Divide Value
(1-7)</description>
              <bitRange>[10:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REFDIV</name>
              <description>Reference Clock Divide Value
(1-63)</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CPLL_CON2</name>
          <description>CPLL configuration register2</description>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <resetValue>0x31f</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PLL_LOCK</name>
              <description>PLL lock status
1'b0: unlock
1'b1: lock</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FRACDIV</name>
              <description>Fractional part of feedback divide
(fraction = FRAC/2^24)</description>
              <bitRange>[23:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CPLL_CON3</name>
          <description>CPLL configuration register3</description>
          <addressOffset>0x6c</addressOffset>
          <size>32</size>
          <resetValue>0x8</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PLL_WORK_MODE</name>
              <description>PLL work mode select
2'b00: Slow mode, clock from external 24MHz/26MHz OSC
(default)
2'b01: Normal mode, clock from PLL output
2'b10: Deep slow mode, clock from external 32.768kHz</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FOUT4PHASEPD</name>
              <description>Power down 4-phase clocks and 2X, 3X, 4X clocks
1'b0: no power down
1'b1: power down</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FOUTVCOPD</name>
              <description>Power down buffered VCO clock
1'b0: no power down
1'b1: power down</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FOUTPOSTDIVPD</name>
              <description>Power down all outputs except for buffered VCO clock
1'b0: no power down
1'b1: power down</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSMPD</name>
              <description>PLL saturation behavior enable
1'b0: no power down
1'b1: power down
DSMPD = 1'b1 ( modulator is disabled, "integer mode")</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DACPD</name>
              <description>Power down quantization noise cancellation DAC
1'b0: no power down
1'b1: power down</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BYPASS</name>
              <description>PLL Bypass.    FREF bypasses PLL to FOUTPOSTDIV
1'b0: no bypass
1'b1: bypass</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POWER_DOWN</name>
              <description>Global power down
1'b0: no power down
1'b1: power down</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CPLL_CON4</name>
          <description>CPLL configuration register4</description>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <resetValue>0x7</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>SSMOD_SPREAD</name>
              <description>spread amplitude
% = 0.1 * SPREAD[4:0]</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSMOD_DIVVAL</name>
              <description>Divider required to set the modulation frequency
Divider required to set the modulation frequency</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSMOD_DOWNSPREAD</name>
              <description>Selects center spread or downs pread
1'b0: center spread
1'b1: down spread</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSMOD_RESET</name>
              <description>Reset modulator state
1'b0: no reset
1'b1: reset</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSMOD_DISABLE_SSCG</name>
              <description>Bypass SSMOD by module
1'b0: no bypass
1'b1: bypass</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSMOD_BP</name>
              <description>Bypass SSMOD by integration
1'b0: no bypass
1'b1: bypass</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CPLL_CON5</name>
          <description>CPLL configuration register5</description>
          <addressOffset>0x74</addressOffset>
          <size>32</size>
          <resetValue>0x7f00</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>SSMOD_EXT_MAXADDR</name>
              <description>External wave table data inputs
(0-255)</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSMOD_SEL_EXT_WAVE</name>
              <description>select external wave
1'b0: no select ext_wave
1'b1: select ext_wave</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_GPLL_CON0</name>
          <description>GPLL configuration register0</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <resetValue>0xc6</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>FBDIV</name>
              <description>Feedback Divide Value
Valid divider settings are:
[16, 3200] in integer mode
[20, 320] in fractional mode
Tips: no plus one operation</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_GPLL_CON1</name>
          <description>GPLL configuration register1</description>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <resetValue>0x2202</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>POSTDIV2</name>
              <description>Second Post Divide Value
(1-7)</description>
              <bitRange>[14:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POSTDIV1</name>
              <description>First Post Divide Value
(1-7)</description>
              <bitRange>[10:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REFDIV</name>
              <description>Reference Clock Divide Value
(1-63)</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_GPLL_CON2</name>
          <description>GPLL configuration register2</description>
          <addressOffset>0x88</addressOffset>
          <size>32</size>
          <resetValue>0x31f</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PLL_LOCK</name>
              <description>PLL lock status
1'b0: unlock
1'b1: lock</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FRACDIV</name>
              <description>Fractional part of feedback divide
(fraction = FRAC/2^24)</description>
              <bitRange>[23:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_GPLL_CON3</name>
          <description>GPLL configuration register3</description>
          <addressOffset>0x8c</addressOffset>
          <size>32</size>
          <resetValue>0x8</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PLL_WORK_MODE</name>
              <description>PLL work mode select
2'b00: Slow mode, clock from external 24MHz/26MHz OSC
(default)
2'b01: Normal mode, clock from PLL output
2'b10: Deep slow mode, clock from external 32.768kHz</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FOUT4PHASEPD</name>
              <description>Power down 4-phase clocks and 2X, 3X, 4X clocks
1'b0: no power down
1'b1: power down</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FOUTVCOPD</name>
              <description>Power down buffered VCO clock
1'b0: no power down
1'b1: power down</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FOUTPOSTDIVPD</name>
              <description>Power down all outputs except for buffered VCO clock
1'b0: no power down
1'b1: power down</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSMPD</name>
              <description>PLL saturation behavior enable
1'b0: no power down
1'b1: power down
DSMPD = 1'b1 ( modulator is disabled, "integer mode")</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DACPD</name>
              <description>Power down quantization noise cancellation DAC
1'b0: no power down
1'b1: power down</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BYPASS</name>
              <description>PLL Bypass.    FREF bypasses PLL to FOUTPOSTDIV
1'b0: no bypass
1'b1: bypass</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POWER_DOWN</name>
              <description>Global power down
1'b0: no power down
1'b1: power down</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_GPLL_CON4</name>
          <description>GPLL configuration register4</description>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <resetValue>0x7</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>SSMOD_SPREAD</name>
              <description>spread amplitude
% = 0.1 * SPREAD[4:0]</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSMOD_DIVVAL</name>
              <description>Divider required to set the modulation frequency
Divider required to set the modulation frequency</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSMOD_DOWNSPREAD</name>
              <description>Selects center spread or downs pread
1'b0: center spread
1'b1: down spread</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSMOD_RESET</name>
              <description>Reset modulator state
1'b0: no reset
1'b1: reset</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSMOD_DISABLE_SSCG</name>
              <description>Bypass SSMOD by module
1'b0: no bypass
1'b1: bypass</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSMOD_BP</name>
              <description>Bypass SSMOD by integration
1'b0: no bypass
1'b1: bypass</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_GPLL_CON5</name>
          <description>GPLL configuration register5</description>
          <addressOffset>0x94</addressOffset>
          <size>32</size>
          <resetValue>0x7f00</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>SSMOD_EXT_MAXADDR</name>
              <description>External wave table data inputs
(0-255)</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSMOD_SEL_EXT_WAVE</name>
              <description>select external wave
1'b0: no select ext_wave
1'b1: select ext_wave</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_NPLL_CON0</name>
          <description>NPLL configuration register0</description>
          <addressOffset>0xa0</addressOffset>
          <size>32</size>
          <resetValue>0xfa</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>FBDIV</name>
              <description>Feedback Divide Value
Valid divider settings are:
[16, 3200] in integer mode
[20, 320] in fractional mode
Tips: no plus one operation</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_NPLL_CON1</name>
          <description>NPLL configuration register1</description>
          <addressOffset>0xa4</addressOffset>
          <size>32</size>
          <resetValue>0x1203</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>POSTDIV2</name>
              <description>Second Post Divide Value
(1-7)</description>
              <bitRange>[14:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POSTDIV1</name>
              <description>First Post Divide Value
(1-7)</description>
              <bitRange>[10:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REFDIV</name>
              <description>Reference Clock Divide Value
(1-63)</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_NPLL_CON2</name>
          <description>NPLL configuration register2</description>
          <addressOffset>0xa8</addressOffset>
          <size>32</size>
          <resetValue>0x31f</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PLL_LOCK</name>
              <description>PLL lock status
1'b0: unlock
1'b1: lock</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FRACDIV</name>
              <description>Fractional part of feedback divide
(fraction = FRAC/2^24)</description>
              <bitRange>[23:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_NPLL_CON3</name>
          <description>NPLL configuration register3</description>
          <addressOffset>0xac</addressOffset>
          <size>32</size>
          <resetValue>0x8</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PLL_WORK_MODE</name>
              <description>PLL work mode select
2'b00: Slow mode, clock from external 24MHz/26MHz OSC
(default)
2'b01: Normal mode, clock from PLL output
2'b10: Deep slow mode, clock from external 32.768kHz</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FOUT4PHASEPD</name>
              <description>Power down 4-phase clocks and 2X, 3X, 4X clocks
1'b0: no power down
1'b1: power down</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FOUTVCOPD</name>
              <description>Power down buffered VCO clock
1'b0: no power down
1'b1: power down</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FOUTPOSTDIVPD</name>
              <description>Power down all outputs except for buffered VCO clock
1'b0: no power down
1'b1: power down</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSMPD</name>
              <description>PLL saturation behavior enable
1'b0: no power down
1'b1: power down
DSMPD = 1'b1 ( modulator is disabled, "integer mode")</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DACPD</name>
              <description>Power down quantization noise cancellation DAC
1'b0: no power down
1'b1: power down</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BYPASS</name>
              <description>PLL Bypass.    FREF bypasses PLL to FOUTPOSTDIV
1'b0: no bypass
1'b1: bypass</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POWER_DOWN</name>
              <description>Global power down
1'b0: no power down
1'b1: power down</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_NPLL_CON4</name>
          <description>NPLL configuration register4</description>
          <addressOffset>0xb0</addressOffset>
          <size>32</size>
          <resetValue>0x7</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>SSMOD_SPREAD</name>
              <description>spread amplitude
% = 0.1 * SPREAD[4:0]</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSMOD_DIVVAL</name>
              <description>Divider required to set the modulation frequency
Divider required to set the modulation frequency</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSMOD_DOWNSPREAD</name>
              <description>Selects center spread or downs pread
1'b0: center spread
1'b1: down spread</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSMOD_RESET</name>
              <description>Reset modulator state
1'b0: no reset
1'b1: reset</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSMOD_DISABLE_SSCG</name>
              <description>Bypass SSMOD by module
1'b0: no bypass
1'b1: bypass</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSMOD_BP</name>
              <description>Bypass SSMOD by integration
1'b0: no bypass
1'b1: bypass</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_NPLL_CON5</name>
          <description>NPLL configuration register5</description>
          <addressOffset>0xb4</addressOffset>
          <size>32</size>
          <resetValue>0x7f00</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>SSMOD_EXT_MAXADDR</name>
              <description>External wave table data inputs
(0-255)</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSMOD_SEL_EXT_WAVE</name>
              <description>select external wave
1'b0: no select ext_wave
1'b1: select ext_wave</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_VPLL_CON0</name>
          <description>VPLL configuration register0</description>
          <addressOffset>0xc0</addressOffset>
          <size>32</size>
          <resetValue>0xc6</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>FBDIV</name>
              <description>Feedback Divide Value
Valid divider settings are:
[16, 3200] in integer mode
[20, 320] in fractional mode
Tips: no plus one operation</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_VPLL_CON1</name>
          <description>VPLL configuration register1</description>
          <addressOffset>0xc4</addressOffset>
          <size>32</size>
          <resetValue>0x1202</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>POSTDIV2</name>
              <description>Second Post Divide Value
(1-7)</description>
              <bitRange>[14:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POSTDIV1</name>
              <description>First Post Divide Value
(1-7)</description>
              <bitRange>[10:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REFDIV</name>
              <description>Reference Clock Divide Value
(1-63)</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_VPLL_CON2</name>
          <description>VPLL configuration register2</description>
          <addressOffset>0xc8</addressOffset>
          <size>32</size>
          <resetValue>0x31f</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PLL_LOCK</name>
              <description>PLL lock status
1'b0: unlock
1'b1: lock</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FRACDIV</name>
              <description>Fractional part of feedback divide
(fraction = FRAC/2^24)</description>
              <bitRange>[23:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_VPLL_CON3</name>
          <description>VPLL configuration register3</description>
          <addressOffset>0xcc</addressOffset>
          <size>32</size>
          <resetValue>0x8</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PLL_WORK_MODE</name>
              <description>PLL work mode select
2'b00: Slow mode, clock from external 24MHz/26MHz OSC
(default)
2'b01: Normal mode, clock from PLL output
2'b10: Deep slow mode, clock from external 32.768kHz</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FOUT4PHASEPD</name>
              <description>Power down 4-phase clocks and 2X, 3X, 4X clocks
1'b0: no power down
1'b1: power down</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FOUTVCOPD</name>
              <description>Power down buffered VCO clock
1'b0: no power down
1'b1: power down</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FOUTPOSTDIVPD</name>
              <description>Power down all outputs except for buffered VCO clock
1'b0: no power down
1'b1: power down</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSMPD</name>
              <description>PLL saturation behavior enable
1'b0: no power down
1'b1: power down
DSMPD = 1'b1 ( modulator is disabled, "integer mode")</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DACPD</name>
              <description>Power down quantization noise cancellation DAC
1'b0: no power down
1'b1: power down</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BYPASS</name>
              <description>PLL Bypass.    FREF bypasses PLL to FOUTPOSTDIV
1'b0: no bypass
1'b1: bypass</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POWER_DOWN</name>
              <description>Global power down
1'b0: no power down
1'b1: power down</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_VPLL_CON4</name>
          <description>VPLL configuration register4</description>
          <addressOffset>0xd0</addressOffset>
          <size>32</size>
          <resetValue>0x7</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>SSMOD_SPREAD</name>
              <description>spread amplitude
% = 0.1 * SPREAD[4:0]</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSMOD_DIVVAL</name>
              <description>Divider required to set the modulation frequency
Divider required to set the modulation frequency</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSMOD_DOWNSPREAD</name>
              <description>Selects center spread or downs pread
1'b0: center spread
1'b1: down spread</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSMOD_RESET</name>
              <description>Reset modulator state
1'b0: no reset
1'b1: reset</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSMOD_DISABLE_SSCG</name>
              <description>Bypass SSMOD by module
1'b0: no bypass
1'b1: bypass</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSMOD_BP</name>
              <description>Bypass SSMOD by integration
1'b0: no bypass
1'b1: bypass</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_VPLL_CON5</name>
          <description>VPLL configuration register5</description>
          <addressOffset>0xd4</addressOffset>
          <size>32</size>
          <resetValue>0x7f00</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>SSMOD_EXT_MAXADDR</name>
              <description>External wave table data inputs
(0-255)</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSMOD_SEL_EXT_WAVE</name>
              <description>select external wave
1'b0: no select ext_wave
1'b1: select ext_wave</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON0</name>
          <description>Internal clock select and divide register0</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <resetValue>0x101</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>ACLKM_CORE_L_DIV_CON</name>
              <description>aclkm_core_l divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_CORE_L_PLL_SEL</name>
              <description>clk_core_l clock source select control register
2'b00:LPLL
2'b01:BPLL
2'b10:DPLL
2'b11:GPLL</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_CORE_L_DIV_CON</name>
              <description>clk_core_l divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON1</name>
          <description>Internal clock select and divide register1</description>
          <addressOffset>0x104</addressOffset>
          <size>32</size>
          <resetValue>0x303</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PCLK_DBG_L_DIV_CON</name>
              <description>pclk_dbg_l divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ATCLK_CORE_L_DIV_CON</name>
              <description>atclk_core_l divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON2</name>
          <description>Internal clock select and divide register2</description>
          <addressOffset>0x108</addressOffset>
          <size>32</size>
          <resetValue>0x141</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>ACLKM_CORE_B_DIV_CON</name>
              <description>aclkm_core_b divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_CORE_B_PLL_SEL</name>
              <description>clk_core_b clock source select control register
2'b00:LPLL
2'b01:BPLL
2'b10:DPLL
2'b11:GPLL</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_CORE_B_DIV_CON</name>
              <description>clk_core_b divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON3</name>
          <description>Internal clock select and divide register3</description>
          <addressOffset>0x10c</addressOffset>
          <size>32</size>
          <resetValue>0x6303</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PCLKEN_DBG_B_DIV_CON</name>
              <description>pclken_dbg_b divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[14:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_DBG_B_DIV_CON</name>
              <description>pclk_dbg_b divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ATCLK_CORE_B_DIV_CON</name>
              <description>atclk_core_b divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON4</name>
          <description>Internal clock select and divide register4</description>
          <addressOffset>0x110</addressOffset>
          <size>32</size>
          <resetValue>0x41</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CLK_CS_PLL_SEL</name>
              <description>clk_cs clock source select control register
2'b00:CPLL
2'b01:GPLL
2'b1x:NPLL</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_CS_DIV_CON</name>
              <description>clk_cs divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON5</name>
          <description>Internal clock select and divide register5</description>
          <addressOffset>0x114</addressOffset>
          <size>32</size>
          <resetValue>0x8341</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CLK_CCI_TRACE_PLL_SEL</name>
              <description>clk_cci_trace clock source select control register
1'b0:CPLL
1'b1:GPLL</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_CCI_TRACE_DIV_CON</name>
              <description>clk_cci_trace divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_CCI_PLL_SEL</name>
              <description>aclk_cci clock source select control register
2'b00:CPLL
2'b01:GPLL
2'b10:NPLL
2'b11:VPLL</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_CCI_DIV_CON</name>
              <description>aclk_cci divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON6</name>
          <description>Internal clock select and divide register6</description>
          <addressOffset>0x118</addressOffset>
          <size>32</size>
          <resetValue>0x320</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PCLK_DDR_PLL_SEL</name>
              <description>pclk_ddr clock source select control register
1'b0:CPLL
1'b1:GPLL</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_DDR_DIV_CON</name>
              <description>pclk_ddr divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_DDRC_PLL_SEL</name>
              <description>clk_ddrc clock source select control register
2'b00:LPLL
2'b01:BPLL
2'b10:DPLL
2'b11:GPLL</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_DDRC_DIV_CON</name>
              <description>clk_ddrc divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON7</name>
          <description>Internal clock select and divide register7</description>
          <addressOffset>0x11c</addressOffset>
          <size>32</size>
          <resetValue>0x101</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>HCLK_VCODEC_DIV_CON</name>
              <description>hclk_vcodec divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_VCODEC_PLL_SEL</name>
              <description>aclk_vcodec clock source select control register
2'b00:CPLL
2'b01:GPLL
2'b10:NPLL
2'b11:PPLL</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_VCODEC_DIV_CON</name>
              <description>aclk_vcodec divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON8</name>
          <description>Internal clock select and divide register8</description>
          <addressOffset>0x120</addressOffset>
          <size>32</size>
          <resetValue>0x101</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>HCLK_VDU_DIV_CON</name>
              <description>hclk_vdu divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_VDU_PLL_SEL</name>
              <description>aclk_vdu clock source select control register
2'b00:CPLL
2'b01:GPLL
2'b10:NPLL
2'b11:PPLL</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_VDU_DIV_CON</name>
              <description>aclk_vdu divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON9</name>
          <description>Internal clock select and divide register9</description>
          <addressOffset>0x124</addressOffset>
          <size>32</size>
          <resetValue>0x4141</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CLK_VDU_CA_PLL_SEL</name>
              <description>clk_vdu_ca clock source select control register
2'b00:CPLL
2'b01:GPLL
2'b1x:NPLL</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_VDU_CA_DIV_CON</name>
              <description>clk_vdu_ca divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_VDU_CORE_PLL_SEL</name>
              <description>clk_vdu_core clock source select control register
2'b00:CPLL
2'b01:GPLL
2'b1x:NPLL</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_VDU_CORE_DIV_CON</name>
              <description>clk_vdu_core divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON10</name>
          <description>Internal clock select and divide register10</description>
          <addressOffset>0x128</addressOffset>
          <size>32</size>
          <resetValue>0x101</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>HCLK_IEP_DIV_CON</name>
              <description>hclk_iep divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_IEP_PLL_SEL</name>
              <description>aclk_iep clock source select control register
2'b00:CPLL
2'b01:GPLL
2'b10:NPLL
2'b11:PPLL</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_IEP_DIV_CON</name>
              <description>aclk_iep divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON11</name>
          <description>Internal clock select and divide register11</description>
          <addressOffset>0x12c</addressOffset>
          <size>32</size>
          <resetValue>0x101</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>HCLK_RGA_DIV_CON</name>
              <description>hclk_rga divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_RGA_PLL_SEL</name>
              <description>aclk_rga clock source select control register
2'b00:CPLL
2'b01:GPLL
2'b10:NPLL
2'b11:PPLL</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_RGA_DIV_CON</name>
              <description>aclk_rga divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON12</name>
          <description>Internal clock select and divide register12</description>
          <addressOffset>0x130</addressOffset>
          <size>32</size>
          <resetValue>0x100</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>ACLK_CENTER_PLL_SEL</name>
              <description>aclk_center clock source select control register
2'b00:CPLL
2'b01:GPLL
2'b1x:NPLL</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_CENTER_DIV_CON</name>
              <description>aclk_center divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_RGA_CORE_PLL_SEL</name>
              <description>clk_rga_core clock source select control register
2'b00:CPLL
2'b01:GPLL
2'b10:NPLL
2'b11:PPLL</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_RGA_CORE_DIV_CON</name>
              <description>clk_rga_core divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON13</name>
          <description>Internal clock select and divide register13</description>
          <addressOffset>0x134</addressOffset>
          <size>32</size>
          <resetValue>0x361</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>HCLK_SD_SRC_SEL</name>
              <description>hclk_sd clock source select control register
1'b0:CPLL
1'b1:GPLL</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HCLK_SD_DIV_CON</name>
              <description>hclk_sd divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_GPU_PLL_SEL</name>
              <description>aclk_gpu clock source select control register
3'b000:PPLL
3'b001:CPLL
3'b010:GPLL
3'b011:NPLL
3'b100:USB_480M</description>
              <bitRange>[7:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_GPU_DIV_CON</name>
              <description>aclk_gpu divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON14</name>
          <description>Internal clock select and divide register14</description>
          <addressOffset>0x138</addressOffset>
          <size>32</size>
          <resetValue>0x3181</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CLK_USBPLL_480M_SEL</name>
              <description>clk_usbpll_480m_sel clock select control register
1'b0:xin_24m
1'b1:clk_usbphy_480m</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_PERIHP_DIV_CON</name>
              <description>pclk_perihp divider control register
clk=aclk_perihp/(div_con+1)</description>
              <bitRange>[14:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HCLK_PERIHP_DIV_CON</name>
              <description>hclk_perihp divider control register
clk=aclk_perihp/(div_con+1)</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_PERIHP_PLL_SEL</name>
              <description>aclk_perihp clock source select control register
1'b0:CPLL
1'b1:GPLL</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_USBPHY_480M_CH_SEL</name>
              <description>clk_usbphy_480m clock channel select control register
1'b0:usb_phy0_480m
1'b1:usb_phy1_480m</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_PERIHP_DIV_CON</name>
              <description>aclk_perihp divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON15</name>
          <description>Internal clock select and divide register15</description>
          <addressOffset>0x13c</addressOffset>
          <size>32</size>
          <resetValue>0x500</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CLK_SDIO_PLL_SEL</name>
              <description>clk_sdio clock source select control register
3'b000:CPLL
3'b001:GPLL
3'b010:NPLL
3'b011:PPLL
3'b100:USB_480M
3'b101:xin_24m</description>
              <bitRange>[10:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_SDIO_DIV_CON</name>
              <description>clk_sdio divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON16</name>
          <description>Internal clock select and divide register16</description>
          <addressOffset>0x140</addressOffset>
          <size>32</size>
          <resetValue>0x500</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CLK_SDMMC_PLL_SEL</name>
              <description>clk_sdmmc clock source select control register
3'b000:CPLL
3'b001:GPLL
3'b010:NPLL
3'b011:PPLL
3'b100:USB_480M
3'b101:xin_24m</description>
              <bitRange>[10:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_SDMMC_DIV_CON</name>
              <description>clk_sdmmc divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON17</name>
          <description>Internal clock select and divide register17</description>
          <addressOffset>0x144</addressOffset>
          <size>32</size>
          <resetValue>0x300</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CLK_PCIE_PM_PLL_SEL</name>
              <description>clk_pcie_pm clock source select control register
3'b000:CPLL
3'b001:GPLL
3'b010:NPLL
3'b011:xin_24m
3'b1xx:reserved</description>
              <bitRange>[10:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_PCIE_PM_DIV_CON</name>
              <description>clk_pcie_pm divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON18</name>
          <description>Internal clock select and divide register18</description>
          <addressOffset>0x148</addressOffset>
          <size>32</size>
          <resetValue>0x4a87</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CLK_PCIEPHY_REF100M_DIV_CON</name>
              <description>clk_pciephy_ref100m divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[15:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_PCIEPHY_REF_SEL</name>
              <description>clk_pciephy_ref clock select control register
1'b0:clk_pcie_ref24m
1'b1:clk_pcie_ref100m</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_PCIE_CORE_PLL_SEL</name>
              <description>clk_pcie_core clock source select control register
2'b00:CPLL
2'b01:GPLL
2'b1x:NPLL</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_PCIE_CORE_CLK_SEL</name>
              <description>clk_pcie_core clock select control register
1'b0:clk_pcie_core
1'b1:pipe_clk_pcie from PCIE PHY</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_PCIE_CORE_DIV_CON</name>
              <description>clk_pcie_core divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON19</name>
          <description>Internal clock select and divide register19</description>
          <addressOffset>0x14c</addressOffset>
          <size>32</size>
          <resetValue>0x100</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PCLK_GMAC_DIV_CON</name>
              <description>pclk_gmac divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[10:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_RMII_SRC_SEL</name>
              <description>clk_rmii_src clock select control register
1'b0:clk_mac_divout
1'b1:rmii_clkin from IO</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_HSICPHY_PLL_SEL</name>
              <description>clk_hsicphy clock source select control register
2'b00:CPLL
2'b01:GPLL
2'b10:NPLL
2'b11:USB_480M</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON20</name>
          <description>Internal clock select and divide register20</description>
          <addressOffset>0x150</addressOffset>
          <size>32</size>
          <resetValue>0x9303</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CLK_GMAC_PLL_SEL</name>
              <description>clk_gmac clock source select control register
2'b00:CPLL
2'b01:GPLL
2'b1x:NPLL</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_GMAC_DIV_CON</name>
              <description>clk_gmac divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_GMAC_PLL_SEL</name>
              <description>aclk_gmac clock source select control register
1'b0:CPLL
1'b1:GPLL</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_GMAC_DIV_CON</name>
              <description>aclk_gmac divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON21</name>
          <description>Internal clock select and divide register21</description>
          <addressOffset>0x154</addressOffset>
          <size>32</size>
          <resetValue>0x3</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>ACLK_EMMC_PLL_SEL</name>
              <description>aclk_emmc clock source select control register
1'b0:CPLL
1'b1:GPLL</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_EMMC_DIV_CON</name>
              <description>aclk_emmc divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON22</name>
          <description>Internal clock select and divide register22</description>
          <addressOffset>0x158</addressOffset>
          <size>32</size>
          <resetValue>0x400</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CLK_EMMC_PLL_SEL</name>
              <description>clk_emmc clock source select control register
3'b000:CPLL
3'b001:GPLL
3'b010:NPLL
3'b011:USB_480M
3'b1xx:xin_24m</description>
              <bitRange>[10:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_EMMC_DIV_CON</name>
              <description>clk_emmc divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON23</name>
          <description>Internal clock select and divide register23</description>
          <addressOffset>0x15c</addressOffset>
          <size>32</size>
          <resetValue>0x3181</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PCLK_PERILP0_DIV_CON</name>
              <description>perilp0_pclk divider control register
clk=aclk_perilp0/(div_con+1)</description>
              <bitRange>[14:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HCLK_PERILP0_DIV_CON</name>
              <description>perilp0_hclk divider control register
clk=aclk_perilp0/(div_con+1)</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_PERILP0_PLL_SEL</name>
              <description>aclk_perilp0 clock source select control register
1'b0:CPLL
1'b1:GPLL</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_PERILP0_DIV_CON</name>
              <description>aclk_perilp0 divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON24</name>
          <description>Internal clock select and divide register24</description>
          <addressOffset>0x160</addressOffset>
          <size>32</size>
          <resetValue>0x8103</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>FCLK_CM0S_PLL_SEL</name>
              <description>fclk_cm0s clock source select control register
1'b0:CPLL
1'b1:GPLL</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FCLK_CM0S_DIV_CON</name>
              <description>fclk_cm0s divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_CRYPTO0_PLL_SEL</name>
              <description>clk_crypto0 clock source select control register
2'b00:CPLL
2'b01:GPLL
2'b10:PPLL</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_CRYPTO0_DIV_CON</name>
              <description>clk_crypto0 divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON25</name>
          <description>Internal clock select and divide register25</description>
          <addressOffset>0x164</addressOffset>
          <size>32</size>
          <resetValue>0x183</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PCLK_PERILP1_DIV_CON</name>
              <description>pclk_perilp1 divider control register
clk=hclk_perilp1/(div_con+1)</description>
              <bitRange>[10:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HCLK_PERILP1_PLL_SEL</name>
              <description>hclk_perilp1 clock source select control register
1'b0:CPLL
1'b1:GPLL</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HCLK_PERILP1_DIV_CON</name>
              <description>hclk_perilp1 divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON26</name>
          <description>Internal clock select and divide register26</description>
          <addressOffset>0x168</addressOffset>
          <size>32</size>
          <resetValue>0x103</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CLK_SARADC_DIV_CON</name>
              <description>clk_saradc divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_CRYPTO1_PLL_SEL</name>
              <description>clk_crypto1 clock source select control register
2'b00:CPLL
2'b01:GPLL
2'b10:PPLL</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_CRYPTO1_DIV_CON</name>
              <description>clk_crypto1 divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON27</name>
          <description>Internal clock select and divide register27</description>
          <addressOffset>0x16c</addressOffset>
          <size>32</size>
          <resetValue>0x2dc</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CLK_TSADC_SEL</name>
              <description>clk tsadc clock select control register
1'b0:xin_24m
1'b1:clk_32k</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_TSADC_DIV_CON</name>
              <description>clk tsadc divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON28</name>
          <description>Internal clock select and divide register28</description>
          <addressOffset>0x170</addressOffset>
          <size>32</size>
          <resetValue>0x300</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CLK_I2S0_SEL</name>
              <description>clk_i2s0 clock select control register
2'b00:clk_i2s0_divout
2'b01:clk_i2s0_frac
2'b10:clkin_i2s from IO
2'b11:clk_12m</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_I2S0_PLL_SEL</name>
              <description>clk_i2s0 clock source select control register
1'b0:CPLL
1'b1:GPLL</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_I2S0_DIV_CON</name>
              <description>clk_i2s0 divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON29</name>
          <description>Internal clock select and divide register29</description>
          <addressOffset>0x174</addressOffset>
          <size>32</size>
          <resetValue>0x300</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CLK_I2S1_SEL</name>
              <description>clk_i2s1 clock select control register
2'b00:clk_i2s1_divout
2'b01:clk_i2s1_frac
2'b10:clkin_i2s from IO
2'b11:clk_12m</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_I2S1_PLL_SEL</name>
              <description>clk_i2s1 clock source select control register
1'b0:CPLL
1'b1:GPLL</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_I2S1_DIV_CON</name>
              <description>clk_i2s1 divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON30</name>
          <description>Internal clock select and divide register30</description>
          <addressOffset>0x178</addressOffset>
          <size>32</size>
          <resetValue>0x300</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CLK_I2S2_SEL</name>
              <description>clk_i2s2 clock select control register
2'b00:clk_i2s2_divout
2'b01:clk_i2s2_frac
2'b10:clkin_i2s2 from IO
2'b11:clk_12m</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_I2S2_PLL_SEL</name>
              <description>clk_i2s2 clock source select control register
1'b0:CPLL
1'b1:GPLL</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_I2S2_DIV_CON</name>
              <description>clk_i2s2 divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON31</name>
          <description>Internal clock select and divide register31</description>
          <addressOffset>0x17c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CLK_I2SOUT_SEL</name>
              <description>clk_i2sout clock select control register
1'b0:clk_i2s
1'b1:clk_12m</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_I2S_CH_SEL</name>
              <description>clk_i2s_ch clock select control register
2'b00:clk_i2s0
2'b01:clk_i2s1
2'b10:clk_i2s2</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON32</name>
          <description>Internal clock select and divide register32</description>
          <addressOffset>0x180</addressOffset>
          <size>32</size>
          <resetValue>0x6300</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CLK_DPTX_SPDIF_REC_PLL_SEL</name>
              <description>clk_dptx_spdif_rec clock source select control register
1'b0:CPLL
1'b1:GPLL</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_SPDIF_8CH_CLK_SEL</name>
              <description>clk_spdif_8ch clock select control register
2'b00:clk_spdif_divout
2'b01:clk_spdif_frac
2'b10:clkin_spdif from IO SAME AS clkin_i2s
2'b11:clk_12m</description>
              <bitRange>[14:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_DPTX_SPDIF_REC_DIV_CON</name>
              <description>clk_dptx_spdif_rec divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_SPDIF_8CH_PLL_SEL</name>
              <description>clk_spdif_8ch clock source select control register
1'b0:CPLL
1'b1:GPLL</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_SPDIF_8CH_PLL_DIV_CON</name>
              <description>clk_spdif_8ch_pll divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON33</name>
          <description>Internal clock select and divide register33</description>
          <addressOffset>0x184</addressOffset>
          <size>32</size>
          <resetValue>0x200</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CLK_UART_PLL_SEL</name>
              <description>clk_uart clock source select control register
1'b0:CPLL
1'b1:GPLL</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_UART0_SRC_SEL</name>
              <description>clk_uart0_src clock select control register
2'b00:CPLL
2'b01:GPLL
2'b1x:USB_480M</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_UART0_SEL</name>
              <description>clk_uart0 clock select control register
2'b00:clk_uart0_divout
2'b01:clk_uart0_frac
2'b10:xin_24m</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_UART0_DIV_CON</name>
              <description>clk_uart0 divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON34</name>
          <description>Internal clock select and divide register34</description>
          <addressOffset>0x188</addressOffset>
          <size>32</size>
          <resetValue>0x200</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLK_WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CLK_UART1_SEL</name>
              <description>clk_uart1 clock select control register
2'b00:clk_uart1_divout
2'b01:clk_uart1_frac
2'b10:xin_24m</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_UART1_DIV_CON</name>
              <description>clk_uart1 divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON35</name>
          <description>Internal clock select and divide register35</description>
          <addressOffset>0x18c</addressOffset>
          <size>32</size>
          <resetValue>0x200</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CLK_UART2_SEL</name>
              <description>clk_uart2 clock select control register
2'b00:clk_uart2_divout
2'b01:clk_uart2_frac
2'b10:xin_24m</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_UART2_DIV_CON</name>
              <description>clk_uart2 divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON36</name>
          <description>Internal clock select and divide register36</description>
          <addressOffset>0x190</addressOffset>
          <size>32</size>
          <resetValue>0x200</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CLK_UART3_SEL</name>
              <description>clk_uart3 clock select control register
2'b00:clk_uart3_divout
2'b01:clk_uart3_frac
2'b10:xin_24m</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_UART3_DIV_CON</name>
              <description>clk_uart3 divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON38</name>
          <description>Internal clock select and divide register38</description>
          <addressOffset>0x198</addressOffset>
          <size>32</size>
          <resetValue>0x3f3f</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CLK_TESTOUT2_PLL_SEL</name>
              <description>clk_testout2 clock source select control register
2'b00:CPLL
2'b01:GPLL
2'b1x:NPLL</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_TESTOUT2_CLK_SEL</name>
              <description>clk_testout2 clock select control register
1'b0:clk_testout_src
1'b1:xin_24m</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_TESTOUT2_DIV_CON</name>
              <description>clk_testout2 divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_TESTOUT1_PLL_SEL</name>
              <description>clk_testout1 clock source select control register
2'b00:CPLL
2'b01:GPLL
2'b1x:NPLL</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_TESTOUT1_CLK_SEL</name>
              <description>clk_testout1 clock select control register
1'b0:clk_testout_src
1'b1:xin_24m</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_TESTOUT1_DIV_CON</name>
              <description>clk_testout1 divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON39</name>
          <description>Internal clock select and divide register39</description>
          <addressOffset>0x19c</addressOffset>
          <size>32</size>
          <resetValue>0x41</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>ACLK_USB3_PLL_SEL</name>
              <description>aclk_usb3 clock source select control register
2'b00:CPLL
2'b01:GPLL
2'b1x:NPLL</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_USB3_DIV_CON</name>
              <description>aclk_usb3 divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON40</name>
          <description>Internal clock select and divide register40</description>
          <addressOffset>0x1a0</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CLK_USB3_OTG0_SUSPEND_SRC_SEL</name>
              <description>clk_usb3_otg0_suspend_src clock select control register
1'b0:xin_24m
1'b1:clk_32k</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_USB3_OTG0_SUSPEND_DIV_CON</name>
              <description>clk_usb3_otg0_suspend divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON41</name>
          <description>Internal clock select and divide register41</description>
          <addressOffset>0x1a4</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CLK_USB3_OTG1_SUSPEND_SRC_SEL</name>
              <description>clk_usb3_otg1_suspend_src clock select control register
1'b0:xin_24m
1'b1:clk_32k</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_USB3_OTG1_SUSPEND_DIV_CON</name>
              <description>clk_usb3_otg1_suspend divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON42</name>
          <description>Internal clock select and divide register42</description>
          <addressOffset>0x1a8</addressOffset>
          <size>32</size>
          <resetValue>0x101</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>ACLK_HDCP_PLL_SEL</name>
              <description>aclk_hdcp clock source select control register
2'b00:CPLL
2'b01:GPLL
2'b10:PPLL</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_HDCP_DIV_CON</name>
              <description>aclk_hdcp divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_VIO_PLL_SEL</name>
              <description>aclk_vio clock source select control register
2'b00:CPLL
2'b01:GPLL
2'b10:PPLL</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_VIO_DIV_CON</name>
              <description>aclk_vio divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON43</name>
          <description>Internal clock select and divide register43</description>
          <addressOffset>0x1ac</addressOffset>
          <size>32</size>
          <resetValue>0x421</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PCLK_HDCP_DIV_CON</name>
              <description>pclk_hdcp divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[14:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HCLK_HDCP_DIV_CON</name>
              <description>hclk_hdcp divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[9:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_VIO_DIV_CON</name>
              <description>pclk_vio divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON44</name>
          <description>Internal clock select and divide register44</description>
          <addressOffset>0x1b0</addressOffset>
          <size>32</size>
          <resetValue>0x700</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PCLK_EDP_PLL_SEL</name>
              <description>pclk_edp clock source select control register
1'b0:CPLL
1'b1:GPLL</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_EDP_DIV_CON</name>
              <description>pclk_edp divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[13:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON45</name>
          <description>Internal clock select and divide register45</description>
          <addressOffset>0x1b4</addressOffset>
          <size>32</size>
          <resetValue>0x2dc</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CLK_HDMI_CEC_SRC_SEL</name>
              <description>clk_hdmi_cec_src clock select control register
1'b0:clk_32k
1'b1:xin_24m</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_HDMI_CEC_DIV_CON</name>
              <description>clk_hdmi_cec divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON46</name>
          <description>Internal clock select and divide register46</description>
          <addressOffset>0x1b8</addressOffset>
          <size>32</size>
          <resetValue>0x4</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CLK_DP_CORE_PLL_SEL</name>
              <description>clk_dp_core clock source select control register
2'b00:NPLL
2'b01:CPLL
2'b10:GPLL</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_DP_CORE_DIV_CON</name>
              <description>clk_dp_core divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON47</name>
          <description>Internal clock select and divide register47</description>
          <addressOffset>0x1bc</addressOffset>
          <size>32</size>
          <resetValue>0x102</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>HCLK_VOP0_DIV_CON</name>
              <description>hclk_vop0 divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_VOP0_PLL_SEL</name>
              <description>aclk_vop0 clock source select control register
2'b00:VPLL
2'b01:CPLL
2'b10:GPLL
2'b11:NPLL</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_VOP0_DIV_CON</name>
              <description>aclk_vop0 divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON48</name>
          <description>Internal clock select and divide register48</description>
          <addressOffset>0x1c0</addressOffset>
          <size>32</size>
          <resetValue>0x102</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>HCLK_VOP1_DIV_CON</name>
              <description>hclk_vop1 divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_VOP1_PLL_SEL</name>
              <description>aclk_vop1 clock source select control register
2'b00:VPLL
2'b01:CPLL
2'b10:GPLL
2'b11:NPLL</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_VOP1_DIV_CON</name>
              <description>aclk_vop1 divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON49</name>
          <description>Internal clock select and divide register49</description>
          <addressOffset>0x1c4</addressOffset>
          <size>32</size>
          <resetValue>0x1</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DCLK_VOP0_DCLK_SEL</name>
              <description>dclk_vop0 clock select control register
1'b0:dclk_vop_divout
1'b1:dclk_vop_frac</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DCLK_VOP0_PLL_SEL</name>
              <description>dclk_vop0 clock source select control register
2'b00:VPLL
2'b01:CPLL
2'b1x:GPLL</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DCLK_VOP0_DIV_CON</name>
              <description>dclk_vop0 divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON50</name>
          <description>Internal clock select and divide register50</description>
          <addressOffset>0x1c8</addressOffset>
          <size>32</size>
          <resetValue>0x3</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DCLK_VOP1_DCLK_SEL</name>
              <description>dclk_vop1 clock select control register
1'b0:dclk_vop_divout
1'b1:dclk_vop_frac</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DCLK_VOP1_PLL_SEL</name>
              <description>dclk_vop1 clock source select control register
2'b00:VPLL
2'b01:CPLL
2'b1x:GPLL</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DCLK_VOP1_DIV_CON</name>
              <description>vop1 divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON51</name>
          <description>Internal clock select and divide register51</description>
          <addressOffset>0x1cc</addressOffset>
          <size>32</size>
          <resetValue>0x5</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CLK_VOP0_PWM_SRC_SEL</name>
              <description>vop0_pwm_src clock select control register
2'b00:VPLL
2'b01:CPLL
2'b1x:GPLL</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_VOP0_PWM_DIV_CON</name>
              <description>vop0_pwm divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON52</name>
          <description>Internal clock select and divide register52</description>
          <addressOffset>0x1d0</addressOffset>
          <size>32</size>
          <resetValue>0x5</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CLK_VOP1_PWM_SRC_SEL</name>
              <description>vop1_pwm_src clock select control register
2'b00:VPLL
2'b01:CPLL
2'b1x:GPLL</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_VOP1_PWM_DIV_CON</name>
              <description>vop1_pwm divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON53</name>
          <description>Internal clock select and divide register53</description>
          <addressOffset>0x1d4</addressOffset>
          <size>32</size>
          <resetValue>0x101</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>HCLK_ISP0_DIV_CON</name>
              <description>hclk_isp0 divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_ISP0_PLL_SEL</name>
              <description>aclk_isp0 clock source select control register
2'b00:CPLL
2'b01:GPLL
2'b10:PPLL</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_ISP0_DIV_CON</name>
              <description>aclk_isp0 divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON54</name>
          <description>Internal clock select and divide register54</description>
          <addressOffset>0x1d8</addressOffset>
          <size>32</size>
          <resetValue>0x101</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>HCLK_ISP1_DIV_CON</name>
              <description>hclk_isp1 divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_ISP1_PLL_SEL</name>
              <description>aclk_isp1 clock source select control register
2'b00:CPLL
2'b01:GPLL
2'b10:PPLL</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_ISP1_DIV_CON</name>
              <description>aclk_isp1 divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON55</name>
          <description>Internal clock select and divide register55</description>
          <addressOffset>0x1dc</addressOffset>
          <size>32</size>
          <resetValue>0x8181</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CLK_ISP1_PLL_SEL</name>
              <description>clk_isp1 clock source select control register
2'b00:CPLL
2'b01:GPLL
2'b1x:NPLL</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_ISP1_DIV_CON</name>
              <description>clk_isp1 divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_ISP0_PLL_SEL</name>
              <description>clk_isp0 clock source select control register
2'b00:CPLL
2'b01:GPLL
2'b1x:NPLL</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_ISP0_DIV_CON</name>
              <description>clk_isp0 divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON56</name>
          <description>Internal clock select and divide register56</description>
          <addressOffset>0x1e0</addressOffset>
          <size>32</size>
          <resetValue>0x320</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>ACLK_GIC_PLL_SEL</name>
              <description>aclk_gic source select control register
1'b0:CPLL
1'b1:GPLL</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_GIC_DIV_CON</name>
              <description>aclk_gic divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_CIF_PLL_SEL</name>
              <description>clk_cif clock source select control register
2'b00:CPLL
2'b01:GPLL
2'b1x:NPLL</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_CIF_CLK_SEL</name>
              <description>clk_cif clock select control register
1'b0:clk_cif_src
1'b1:xin_24m</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_CIF_DIV_CON</name>
              <description>clk_cif divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON57</name>
          <description>Internal clock select and divide register57</description>
          <addressOffset>0x1e4</addressOffset>
          <size>32</size>
          <resetValue>0x5</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CLKOUT_24M_DIV_CON</name>
              <description>clkout_24m divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[15:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_ALIVE_DIV_CON</name>
              <description>pclk_alive divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON58</name>
          <description>Internal clock select and divide register58</description>
          <addressOffset>0x1e8</addressOffset>
          <size>32</size>
          <resetValue>0x71f</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CLK_SPI5_PLL_SEL</name>
              <description>clk_spi5 clock source select control register
1'b0:CPLL
1'b1:GPLL</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_SPI5_DIV_CON</name>
              <description>spi5 divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[14:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_TESTFRAC_PLL_SEL</name>
              <description>clk_frac clock source select control register
1'b0:CPLL
1'b1:GPLL</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_TEST_DIV_CON</name>
              <description>test divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON59</name>
          <description>Internal clock select and divide register59</description>
          <addressOffset>0x1ec</addressOffset>
          <size>32</size>
          <resetValue>0x707</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CLK_SPI1_PLL_SEL</name>
              <description>clk_spi1 clock source select control register
1'b0:CPLL
1'b1:GPLL</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_SPI1_DIV_CON</name>
              <description>spi1 divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[14:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_SPI0_PLL_SEL</name>
              <description>clk_spi0 clock source select control register
1'b0:CPLL
1'b1:GPLL</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_SPI0_DIV_CON</name>
              <description>spi0 divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON60</name>
          <description>Internal clock select and divide register60</description>
          <addressOffset>0x1f0</addressOffset>
          <size>32</size>
          <resetValue>0x707</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CLK_SPI4_PLL_SEL</name>
              <description>clk_spi4 clock source select control register
1'b0:CPLL
1'b1:GPLL</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_SPI4_DIV_CON</name>
              <description>spi4 divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[14:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_SPI2_PLL_SEL</name>
              <description>clk_spi2 clock source select control register
1'b0:CPLL
1'b1:GPLL</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_SPI2_DIV_CON</name>
              <description>spi2 divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON61</name>
          <description>Internal clock select and divide register61</description>
          <addressOffset>0x1f4</addressOffset>
          <size>32</size>
          <resetValue>0x303</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CLK_I2C5_PLL_SEL</name>
              <description>clk_i2c5 clock source select control register
1'b0:CPLL
1'b1:GPLL</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_I2C5_DIV_CON</name>
              <description>i2c5 divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[14:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_I2C1_PLL_SEL</name>
              <description>clk_i2c1 clock source select control register
1'b0:CPLL
1'b1:GPLL</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_I2C1_DIV_CON</name>
              <description>i2c1 divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON62</name>
          <description>Internal clock select and divide register62</description>
          <addressOffset>0x1f8</addressOffset>
          <size>32</size>
          <resetValue>0x303</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CLK_I2C6_PLL_SEL</name>
              <description>clk_i2c6 clock source select control register
1'b0:CPLL
1'b1:GPLL</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_I2C6_DIV_CON</name>
              <description>i2c6 divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[14:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_I2C2_PLL_SEL</name>
              <description>clk_i2c2 clock source select control register
1'b0:CPLL
1'b1:GPLL</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_I2C2_DIV_CON</name>
              <description>i2c2 divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON63</name>
          <description>Internal clock select and divide register63</description>
          <addressOffset>0x1fc</addressOffset>
          <size>32</size>
          <resetValue>0x303</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CLK_I2C7_PLL_SEL</name>
              <description>clk_i2c7 clock source select control register
1'b0:CPLL
1'b1:GPLL</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_I2C7_DIV_CON</name>
              <description>i2c7 divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[14:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_I2C3_PLL_SEL</name>
              <description>clk_i2c3 clock source select control register
1'b0:CPLL
1'b1:GPLL</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_I2C3_DIV_CON</name>
              <description>i2c3 divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON64</name>
          <description>Internal clock select and divide register64</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <resetValue>0xc5</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CLK_UPHY0_TCPDPHY_REF_CLK_SEL</name>
              <description>clk_uphy0_tcpdphy_ref clock select control register
1'b0:xin_24m
1'b1:clk_32k</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_UPHY0_TCPDPHY_REF_DIV_CON</name>
              <description>clk_uphy0_tcpdphy_ref divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_UPHY0_TCPDCORE_CLK_SEL</name>
              <description>clk_uphy0_tcpdcore clock select control register
2'b00:xin_24m
2'b01:clk_32k
2'b10:cpll
2'b11:gpll</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_UPHY0_TCPDCORE_DIV_CON</name>
              <description>clk_uphy0_tcpdcore divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON65</name>
          <description>Internal clock select and divide register65</description>
          <addressOffset>0x204</addressOffset>
          <size>32</size>
          <resetValue>0xc5</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CLK_UPHY1_TCPDPHY_REF_CLK_SEL</name>
              <description>clk_uphy1_tcpdphy_ref clock select control register
1'b0:xin_24m
1'b1:clk_32k</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_UPHY1_TCPDPHY_REF_DIV_CON</name>
              <description>clk_uphy1_tcpdphy_ref divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_UPHY1_TCPDCORE_CLK_SEL</name>
              <description>clk_uphy1_tcpdcore clock select control register
2'b00:xin_24m
2'b01:clk_32k
2'b10:cpll
2'b11:gpll</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_UPHY1_TCPDCORE_DIV_CON</name>
              <description>clk_uphy1_tcpdcore divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON96</name>
          <description>Internal clock select and divide register80</description>
          <addressOffset>0x280</addressOffset>
          <size>32</size>
          <resetValue>0xbb8ea60</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLK_I2S0_FRAC_DIV_CON</name>
              <description>clk_i2s0_frac divider control register
Fout = Fsrc*numerator/denominator
High 16-bit for numerator
Low 16-bit for denominator</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON97</name>
          <description>Internal clock select and divide register81</description>
          <addressOffset>0x284</addressOffset>
          <size>32</size>
          <resetValue>0xbb8ea60</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLK_I2S1_FRAC_DIV_CON</name>
              <description>clk_i2s1_frac divider control register
Fout = Fsrc*numerator/denominator
High 16-bit for numerator
Low 16-bit for denominator</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON98</name>
          <description>Internal clock select and divide register82</description>
          <addressOffset>0x288</addressOffset>
          <size>32</size>
          <resetValue>0xbb8ea60</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLK_I2S2_FRAC_DIV_CON</name>
              <description>clk_i2s2_frac divider control register
Fout = Fsrc*numerator/denominator
High 16-bit for numerator
Low 16-bit for denominator</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON99</name>
          <description>Internal clock select and divide register83</description>
          <addressOffset>0x28c</addressOffset>
          <size>32</size>
          <resetValue>0xbb8ea60</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLK_SPDIF_8CH_FRAC_DIV_CON</name>
              <description>spdif_8ch_frac divider control register
Fout = Fsrc*numerator/denominator
High 16-bit for numerator
Low 16-bit for denominator</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON100</name>
          <description>Internal clock select and divide register84</description>
          <addressOffset>0x290</addressOffset>
          <size>32</size>
          <resetValue>0xbb8ea60</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLK_UART0_FRAC_DIV_CON</name>
              <description>uart0_frac divider control register
Fout = Fsrc*numerator/denominator
High 16-bit for numerator
Low 16-bit for denominator</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON101</name>
          <description>Internal clock select and divide register85</description>
          <addressOffset>0x294</addressOffset>
          <size>32</size>
          <resetValue>0xbb8ea60</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLK_UART1_FRAC_DIV_CON</name>
              <description>uart1_frac divider control register
Fout = Fsrc*numerator/denominator
High 16-bit for numerator
Low 16-bit for denominator</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON102</name>
          <description>Internal clock select and divide register86</description>
          <addressOffset>0x298</addressOffset>
          <size>32</size>
          <resetValue>0xbb8ea60</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLK_UART2_FRAC_DIV_CON</name>
              <description>uart2_frac divider control register
Fout = Fsrc*numerator/denominator
High 16-bit for numerator
Low 16-bit for denominator</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON103</name>
          <description>Internal clock select and divide register87</description>
          <addressOffset>0x29c</addressOffset>
          <size>32</size>
          <resetValue>0xbb8ea60</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLK_UART3_FRAC_DIV_CON</name>
              <description>uart3_frac divider control register
Fout = Fsrc*numerator/denominator
High 16-bit for numerator
Low 16-bit for denominator</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON105</name>
          <description>Internal clock select and divide register89</description>
          <addressOffset>0x2a4</addressOffset>
          <size>32</size>
          <resetValue>0xbb8ea60</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLK_TESTFRAC_FRAC_DIV_CON</name>
              <description>clk_testfrac frac divider control register
Fout = Fsrc*numerator/denominator
High 16-bit for numerator
Low 16-bit for denominator</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON106</name>
          <description>Internal clock select and divide register90</description>
          <addressOffset>0x2a8</addressOffset>
          <size>32</size>
          <resetValue>0xbb8ea60</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DCLK_VOP0_FRAC_DIV_CON</name>
              <description>dclk_vop0_frac divider control register
Fout = Fsrc*numerator/denominator
High 16-bit for numerator
Low 16-bit for denominator</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKSEL_CON107</name>
          <description>Internal clock select and divide register91</description>
          <addressOffset>0x2ac</addressOffset>
          <size>32</size>
          <resetValue>0xbb8ea60</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DCLK_VOP1_FRAC_DIV_CON</name>
              <description>dclk_vop1_frac divider control register
Fout = Fsrc*numerator/denominator
High 16-bit for numerator
Low 16-bit for denominator</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKGATE_CON0</name>
          <description>Internal clock gating register0</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CLK_PVTM_CORE_L_EN</name>
              <description>clk_pvtm_core_l clock disable bit
When HIGH, disable clock</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_COREDBG_L_EN</name>
              <description>pclk_coredbg_l clock disable bit
When HIGH, disable clock</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ATCLK_CORE_L_EN</name>
              <description>atclk_core_l clock disable bit
When HIGH, disable clock</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLKM_CORE_L_EN</name>
              <description>aclkm_core_l clock disable bit
When HIGH, disable clock</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_CORE_L_GPLL_SRC_EN</name>
              <description>clk_core_l_gpll clock disable bit
When HIGH, disable clock</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_CORE_L_DPLL_SRC_EN</name>
              <description>clk_core_l_dpll clock disable bit
When HIGH, disable clock</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_CORE_L_BPLL_SRC_EN</name>
              <description>clk_core_l_bpll clock disable bit
When HIGH, disable clock</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_CORE_L_LPLL_SRC_EN</name>
              <description>clk_core_l_lpll clock disable bit
When HIGH, disable clock</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKGATE_CON1</name>
          <description>Internal clock gating register1</description>
          <addressOffset>0x304</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CLK_PVTM_CORE_B_EN</name>
              <description>clk_pvtm_core_b clock disable bit
When HIGH, disable clock</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_COREDBG_B_EN</name>
              <description>pclk_coredbg_b clock disable bit
When HIGH, disable clock</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ATCLK_CORE_B_EN</name>
              <description>atclk_core_b clock disable bit
When HIGH, disable clock</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLKM_CORE_B_EN</name>
              <description>aclkm_core_b clock disable bit
When HIGH, disable clock</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_CORE_B_GPLL_SRC_EN</name>
              <description>clk_core_b_gpll clock disable bit
When HIGH, disable clock</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_CORE_B_DPLL_SRC_EN</name>
              <description>clk_core_b_dpll clock disable bit
When HIGH, disable clock</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_CORE_B_BPLL_SRC_EN</name>
              <description>clk_core_b_bpll clock disable bit
When HIGH, disable clock</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_CORE_B_LPLL_SRC_EN</name>
              <description>clk_core_b_lpll clock disable bit
When HIGH, disable clock</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKGATE_CON2</name>
          <description>Internal clock gating register2</description>
          <addressOffset>0x308</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CS_NPLL_CLK_EN</name>
              <description>cs_npll_clk clock disable bit
When HIGH, disable clock</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CS_GPLL_CLK_EN</name>
              <description>cs_gpll_clk clock disable bit
When HIGH, disable clock</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CS_CPLL_CLK_EN</name>
              <description>cs_cpll_clk clock disable bit
When HIGH, disable clock</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_CCI_TRACE_EN</name>
              <description>clk_cci_trace clock disable bit
When HIGH, disable clock</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_CCI_TRACE_GPLL_SRC_EN</name>
              <description>clk_cci_trace_gpll clock disable bit
When HIGH, disable clock</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_CCI_TRACE_CPLL_SRC_EN</name>
              <description>clk_cci_trace_cpll clock disable bit
When HIGH, disable clock</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_CCI_SRC_EN</name>
              <description>aclk_cci_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_CCI_VPLL_SRC_EN</name>
              <description>aclk_cci_vpll clock disable bit
When HIGH, disable clock</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_CCI_NPLL_SRC_EN</name>
              <description>aclk_cci_npll clock disable bit
When HIGH, disable clock</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_CCI_GPLL_SRC_EN</name>
              <description>aclk_cci_gpll clock disable bit
When HIGH, disable clock</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_CCI_CPLL_SRC_EN</name>
              <description>aclk_cci_cpll clock disable bit
When HIGH, disable clock</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKGATE_CON3</name>
          <description>Internal clock gating register3</description>
          <addressOffset>0x30c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>ACLK_CENTER_SRC_EN</name>
              <description>aclk_center_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_DDR_EN</name>
              <description>pclk_ddr clock disable bit
When HIGH, disable clock</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_DDRC_GPLL_SRC_EN</name>
              <description>clk_ddrc_gpll clock disable bit
When HIGH, disable clock</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_DDRC_DPLL_SRC_EN</name>
              <description>clk_ddrc_dpll clock disable bit
When HIGH, disable clock</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_DDRC_BPLL_SRC_EN</name>
              <description>clk_ddrc_bpll clock disable bit
When HIGH, disable clock</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_DDRC_LPLL_SRC_EN</name>
              <description>clk_ddrc_lpll clock disable bit
When HIGH, disable clock</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKGATE_CON4</name>
          <description>Internal clock gating register4</description>
          <addressOffset>0x310</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CLK_PVTM_DDR_EN</name>
              <description>clk_pvtm_ddr clock disable bit
When HIGH, disable clock</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_RGA_CORE_SRC_EN</name>
              <description>clk_rga_core_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HCLK_RGA_SRC_EN</name>
              <description>hclk_rga_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_RGA_SRC_EN</name>
              <description>aclk_rga_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HCLK_IEP_SRC_EN</name>
              <description>hclk_iep_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_IEP_SRC_EN</name>
              <description>aclk_iep_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_VDU_CA_SRC_EN</name>
              <description>clk_vdu_ca_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_VDU_CORE_SRC_EN</name>
              <description>clk_vdu_core_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HCLK_VDU_SRC_EN</name>
              <description>hclk_vdu_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_VDU_SRC_EN</name>
              <description>aclk_vdu_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HCLK_VCODEC_SRC_EN</name>
              <description>hclk_vcodec_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_VCODEC_SRC_EN</name>
              <description>aclk_vcodec_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKGATE_CON5</name>
          <description>Internal clock gating register5</description>
          <addressOffset>0x314</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CLK_MAC_TX_EN</name>
              <description>clk_mac_tx clock disable bit
When HIGH, disable clock</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_MAC_RX_EN</name>
              <description>clk_mac_rx clock disable bit
When HIGH, disable clock</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_MAC_REFOUT_EN</name>
              <description>clk_mac_refout clock disable bit
When HIGH, disable clock</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_MAC_REF_EN</name>
              <description>clk_mac_ref clock disable bit
When HIGH, disable clock</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_GMAC_SRC_EN</name>
              <description>clk_gmac_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_PERIHP_EN</name>
              <description>pclk_perihp clock disable bit
When HIGH, disable clock</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HCLK_PERIHP_EN</name>
              <description>hclk_perihp clock disable bit
When HIGH, disable clock</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_PERIHP_EN</name>
              <description>aclk_perihp clock disable bit
When HIGH, disable clock</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_PERIHP_CPLL_SRC_EN</name>
              <description>aclk_perihp_cpll clock disable bit
When HIGH, disable clock</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_PERIHP_GPLL_SRC_EN</name>
              <description>aclk_perihp_gpll clock disable bit
When HIGH, disable clock</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKGATE_CON6</name>
          <description>Internal clock gating register6</description>
          <addressOffset>0x318</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CLK_EMMC_SRC_EN</name>
              <description>clk_emmc_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_EMMC_CPLL_SRC_EN</name>
              <description>aclk_emmc_cpll clock disable bit
When HIGH, disable clock</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_EMMC_GPLL_SRC_EN</name>
              <description>aclk_emmc_gpll clock disable bit
When HIGH, disable clock</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_GMAC_EN</name>
              <description>pclk_gmac clock disable bit
When HIGH, disable clock</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_GMAC_EN</name>
              <description>aclk_gmac clock disable bit
When HIGH, disable clock</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_GMAC_CPLL_SRC_EN</name>
              <description>aclk_gmac_cpll clock disable bit
When HIGH, disable clock</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_GMAC_GPLL_SRC_EN</name>
              <description>aclk_gmac_gpll clock disable bit
When HIGH, disable clock</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_USB2PHY1_REF_EN</name>
              <description>clk_usb2phy1_ref clock disable bit
When HIGH, disable clock</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_USB2PHY0_REF_EN</name>
              <description>clk_usb2phy0_ref clock disable bit
When HIGH, disable clock</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_HSICPHY_EN</name>
              <description>clk_hsicphy clock disable bit
When HIGH, disable clock</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_PCIE_CORE_SRC_EN</name>
              <description>clk_pcie_core_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_PCIE_PM_SRC_EN</name>
              <description>clk_pcie_pm_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_SDMMC_SRC_EN</name>
              <description>clk_sdmmc_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_SDIO_SRC_EN</name>
              <description>clk_sdio_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKGATE_CON7</name>
          <description>Internal clock gating register7</description>
          <addressOffset>0x31c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>FCLK_CM0S_EN</name>
              <description>fclk_cm0s clock disable bit
When HIGH, disable clock</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_CRYPTO1_EN</name>
              <description>clk_crypto1 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_CRYPTO0_EN</name>
              <description>clk_crypto0 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_CM0S_CPLL_SRC_EN</name>
              <description>clk_cm0s_cpll clock disable bit
When HIGH, disable clock</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_CM0S_GPLL_SRC_EN</name>
              <description>clk_cm0s_gpll clock disable bit
When HIGH, disable clock</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_PERILP0_EN</name>
              <description>pclk_perilp0 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HCLK_PERILP0_EN</name>
              <description>hclk_perilp0 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_PERILP0_EN</name>
              <description>aclk_perilp0 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_PERILP0_CPLL_SRC_EN</name>
              <description>aclk_perilp0_cpll clock disable bit
When HIGH, disable clock</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_PERILP0_GPLL_SRC_EN</name>
              <description>aclk_perilp0_gpll clock disable bit
When HIGH, disable clock</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKGATE_CON8</name>
          <description>Internal clock gating register8</description>
          <addressOffset>0x320</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CLK_SPDIF_8CH_EN</name>
              <description>clk_spdif_8ch clock disable bit
When HIGH, disable clock</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_SPDIF_8CH_FRAC_SRC_EN</name>
              <description>clk_spdif_8ch_frac_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_SPDIF_8CH_SRC_EN</name>
              <description>clk_spdif_8ch_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_I2S_OUT_EN</name>
              <description>clk_i2s_out clock disable bit
When HIGH, disable clock</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_I2S2_EN</name>
              <description>clk_i2s2 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_I2S2_FRAC_SRC_EN</name>
              <description>clk_i2s2_frac_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_I2S2_SRC_EN</name>
              <description>clk_i2s2_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_I2S1_EN</name>
              <description>clk_i2s1 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_I2S1_FRAC_SRC_EN</name>
              <description>clk_i2s1_frac_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_I2S1_SRC_EN</name>
              <description>clk_i2s1_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_I2S0_EN</name>
              <description>clk_i2s0 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_I2S0_FRAC_SRC_EN</name>
              <description>clk_i2s0_frac_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_I2S0_SRC_EN</name>
              <description>clk_i2s0_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_PERILP1_EN</name>
              <description>pclk_perilp1 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HCLK_PERILP1_CPLL_SRC_EN</name>
              <description>hclk_perilp1_cpll clock disable bit
When HIGH, disable clock</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HCLK_PERILP1_GPLL_SRC_EN</name>
              <description>hclk_perilp1_gpll clock disable bit
When HIGH, disable clock</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKGATE_CON9</name>
          <description>Internal clock gating register9</description>
          <addressOffset>0x324</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CLK_SPI4_SRC_EN</name>
              <description>clk_spi4_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_SPI2_SRC_EN</name>
              <description>clk_spi2_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_SPI1_SRC_EN</name>
              <description>clk_spi1_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_SPI0_SRC_EN</name>
              <description>clk_spi0_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_SARADC_SRC_EN</name>
              <description>clk_saradc_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_TSADC_SRC_EN</name>
              <description>clk_tsadc_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_UART3_FRAC_SRC_EN</name>
              <description>clk_uart3_frac_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_UART3_SRC_EN</name>
              <description>clk_uart3_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_UART2_FRAC_SRC_EN</name>
              <description>clk_uart2_frac_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_UART2_SRC_EN</name>
              <description>clk_uart2_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_UART1_FRAC_SRC_EN</name>
              <description>clk_uart1_frac_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_UART1_SRC_EN</name>
              <description>clk_uart1_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_UART0_FRAC_SRC_EN</name>
              <description>clk_uart0_frac_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_UART0_SRC_EN</name>
              <description>clk_uart0_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKGATE_CON10</name>
          <description>Internal clock gating register10</description>
          <addressOffset>0x328</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CLK_VOP1_PWM_EN</name>
              <description>clk_vop1_pwm clock disable bit
When HIGH, disable clock</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_VOP0_PWM_EN</name>
              <description>clk_vop0_pwm clock disable bit
When HIGH, disable clock</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DCLK_VOP1_SRC_EN</name>
              <description>dclk_vop1_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DCLK_VOP0_SRC_EN</name>
              <description>dclk_vop0_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HCLK_VOP1_PRE_EN</name>
              <description>hclk_vop1_pre clock disable bit
When HIGH, disable clock</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_VOP1_PRE_SRC_EN</name>
              <description>aclk_vop1_pre_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HCLK_VOP0_PRE_EN</name>
              <description>hclk_vop0_pre clock disable bit
When HIGH, disable clock</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_VOP0_PRE_SRC_EN</name>
              <description>aclk_vop0_pre_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_CIF_OUT_SRC_EN</name>
              <description>clk_cif_out_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_DPTX_SPDIF_REC_SRC_EN</name>
              <description>clk_dptx_spdif_rec_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_I2C7_SRC_EN</name>
              <description>clk_i2c7_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_I2C3_SRC_EN</name>
              <description>clk_i2c3_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_I2C6_SRC_EN</name>
              <description>clk_i2c6_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_I2C2_SRC_EN</name>
              <description>clk_i2c2_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_I2C5_SRC_EN</name>
              <description>clk_i2c5_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_I2C1_SRC_EN</name>
              <description>clk_i2c1_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKGATE_CON11</name>
          <description>Internal clock gating register11</description>
          <addressOffset>0x32c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CLK_MIPIDPHY_CFG_EN</name>
              <description>clk_mipidphy_cfg clock disable bit
When HIGH, disable clock</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_MIPIDPHY_REF_EN</name>
              <description>clk_mipidphy_ref clock disable bit
When HIGH, disable clock</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_EDP_EN</name>
              <description>pclk_edp clock disable bit
When HIGH, disable clock</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_HDCP_EN</name>
              <description>pclk_hdcp clock disable bit
When HIGH, disable clock</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_DP_CORE_SRC_EN</name>
              <description>clk_dp_core_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_HDMI_CEC_EN</name>
              <description>clk_hdmi_cec clock disable bit
When HIGH, disable clock</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_HDMI_SFR_EN</name>
              <description>clk_hdmi_sfr clock disable bit
When HIGH, disable clock</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_ISP1_EN</name>
              <description>clk_isp1 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_ISP0_EN</name>
              <description>clk_isp0 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HCLK_HDCP_EN</name>
              <description>hclk_hdcp clock disable bit
When HIGH, disable clock</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_HDCP_SRC_EN</name>
              <description>aclk_hdcp_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_VIO_EN</name>
              <description>pclk_vio clock disable bit
When HIGH, disable clock</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_VIO_SRC_EN</name>
              <description>aclk_vio_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKGATE_CON12</name>
          <description>Internal clock gating register12</description>
          <addressOffset>0x330</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>HCLK_SD_SRC_EN</name>
              <description>hclk_sd_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_GIC_SRC_EN</name>
              <description>aclk_gic_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HCLK_ISP1_EN</name>
              <description>hclk_isp1 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_ISP1_SRC_EN</name>
              <description>aclk_isp1_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HCLK_ISP0_EN</name>
              <description>hclk_isp0 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_ISP0_SRC_EN</name>
              <description>aclk_isp0_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_PCIEPHY_REF100M_EN</name>
              <description>clk_pciephy_ref100m clock disable bit
When HIGH, disable clock</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_USB3_OTG1_SUSPEND_EN</name>
              <description>clk_usb3_otg1_suspend clock disable bit
When HIGH, disable clock</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_USB3_OTG0_SUSPEND_EN</name>
              <description>clk_usb3_otg0_suspend clock disable bit
When HIGH, disable clock</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_USB3_OTG1_REF_EN</name>
              <description>clk_usb3_otg1_ref clock disable bit
When HIGH, disable clock</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_USB3_OTG0_REF_EN</name>
              <description>clk_usb3_otg0_ref clock disable bit
When HIGH, disable clock</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_USB3_SRC_EN</name>
              <description>aclk_usb3_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKGATE_CON13</name>
          <description>Internal clock gating register13</description>
          <addressOffset>0x334</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CLK_TESTOUT2_SRC_EN</name>
              <description>clk_testout2_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_TESTOUT1_SRC_EN</name>
              <description>clk_testout1_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_SPI5_SRC_EN</name>
              <description>clk_spi5_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_USB480M_EN</name>
              <description>clk_usb480m clock disable bit
When HIGH, disable clock</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TESTCLK_EN</name>
              <description>testclk clock disable bit
When HIGH, disable clock</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_WIFI_EN</name>
              <description>clk_wifi clock disable bit
When HIGH, disable clock</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_UPHY1_TCPDCORE_EN</name>
              <description>clk_uphy1_tcpdcore clock disable bit
When HIGH, disable clock</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_UPHY1_TCPDPHYREF_EN</name>
              <description>clk_uphy1_tcpdphyref clock disable bit
When HIGH, disable clock</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_UPHY0_TCPDCORE_EN</name>
              <description>clk_uphy0_tcpdcore clock disable bit
When HIGH, disable clock</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_UPHY0_TCPDPHYREF_EN</name>
              <description>clk_uphy0_tcpdphyref clock disable bit
When HIGH, disable clock</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_PVTM_GPU_EN</name>
              <description>clk_pvtm_gpu clock disable bit
When HIGH, disable clock</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_GPU_PLL_SRC_EN</name>
              <description>aclk_gpu_pll_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKGATE_CON14</name>
          <description>Internal clock gating register14</description>
          <addressOffset>0x338</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>ACLK_PERF_CORE_L_EN</name>
              <description>aclk_perf_core_l clock disable bit
When HIGH, disable clock</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_CORE_ADB400_CORE_L_2_CCI500_EN</name>
              <description>aclk_core_adb400_core_l_2_cci500 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_CORE_ADB400_CORE_L_2_GIC_EN</name>
              <description>aclk_core_adb400_core_l_2_gic clock disable bit
When HIGH, disable clock</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_CORE_ADB400_GIC_2_CORE_L_EN</name>
              <description>aclk_core_adb400_gic_2_core_l clock disable bit
When HIGH, disable clock</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_DBG_PD_CORE_L_EN</name>
              <description>clk_dbg_pd_core_l clock disable bit
When HIGH, disable clock</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_PERF_CORE_B_EN</name>
              <description>aclk_perf_core_b clock disable bit
When HIGH, disable clock</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_CORE_ADB400_CORE_B_2_CCI500_EN</name>
              <description>aclk_core_adb400_core_b_2_cci500 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_CORE_ADB400_CORE_B_2_GIC_EN</name>
              <description>aclk_core_adb400_core_b_2_gic clock disable bit
When HIGH, disable clock</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_CORE_ADB400_GIC_2_CORE_B_EN</name>
              <description>aclk_core_adb400_gic_2_core_b clock disable bit
When HIGH, disable clock</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_DBG_CXCS_PD_CORE_B_EN</name>
              <description>pclk_dbg_cxcs_pd_core_b clock disable bit
When HIGH, disable clock</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_DBG_PD_CORE_B_EN</name>
              <description>clk_dbg_pd_core_b clock disable bit
When HIGH, disable clock</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKGATE_CON15</name>
          <description>Internal clock gating register15</description>
          <addressOffset>0x33c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>ACLK_CCI_GRF_EN</name>
              <description>aclk_cci_grf clock disable bit
When HIGH, disable clock
Suggest always on</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_DBG_NOC_EN</name>
              <description>clk_dbg_noc clock disable bit
When HIGH, disable clock
Suggest always on</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_DBG_CXCS_EN</name>
              <description>clk_dbg_cxcs clock disable bit
When HIGH, disable clock</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_CCI_NOC1_EN</name>
              <description>aclk_cci_noc1 clock disable bit
When HIGH, disable clock
Suggest always on</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_CCI_NOC0_EN</name>
              <description>aclk_cci_noc0 clock disable bit
When HIGH, disable clock
Suggest always on</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_CCI_EN</name>
              <description>aclk_cci clock disable bit
When HIGH, disable clock</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_ADB400M_PD_CORE_B_EN</name>
              <description>aclk_adb400m_pd_core_b clock disable bit
When HIGH, disable clock</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_ADB400M_PD_CORE_L_EN</name>
              <description>aclk_adb400m_pd_core_l clock disable bit
When HIGH, disable clock</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKGATE_CON16</name>
          <description>Internal clock gating register16</description>
          <addressOffset>0x340</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>HCLK_RGA_NOC_EN</name>
              <description>hclk_rga_noc clock disable bit
When HIGH, disable clock
Suggest always on</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HCLK_RGA_EN</name>
              <description>hclk_rga clock disable bit
When HIGH, disable clock</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_RGA_NOC_EN</name>
              <description>aclk_rga_noc clock disable bit
When HIGH, disable clock
Suggest always on</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_RGA_EN</name>
              <description>aclk_rga clock disable bit
When HIGH, disable clock</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HCLK_IEP_NOC_EN</name>
              <description>hclk_iep_noc clock disable bit
When HIGH, disable clock
Suggest always on</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HCLK_IEP_EN</name>
              <description>hclk_iep clock disable bit
When HIGH, disable clock</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_IEP_NOC_EN</name>
              <description>aclk_iep_noc clock disable bit
When HIGH, disable clock
Suggest always on</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_IEP_EN</name>
              <description>aclk_iep clock disable bit
When HIGH, disable clock</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKGATE_CON17</name>
          <description>Internal clock gating register17</description>
          <addressOffset>0x344</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>HCLK_VDU_NOC_EN</name>
              <description>hclk_vdu_noc clock disable bit
When HIGH, disable clock
Suggest always on</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HCLK_VDU_EN</name>
              <description>hclk_vdu clock disable bit
When HIGH, disable clock</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_VDU_NOC_EN</name>
              <description>aclk_vdu_noc clock disable bit
When HIGH, disable clock
Suggest always on</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_VDU_EN</name>
              <description>aclk_vdu clock disable bit
When HIGH, disable clock</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HCLK_VCODEC_NOC_EN</name>
              <description>hclk_vcodec_noc clock disable bit
When HIGH, disable clock
Suggest always on</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HCLK_VCODEC_EN</name>
              <description>hclk_vcodec clock disable bit
When HIGH, disable clock</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_VCODEC_NOC_EN</name>
              <description>aclk_vcodec_noc clock disable bit
When HIGH, disable clock
Suggest always on</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_VCODEC_EN</name>
              <description>aclk_vcodec clock disable bit
When HIGH, disable clock</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKGATE_CON18</name>
          <description>Internal clock gating register18</description>
          <addressOffset>0x348</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PCLK_CIC_EN</name>
              <description>pclk_cic clock disable bit
When HIGH, disable clock</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_DDR_MON_TIMER_EN</name>
              <description>clk_ddr_mon_timer clock disable bit
When HIGH, disable clock</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_DDR_MON_EN</name>
              <description>clk_ddr_mon clock disable bit
When HIGH, disable clock</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_DDR_MON_EN</name>
              <description>pclk_ddr_mon clock disable bit
When HIGH, disable clock</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_DDR_CIC_EN</name>
              <description>clk_ddr_cic clock disable bit
When HIGH, disable clock</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_CENTER_MAIN_NOC_EN</name>
              <description>pclk_center_main_noc clock disable bit
When HIGH, disable clock
Suggest always on</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_DDRCFG_MSCH1_EN</name>
              <description>clk_ddrcfg_msch1 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_DDRPHY1_EN</name>
              <description>clk_ddrphy1 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_DDRPHY_CTRL1_EN</name>
              <description>clk_ddrphy_ctrl1 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_DDRC1_EN</name>
              <description>clk_ddrc1 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_DDR1_MSCH_EN</name>
              <description>clk_ddr1_msch clock disable bit
When HIGH, disable clock</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_DDRCFG_MSCH0_EN</name>
              <description>clk_ddrcfg_msch0 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_DDRPHY0_EN</name>
              <description>clk_ddrphy0 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_DDRPHY_CTRL0_EN</name>
              <description>clk_ddrphy_ctrl0 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_DDRC0_EN</name>
              <description>clk_ddrc0 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_DDR0_MSCH_EN</name>
              <description>clk_ddr0_msch clock disable bit
When HIGH, disable clock</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKGATE_CON19</name>
          <description>Internal clock gating register19</description>
          <addressOffset>0x34c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PCLK_DDR_SGRF_EN</name>
              <description>pclk_ddr_sgrf clock disable bit
When HIGH, disable clock
Suggest always on</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_CENTER_PERI_NOC_EN</name>
              <description>aclk_center_peri_noc clock disable bit
When HIGH, disable clock
Suggest always on</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_CENTER_MAIN_NOC_EN</name>
              <description>aclk_center_main_noc clock disable bit
When HIGH, disable clock
Suggest always on</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKGATE_CON20</name>
          <description>Internal clock gating register20</description>
          <addressOffset>0x350</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>HCLK_AHB1TOM_EN</name>
              <description>hclk_ahb1tom clock disable bit
When HIGH, disable clock</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_PERIHP_NOC_EN</name>
              <description>pclk_perihp_noc clock disable bit
When HIGH, disable clock
Suggest always on</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HCLK_PERIHP_NOC_EN</name>
              <description>hclk_perihp_noc clock disable bit
When HIGH, disable clock
Suggest always on</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_PERIHP_NOC_EN</name>
              <description>aclk_perihp_noc clock disable bit
When HIGH, disable clock
Suggest always on</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_PCIE_EN</name>
              <description>pclk_pcie clock disable bit
When HIGH, disable clock</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_PCIE_EN</name>
              <description>aclk_pcie clock disable bit
When HIGH, disable clock</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HCLK_HSIC_EN</name>
              <description>hclk_hsic clock disable bit
When HIGH, disable clock</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HCLK_HOST1_ARB_EN</name>
              <description>hclk_host1_arb clock disable bit
When HIGH, disable clock</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HCLK_HOST1_EN</name>
              <description>hclk_host1 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HCLK_HOST0_ARB_EN</name>
              <description>hclk_host0_arb clock disable bit
When HIGH, disable clock</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HCLK_HOST0_EN</name>
              <description>hclk_host0 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_PERIHP_GRF_EN</name>
              <description>pclk_perihp_grf clock disable bit
When HIGH, disable clock
Suggest always on</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_PERF_PCIE_EN</name>
              <description>aclk_perf_pcie clock disable bit
When HIGH, disable clock</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKGATE_CON21</name>
          <description>Internal clock gating register21</description>
          <addressOffset>0x354</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>UPHY1_PCLK_TCPD_GATE_EN</name>
              <description>uphy1_pclk_tcpd disable bit
When HIGH, disable clock</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UPHY1_PCLK_TCPHY_GATE_EN</name>
              <description>uphy1_pclk_tcphy clock disable bit
When HIGH, disable clock</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UPHY0_PCLK_TCPD_GATE_EN</name>
              <description>uphy0_pclk_tcpd clock disable bit
When HIGH, disable clock</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UPHY0_PCLK_TCPHY_GATE_EN</name>
              <description>uphy0_pclk_tcphy clock disable bit
When HIGH, disable clock</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UPHY_PCLK_MUX_GATE_EN</name>
              <description>uphy_pclk_mux clock disable bit
When HIGH, disable clock</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPHY_RX0_CFGCLK_EN</name>
              <description>dphy_rx0_cfg clock disable bit
When HIGH, disable clock</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPHY_TX1RX1_CFGCLK_EN</name>
              <description>dphy_tx1rx1_cfg clock disable bit
When HIGH, disable clock</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPHY_TX0_CFGCLK_EN</name>
              <description>dphy_tx0_cfg clock disable bit
When HIGH, disable clock</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPHY_PLLCLK_EN</name>
              <description>dphy_pll clock disable bit
When HIGH, disable clock</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKGATE_CON22</name>
          <description>Internal clock gating register22</description>
          <addressOffset>0x358</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PCLK_EFUSE1024S_EN</name>
              <description>pclk_efuse1024s clock disable bit
When HIGH, disable clock</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_EFUSE1024NS_EN</name>
              <description>pclk_efuse1024ns clock disable bit
When HIGH, disable clock</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_TSADC_EN</name>
              <description>pclk_tsadc clock disable bit
When HIGH, disable clock</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_SARADC_EN</name>
              <description>pclk_saradc clock disable bit
When HIGH, disable clock</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_MAILBOX0_EN</name>
              <description>pclk_mailbox0 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_RKI2C3_EN</name>
              <description>pclk_rki2c3 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_RKI2C2_EN</name>
              <description>pclk_rki2c2 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_RKI2C6_EN</name>
              <description>pclk_rki2c6 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_RKI2C5PAD_EN</name>
              <description>pclk_rki2c5pad clock disable bit
When HIGH, disable clock</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_RKI2C1CAM_EN</name>
              <description>pclk_rki2c1cam clock disable bit
When HIGH, disable clock</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_RKI2C7_EN</name>
              <description>pclk_rki2c7 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_UART3_EN</name>
              <description>pclk_uart3 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_UART2_EN</name>
              <description>pclk_uart2 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_UART1_EN</name>
              <description>pclk_uart1 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_UART0_EN</name>
              <description>pclk_uart0 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKGATE_CON23</name>
          <description>Internal clock gating register23</description>
          <addressOffset>0x35c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PCLK_SPI4_EN</name>
              <description>pclk_spi4 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_SPI2_EN</name>
              <description>pclk_spi2 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_SPI1_EN</name>
              <description>pclk_spi1 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_SPI0CODEC_EN</name>
              <description>pclk_spi0codec clock disable bit
When HIGH, disable clock</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_DCF_EN</name>
              <description>pclk_dcf clock disable bit
When HIGH, disable clock</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_DCF_EN</name>
              <description>aclk_dcf clock disable bit
When HIGH, disable clock</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_INTMEM5_EN</name>
              <description>clk_intmem5 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_INTMEM4_EN</name>
              <description>clk_intmem4 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_INTMEM3_EN</name>
              <description>clk_intmem3 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_INTMEM2_EN</name>
              <description>clk_intmem2 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_INTMEM1_EN</name>
              <description>clk_intmem1 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_INTMEM0_EN</name>
              <description>clk_intmem0 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_TZMA_EN</name>
              <description>aclk_tzma clock disable bit
When HIGH, disable clock</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_INTMEM_EN</name>
              <description>aclk_intmem clock disable bit
When HIGH, disable clock</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKGATE_CON24</name>
          <description>Internal clock gating register24</description>
          <addressOffset>0x360</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>HCLK_S_CRYPTO1_EN</name>
              <description>hclk_s_crypto1 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HCLK_M_CRYPTO1_EN</name>
              <description>hclk_m_crypto1 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_PERILP_SGRF_EN</name>
              <description>pclk_perilp_sgrf clock disable bit
When HIGH, disable clock
Suggest always on</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_M0_PERILP_DEC_EN</name>
              <description>clk_m0_perilp_dec clock disable bit
When HIGH, disable clock</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DCLK_M0_PERILP_EN</name>
              <description>dclk_m0_perilp clock disable bit
When HIGH, disable clock</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HCLK_M0_PERILP_EN</name>
              <description>hclk_m0_perilp clock disable bit
When HIGH, disable clock</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCLK_M0_PERILP_EN</name>
              <description>sclk_m0_perilp clock disable bit
When HIGH, disable clock</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HCLK_S_CRYPTO0_EN</name>
              <description>hclk_s_crypto0 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HCLK_M_CRYPTO0_EN</name>
              <description>hclk_m_crypto0 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HCLK_ROM_EN</name>
              <description>hclk_rom clock disable bit
When HIGH, disable clock</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKGATE_CON25</name>
          <description>Internal clock gating register25</description>
          <addressOffset>0x364</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>HCLK_SDIO_NOC_EN</name>
              <description>hclk_sdio_noc clock disable bit
When HIGH, disable clock
Suggest always on</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HCLK_M0_PERILP_NOC_EN</name>
              <description>hclk_m0_perilp_noc clock disable bit
When HIGH, disable clock
Suggest always on</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_PERILP1_NOC_EN</name>
              <description>pclk_perilp1_noc clock disable bit
When HIGH, disable clock
Suggest always on</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HCLK_PERILP1_NOC_EN</name>
              <description>hclk_perilp1_noc clock disable bit
When HIGH, disable clock
Suggest always on</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HCLK_PERILP0_NOC_EN</name>
              <description>hclk_perilp0_noc clock disable bit
When HIGH, disable clock
Suggest always on</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_PERILP0_NOC_EN</name>
              <description>aclk_perilp0_noc clock disable bit
When HIGH, disable clock
Suggest always on</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_DMAC1_PERILP_EN</name>
              <description>aclk_dmac1_perilp clock disable bit
When HIGH, disable clock</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_DMAC0_PERILP_EN</name>
              <description>aclk_dmac0_perilp clock disable bit
When HIGH, disable clock</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKGATE_CON26</name>
          <description>Internal clock gating register26</description>
          <addressOffset>0x368</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CLK_TIMER11_EN</name>
              <description>clk_timer11 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_TIMER10_EN</name>
              <description>clk_timer10 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_TIMER9_EN</name>
              <description>clk_timer9 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_TIMER8_EN</name>
              <description>clk_timer8 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_TIMER7_EN</name>
              <description>clk_timer7 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_TIMER6_EN</name>
              <description>clk_timer6 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_TIMER5_EN</name>
              <description>clk_timer5 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_TIMER4_EN</name>
              <description>clk_timer4 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_TIMER3_EN</name>
              <description>clk_timer3 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_TIMER2_EN</name>
              <description>clk_timer2 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_TIMER1_EN</name>
              <description>clk_timer1 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_TIMER0_EN</name>
              <description>clk_timer0 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKGATE_CON27</name>
          <description>Internal clock gating register27</description>
          <addressOffset>0x36c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>ACLK_ISP1_WRAPPER_EN</name>
              <description>aclk_isp1_wrapper clock disable bit
When HIGH, disable clock</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HCLK_ISP1_WRAPPER_EN</name>
              <description>hclk_isp1_wrapper clock disable bit
When HIGH, disable clock</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLKIN_ISP1_WRAPPER_EN</name>
              <description>pclkin_isp1_wrapper clock disable bit
When HIGH, disable clock</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_ISP0_WRAPPER_EN</name>
              <description>aclk_isp0_wrapper clock disable bit
When HIGH, disable clock</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HCLK_ISP0_WRAPPER_EN</name>
              <description>hclk_isp0_wrapper clock disable bit
When HIGH, disable clock</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_ISP1_NOC_EN</name>
              <description>aclk_isp1_noc clock disable bit
When HIGH, disable clock
Suggest always on</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HCLK_ISP1_NOC_EN</name>
              <description>hclk_isp1_noc clock disable bit
When HIGH, disable clock
Suggest always on</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_ISP0_NOC_EN</name>
              <description>aclk_isp0_noc clock disable bit
When HIGH, disable clock
Suggest always on</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HCLK_ISP0_NOC_EN</name>
              <description>hclk_isp0_noc clock disable bit
When HIGH, disable clock
Suggest always on</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKGATE_CON28</name>
          <description>Internal clock gating register28</description>
          <addressOffset>0x370</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>ACLK_VOPB_EN</name>
              <description>aclk_vopb clock disable bit
When HIGH, disable clock</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HCLK_VOPB_EN</name>
              <description>hclk_vopb clock disable bit
When HIGH, disable clock</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_VOPB_NOC_EN</name>
              <description>aclk_vopb_noc clock disable bit
When HIGH, disable clock
Suggest always on</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HCLK_VOPB_NOC_EN</name>
              <description>hclk_vopb_noc clock disable bit
When HIGH, disable clock
Suggest always on</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_VOP0_EN</name>
              <description>aclk_vop0 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HCLK_VOP0_EN</name>
              <description>hclk_vop0 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_VOP0_NOC_EN</name>
              <description>aclk_vop0_noc clock disable bit
When HIGH, disable clock
Suggest always on</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HCLK_VOP0_NOC_EN</name>
              <description>hclk_vop0_noc clock disable bit
When HIGH, disable clock
Suggest always on</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKGATE_CON29</name>
          <description>Internal clock gating register29</description>
          <addressOffset>0x374</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PCLK_VIO_GRF_EN</name>
              <description>pclk_vio_grf clock disable bit
When HIGH, disable clock
Suggest always on</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_GASKET_EN</name>
              <description>pclk_gasket clock disable bit
When HIGH, disable clock</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_HDCP22_EN</name>
              <description>aclk_hdcp22 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HCLK_HDCP22_EN</name>
              <description>hclk_hdcp22 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_HDCP22_EN</name>
              <description>pclk_hdcp22 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_DP_CTRL_EN</name>
              <description>pclk_dp_ctrl clock disable bit
When HIGH, disable clock</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_HDMI_CTRL_EN</name>
              <description>pclk_hdmi_ctrl clock disable bit
When HIGH, disable clock</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HCLK_HDCPNOC_EN</name>
              <description>hclk_hdcpnoc clock disable bit
When HIGH, disable clock
Suggest always on</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_HDCPNOC_EN</name>
              <description>aclk_hdcpnoc clock disable bit
When HIGH, disable clock
Suggest always on</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_HDCPNOC_EN</name>
              <description>pclk_hdcpnoc clock disable bit
When HIGH, disable clock
Suggest always on</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_MIPI_DSI1_EN</name>
              <description>pclk_mipi_dsi1 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_MIPI_DSI0_EN</name>
              <description>pclk_mipi_dsi0 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_VIO_NOC_EN</name>
              <description>aclk_vio_noc clock disable bit
When HIGH, disable clock
Suggest always on</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKGATE_CON30</name>
          <description>Internal clock gating register30</description>
          <addressOffset>0x378</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>ACLK_GPU_GRF_EN</name>
              <description>aclk_gpu_grf clock disable bit
When HIGH, disable clock
Suggest always on</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_PERF_GPU_EN</name>
              <description>aclk_perf_gpu clock disable bit
When HIGH, disable clock</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_GPU_EN</name>
              <description>aclk_gpu clock disable bit
When HIGH, disable clock</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_USB3_GRF_EN</name>
              <description>aclk_usb3_grf clock disable bit
When HIGH, disable clock
Suggest always on</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_USB3_RKSOC_AXI_PERF_EN</name>
              <description>aclk_usb3_rksoc_axi_perf clock disable bit
When HIGH, disable clock</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_USB3OTG1_EN</name>
              <description>aclk_usb3otg1 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_USB3OTG0_EN</name>
              <description>aclk_usb3otg0 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_USB3_NOC_EN</name>
              <description>aclk_usb3_noc clock disable bit
When HIGH, disable clock
Suggest always on</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKGATE_CON31</name>
          <description>Internal clock gating register31</description>
          <addressOffset>0x37c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PCLK_SGRF_EN</name>
              <description>pclk_sgrf clock disable bit
When HIGH, disable clock
Suggest always on</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_PMU_INTR_ARB_EN</name>
              <description>pclk_pmu_intr_arb clock disable bit
When HIGH, disable clock</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_HSICPHY_EN</name>
              <description>pclk_hsicphy clock disable bit
When HIGH, disable clock</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_TIMER1_EN</name>
              <description>pclk_timer1 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_TIMER0_EN</name>
              <description>pclk_timer0 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_GPIO4_EN</name>
              <description>pclk_gpio4 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_GPIO3_EN</name>
              <description>pclk_gpio3 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_GPIO2_EN</name>
              <description>pclk_gpio2 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_INTR_ARB_EN</name>
              <description>pclk_intr_arb clock disable bit
When HIGH, disable clock</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_GRF_EN</name>
              <description>pclk_grf clock disable bit
When HIGH, disable clock
Suggest always on</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKGATE_CON32</name>
          <description>Internal clock gating register32</description>
          <addressOffset>0x380</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PCLK_EDP_CTRL_EN</name>
              <description>pclk_edp_ctrl clock disable bit
When HIGH, disable clock</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_EDP_NOC_EN</name>
              <description>pclk_edp_noc clock disable bit
When HIGH, disable clock
Suggest always on</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_EMMC_GRF_EN</name>
              <description>aclk_emmc_grf clock disable bit
When HIGH, disable clock
Suggest always on</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_EMMC_NOC_EN</name>
              <description>aclk_emmc_noc clock disable bit
When HIGH, disable clock
Suggest always on</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_EMMC_CORE_EN</name>
              <description>aclk_emmc_core clock disable bit
When HIGH, disable clock</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_PERF_GMAC_EN</name>
              <description>aclk_perf_gmac clock disable bit
When HIGH, disable clock</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_GMAC_NOC_EN</name>
              <description>pclk_gmac_noc clock disable bit
When HIGH, disable clock
Suggest always on</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_GMAC_EN</name>
              <description>pclk_gmac clock disable bit
When HIGH, disable clock</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_GMAC_NOC_EN</name>
              <description>aclk_gmac_noc clock disable bit
When HIGH, disable clock
Suggest always on</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_GMAC_EN</name>
              <description>aclk_gmac clock disable bit
When HIGH, disable clock</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKGATE_CON33</name>
          <description>Internal clock gating register33</description>
          <addressOffset>0x384</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>HCLK_SD_NOC_EN</name>
              <description>hclk_sd_noc clock disable bit
When HIGH, disable clock
Suggest always on</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HCLK_SDMMC_EN</name>
              <description>hclk_sdmmc clock disable bit
When HIGH, disable clock</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_GIC_ADB400_GIC_2_CORE_B_EN</name>
              <description>aclk_gic_adb400_gic_2_core_b clock disable bit
When HIGH, disable clock</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_GIC_ADB400_GIC_2_CORE_L_EN</name>
              <description>aclk_gic_adb400_gic_2_core_l clock disable bit
When HIGH, disable clock</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_GIC_ADB400_CORE_B_2_GIC_EN</name>
              <description>aclk_gic_adb400_core_b_2_gic clock disable bit
When HIGH, disable clock</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_GIC_ADB400_CORE_L_2_GIC_EN</name>
              <description>aclk_gic_adb400_core_l_2_gic clock disable bit
When HIGH, disable clock</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_GIC_NOC_EN</name>
              <description>aclk_gic_noc clock disable bit
When HIGH, disable clock
Suggest always on</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLK_GIC_EN</name>
              <description>aclk_gic clock disable bit
When HIGH, disable clock</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_CLKGATE_CON34</name>
          <description>Internal clock gating register34</description>
          <addressOffset>0x388</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>HCLK_SDIOAUDIO_NOC_EN</name>
              <description>hclk_sdioaudio_noc clock disable bit
When HIGH, disable clock
Suggest always on</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_SPI5_EN</name>
              <description>pclk_spi5 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HCLK_SDIO_EN</name>
              <description>hclk_sdio clock disable bit
When HIGH, disable clock</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HCLK_SPDIF_EN</name>
              <description>hclk_spdif clock disable bit
When HIGH, disable clock</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HCLK_I2S2_EN</name>
              <description>hclk_i2s2 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HCLK_I2S1_EN</name>
              <description>hclk_i2s1 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HCLK_I2S0_EN</name>
              <description>hclk_i2s0 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_SOFTRST_CON0</name>
          <description>Internal software reset control register0</description>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>RESETN_DBG_NOC_REQ</name>
              <description>resetn_dbg_noc request bit
When HIGH, reset relative logic</description>
              <bitRange>[11:11]</bitRange>
              <access>write-only</access>
              <modifiedWriteValues>clear</modifiedWriteValues>
            </field>
            <field>
              <name>ARESETN_CCIM1_NOC_REQ</name>
              <description>aresetn_ccim1_noc request bit
When HIGH, reset relative logic</description>
              <bitRange>[10:10]</bitRange>
              <access>write-only</access>
              <modifiedWriteValues>clear</modifiedWriteValues>
            </field>
            <field>
              <name>ARESETN_CCIM0_NOC_REQ</name>
              <description>aresetn_ccim0_noc request bit
When HIGH, reset relative logic</description>
              <bitRange>[9:9]</bitRange>
              <access>write-only</access>
              <modifiedWriteValues>clear</modifiedWriteValues>
            </field>
            <field>
              <name>ARESETN_CCI_REQ</name>
              <description>aresetn_cci request bit
When HIGH, reset relative logic</description>
              <bitRange>[8:8]</bitRange>
              <access>write-only</access>
              <modifiedWriteValues>clear</modifiedWriteValues>
            </field>
            <field>
              <name>ADB_B_SRSTN_REQ</name>
              <description>adb_b_srstn request bit
When HIGH, reset relative logic</description>
              <bitRange>[7:7]</bitRange>
              <access>write-only</access>
              <modifiedWriteValues>clear</modifiedWriteValues>
            </field>
            <field>
              <name>ADB_L_SRSTN_REQ</name>
              <description>adb_l_srstn request bit
When HIGH, reset relative logic</description>
              <bitRange>[6:6]</bitRange>
              <access>write-only</access>
              <modifiedWriteValues>clear</modifiedWriteValues>
            </field>
            <field>
              <name>L2_B_SRSTN_REQ</name>
              <description>l2_b_srstn request bit
When HIGH, reset relative logic</description>
              <bitRange>[5:5]</bitRange>
              <access>write-only</access>
              <modifiedWriteValues>clear</modifiedWriteValues>
            </field>
            <field>
              <name>L2_L_SRSTN_REQ</name>
              <description>l2_l_srstn request bit
When HIGH, reset relative logic</description>
              <bitRange>[4:4]</bitRange>
              <access>write-only</access>
              <modifiedWriteValues>clear</modifiedWriteValues>
            </field>
            <field>
              <name>COREPO0_B_SRSTN_REQ</name>
              <description>corepo0_b_srstn request bit
When HIGH, reset relative logic</description>
              <bitRange>[3:3]</bitRange>
              <access>write-only</access>
              <modifiedWriteValues>clear</modifiedWriteValues>
            </field>
            <field>
              <name>COREPO0_L_SRSTN_REQ</name>
              <description>corepo0_l_srstn request bit
When HIGH, reset relative logic</description>
              <bitRange>[2:2]</bitRange>
              <access>write-only</access>
              <modifiedWriteValues>clear</modifiedWriteValues>
            </field>
            <field>
              <name>CORE0_B_SRSTN_REQ</name>
              <description>core0_b_srstn request bit
When HIGH, reset relative logic</description>
              <bitRange>[1:1]</bitRange>
              <access>write-only</access>
              <modifiedWriteValues>clear</modifiedWriteValues>
            </field>
            <field>
              <name>CORE0_L_SRSTN_REQ</name>
              <description>core0_l_srstn request bit
When HIGH, reset relative logic</description>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
              <modifiedWriteValues>clear</modifiedWriteValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_SOFTRST_CON1</name>
          <description>Internal software reset control register1</description>
          <addressOffset>0x404</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PVTM_CORE_L_SRSTN_REQ</name>
              <description>pvtm_core_l_srstn request bit
When HIGH, reset relative logic</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RKPERF_L_ARSTN_REQ</name>
              <description>rkperf_l_arstn request bit
When HIGH, reset relative logic</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADB_L_SRSTN_REQ_T</name>
              <description>adb_l_srstn request bit
When HIGH, reset relative logic</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>L2_L_SRSTN_REQ_T</name>
              <description>l2_l_srstn request bit
When HIGH, reset relative logic</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRSTN_DBG_L_REQ</name>
              <description>prstn_dbg_l request bit
When HIGH, reset relative logic</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARSTN_ADB400_COREL2GIC_REQ</name>
              <description>arstn_adb400_corel2gic request bit
When HIGH, reset relative logic</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARSTN_ADB400_GIC2COREL_REQ</name>
              <description>arstn_adb400_gic2corel request bit
When HIGH, reset relative logic</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COREPO3_L_SRSTN_REQ</name>
              <description>corepo3_l_srstn request bit
When HIGH, reset relative logic</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COREPO2_L_SRSTN_REQ</name>
              <description>corepo2_l_srstn request bit
When HIGH, reset relative logic</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COREPO1_L_SRSTN_REQ</name>
              <description>corepo1_l_srstn request bit
When HIGH, reset relative logic</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COREPO0_L_SRSTN_REQ_T</name>
              <description>corepo0_l_srstn request bit
When HIGH, reset relative logic</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CORE3_L_SRSTN_REQ</name>
              <description>core3_l_srstn request bit
When HIGH, reset relative logic</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CORE2_L_SRSTN_REQ</name>
              <description>core2_l_srstn request bit
When HIGH, reset relative logic</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CORE1_L_SRSTN_REQ</name>
              <description>core1_l_srstn request bit
When HIGH, reset relative logic</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CORE0_L_SRSTN_REQ_T</name>
              <description>core0_l_srstn request bit
When HIGH, reset relative logic</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_SOFTRST_CON2</name>
          <description>Internal software reset control register2</description>
          <addressOffset>0x408</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PVTM_CORE_B_SRSTN_REQ</name>
              <description>pvtm_core_b_srstn request bit
When HIGH, reset relative logic</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RKPERF_B_ARSTN_REQ</name>
              <description>rkperf_b_arstn request bit
When HIGH, reset relative logic</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADB_B_SRSTN_REQ_T</name>
              <description>adb_b_srstn request bit
When HIGH, reset relative logic</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>L2_B_SRSTN_REQ_T</name>
              <description>l2_b_srstn request bit
When HIGH, reset relative logic</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRSTN_DBG_B_REQ</name>
              <description>prstn_dbg_b request bit
When HIGH, reset relative logic</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARSTN_ADB400_COREB2GIC_REQ</name>
              <description>arstn_adb400_coreb2gic request bit
When HIGH, reset relative logic</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARSTN_ADB400_GIC2COREB_REQ</name>
              <description>arstn_adb400_gic2coreb request bit
When HIGH, reset relative logic</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COREPO1_B_SRSTN_REQ</name>
              <description>corepo1_b_srstn request bit
When HIGH, reset relative logic</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COREPO0_B_SRSTN_REQ_T</name>
              <description>corepo0_b_srstn request bit
When HIGH, reset relative logic</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CORE1_B_SRSTN_REQ</name>
              <description>core1_b_srstn request bit
When HIGH, reset relative logic</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CORE0_B_SRSTN_REQ_T</name>
              <description>core0_b_srstn request bit
When HIGH, reset relative logic</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_SOFTRST_CON3</name>
          <description>Internal software reset control register3</description>
          <addressOffset>0x40c</addressOffset>
          <size>32</size>
          <resetValue>0x10</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PRESETN_CCI_GRF_REQ</name>
              <description>presetn_cci_grf request bit
When HIGH, reset relative logic</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_CCI_TRACE_REQ</name>
              <description>resetn_cci_trace request bit
When HIGH, reset relative logic</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_DBG_CXCS_REQ</name>
              <description>resetn_dbg_cxcs request bit
When HIGH, reset relative logic</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_DBG_NOC_REQ_T</name>
              <description>resetn_dbg_noc request bit
When HIGH, reset relative logic</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARESETN_ADB400M_PD_CORE_L_REQ_T</name>
              <description>aresetn_adb400m_pd_core_l request bit
When HIGH, reset relative logic</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARESETN_ADB400M_PD_CORE_B_REQ_T</name>
              <description>aresetn_adb400m_pd_core_b request bit
When HIGH, reset relative logic</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARESETN_CCIM1_NOC_REQ_T</name>
              <description>aresetn_ccim1_noc request bit
When HIGH, reset relative logic</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ARESETN_CCIM0_NOC_REQ_T</name>
              <description>aresetn_ccim0_noc request bit
When HIGH, reset relative logic</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARESETN_CCI_REQ_T</name>
              <description>aresetn_cci request bit
When HIGH, reset relative logic</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_SOFTRST_CON4</name>
          <description>Internal software reset control register4</description>
          <addressOffset>0x410</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>RESETN_PVTM_DDR_REQ</name>
              <description>resetn_pvtm_ddr request bit
When HIGH, reset relative logic</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_DDR_CIC_REQ</name>
              <description>resetn_ddr_cic request bit
When HIGH, reset relative logic</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_DDRPHY1_REQ</name>
              <description>resetn_ddrphy1 request bit
When HIGH, reset relative logic</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_DDR1_REQ</name>
              <description>resetn_ddr1 request bit
When HIGH, reset relative logic</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_DDRCFG1_MSCH_REQ</name>
              <description>resetn_ddrcfg1_msch request bit
When HIGH, reset relative logic</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_DDR1_MSCH_REQ</name>
              <description>resetn_ddr1_msch request bit
When HIGH, reset relative logic</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_DDRPHY0_REQ</name>
              <description>resetn_ddrphy0 request bit
When HIGH, reset relative logic</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_DDR0_REQ</name>
              <description>resetn_ddr0 request bit
When HIGH, reset relative logic</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_DDRCFG0_MSCH_REQ</name>
              <description>resetn_ddrcfg0_msch request bit
When HIGH, reset relative logic</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_DDR0_MSCH_REQ</name>
              <description>resetn_ddr0_msch request bit
When HIGH, reset relative logic</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_CENTER_SGRF_REQ</name>
              <description>presetn_center_sgrf request bit
When HIGH, reset relative logic</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_CIC_REQ</name>
              <description>presetn_cic request bit
When HIGH, reset relative logic</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_DDRMON_REQ</name>
              <description>presetn_ddrmon request bit
When HIGH, reset relative logic</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_CENTER_MAIN_REQ</name>
              <description>presetn_center_main request bit
When HIGH, reset relative logic</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARESETN_CENTER_PERI_NOC_REQ</name>
              <description>aresetn_center_peri_noc request bit
When HIGH, reset relative logic</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARESETN_CENTER_MAIN_NOC_REQ</name>
              <description>aresetn_center_main_noc request bit
When HIGH, reset relative logic</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_SOFTRST_CON5</name>
          <description>Internal software reset control register5</description>
          <addressOffset>0x414</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>RESETN_VDU_CA_REQ</name>
              <description>resetn_vdu_ca request bit
When HIGH, reset relative logic</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_VDU_CORE_REQ</name>
              <description>resetn_vdu_core request bit
When HIGH, reset relative logic</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HRESETN_VDU_REQ</name>
              <description>hresetn_vdu request bit
When HIGH, reset relative logic</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HRESETN_VDU_NOC_REQ</name>
              <description>hresetn_vdu_noc request bit
When HIGH, reset relative logic</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARESETN_VDU_REQ</name>
              <description>aresetn_vdu request bit
When HIGH, reset relative logic</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARESETN_VDU_NOC_REQ</name>
              <description>aresetn_vdu_noc request bit
When HIGH, reset relative logic</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HRESETN_VCODEC_REQ</name>
              <description>hresetn_vcodec request bit
When HIGH, reset relative logic</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HRESETN_VCODEC_NOC_REQ</name>
              <description>hresetn_vcodec_noc request bit
When HIGH, reset relative logic</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARESETN_VCODEC_REQ</name>
              <description>aresetn_vcodec request bit
When HIGH, reset relative logic</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARESETN_VCODEC_NOC_REQ</name>
              <description>aresetn_vcodec_noc request bit
When HIGH, reset relative logic</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_SOFTRST_CON6</name>
          <description>Internal software reset control register6</description>
          <addressOffset>0x418</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>ARESETN_EMMC_GRF_REQ</name>
              <description>aresetn_emmc_grf request bit
When HIGH, reset relative logic</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARESETN_EMMC_REQ</name>
              <description>aresetn_emmc request bit
When HIGH, reset relative logic</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARESETN_EMMC_NOC_REQ</name>
              <description>aresetn_emmc_noc request bit
When HIGH, reset relative logic</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_RGA_CORE_REQ</name>
              <description>resetn_rga_core request bit
When HIGH, reset relative logic</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HRESETN_RGA_REQ</name>
              <description>hresetn_rga request bit
When HIGH, reset relative logic</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HRESETN_RGA_NOC_REQ</name>
              <description>hresetn_rga_noc request bit
When HIGH, reset relative logic</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARESETN_RGA_REQ</name>
              <description>aresetn_rga request bit
When HIGH, reset relative logic</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARESETN_RGA_NOC_REQ</name>
              <description>aresetn_rga_noc request bit
When HIGH, reset relative logic</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HRESETN_IEP_REQ</name>
              <description>hresetn_iep request bit
When HIGH, reset relative logic</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HRESETN_IEP_NOC_REQ</name>
              <description>hresetn_iep_noc request bit
When HIGH, reset relative logic</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARESETN_IEP_REQ</name>
              <description>aresetn_iep request bit
When HIGH, reset relative logic</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARESETN_VOP_IEP_REQ</name>
              <description>aresetn_vop_iep request bit
When HIGH, reset relative logic</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARESETN_IEP_NOC_REQ</name>
              <description>aresetn_iep_noc request bit
When HIGH, reset relative logic</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_SOFTRST_CON7</name>
          <description>Internal software reset control register7</description>
          <addressOffset>0x41c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PRESETN_HSICPHY_REQ</name>
              <description>presetn_hsicphy request bit
When HIGH, reset relative logic</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_PERIHP_NOC_REQ</name>
              <description>presetn_perihp_noc request bit
When HIGH, reset relative logic</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HRESETN_AHB1TOM_REQ</name>
              <description>hresetn_ahb1tom request bit
When HIGH, reset relative logic</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HRESETN_HSIC_AUX_REQ</name>
              <description>hresetn_hsic_aux request bit
When HIGH, reset relative logic</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HRESETN_HSIC_REQ</name>
              <description>hresetn_hsic request bit
When HIGH, reset relative logic</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HRESETN_SDMMC_REQ</name>
              <description>hresetn_sdmmc request bit
When HIGH, reset relative logic</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HRESETN_SDIO0_REQ</name>
              <description>hresetn_sdio0 request bit
When HIGH, reset relative logic</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HRESETN_HOST1_ARB_REQ</name>
              <description>hresetn_host1_arb request bit
When HIGH, reset relative logic</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HRESETN_HOSTC1_AUX_REQ</name>
              <description>hresetn_hostc1_aux request bit
When HIGH, reset relative logic</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HRESETN_USBHOST1_REQ</name>
              <description>hresetn_usbhost1 request bit
When HIGH, reset relative logic</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HRESETN_HOST0_ARB_REQ</name>
              <description>hresetn_host0_arb request bit
When HIGH, reset relative logic</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HRESETN_HOSTC0_AUX_REQ</name>
              <description>hresetn_hostc0_aux request bit
When HIGH, reset relative logic</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HRESETN_USBHOST0_REQ</name>
              <description>hresetn_usbhost0 request bit
When HIGH, reset relative logic</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HRESETN_PERIHP_NOC_REQ</name>
              <description>hresetn_perihp_noc request bit
When HIGH, reset relative logic</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_PERIHP_GRF_REQ</name>
              <description>presetn_perihp_grf request bit
When HIGH, reset relative logic</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARESETN_PERIHP_NOC_REQ</name>
              <description>aresetn_perihp_noc request bit
When HIGH, reset relative logic</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_SOFTRST_CON8</name>
          <description>Internal software reset control register8</description>
          <addressOffset>0x420</addressOffset>
          <size>32</size>
          <resetValue>0xbc</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>HSICPHY_UTMI_RSTN_REQ</name>
              <description>hsicphy_utmi_rstn request bit
When HIGH, reset relative logic</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HSICPHY_POR_RSTN_REQ</name>
              <description>hsicphy_por_rstn request bit
When HIGH, reset relative logic</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_GMAC_GRF_REQ</name>
              <description>presetn_gmac_grf request bit
When HIGH, reset relative logic</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_GMAC_NOC_REQ</name>
              <description>presetn_gmac_noc request bit
When HIGH, reset relative logic</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARESETN_GMAC_REQ</name>
              <description>aresetn_gmac request bit
When HIGH, reset relative logic</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARESETN_GMAC_NOC_REQ</name>
              <description>aresetn_gmac_noc request bit
When HIGH, reset relative logic</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_PCIEPHY_REQ</name>
              <description>resetn_pciephy request bit
When HIGH, reset relative logic</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_PCIE_PM_REQ</name>
              <description>resetn_pcie_pm request bit
When HIGH, reset relative logic</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_PCIE_PIPE_REQ</name>
              <description>resetn_pcie_pipe request bit
When HIGH, reset relative logic</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_PCIE_MGMT_STICKY_REQ</name>
              <description>resetn_pcie_mgmt_sticky request bit
When HIGH, reset relative logic</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_PCIE_MGMT_REQ</name>
              <description>resetn_pcie_mgmt request bit
When HIGH, reset relative logic</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_PCIE_CORE_REQ</name>
              <description>resetn_pcie_core request bit
When HIGH, reset relative logic</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_PCIE_REQ</name>
              <description>presetn_pcie request bit
When HIGH, reset relative logic</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARESETN_PCIE_REQ</name>
              <description>aresetn_pcie request bit
When HIGH, reset relative logic</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_SOFTRST_CON9</name>
          <description>Internal software reset control register9</description>
          <addressOffset>0x424</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>RESETN_UPHY1_TCPDPWRUP_REQ</name>
              <description>resetn_uphy1_tcpdpwrup request bit
When HIGH, reset relative logic</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_UPHY1_REQ</name>
              <description>resetn_uphy1 request bit
When HIGH, reset relative logic</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_UPHY1_PIPE_L00_REQ</name>
              <description>resetn_uphy1_pipe_l00 request bit
When HIGH, reset relative logic</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_USB2PHY1_EHCIPHY_REQ</name>
              <description>resetn_usb2phy1_ehciphy request bit
When HIGH, reset relative logic</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_USB2PHY1_UTMI_PORT1_REQ</name>
              <description>resetn_usb2phy1_utmi_port1 request bit
When HIGH, reset relative logic</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_USB2PHY1_UTMI_PORT0_REQ</name>
              <description>resetn_usb2phy1_utmi_port0 request bit
When HIGH, reset relative logic</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_USB2PHY1_POR_REQ</name>
              <description>resetn_usb2phy1_por request bit
When HIGH, reset relative logic</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_UPHY0_TCPDPWRUP_REQ</name>
              <description>resetn_uphy0_tcpdpwrup request bit
When HIGH, reset relative logic</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_UPHY0_REQ</name>
              <description>resetn_uphy0 request bit
When HIGH, reset relative logic</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_UPHY0_PIPE_L00_REQ</name>
              <description>resetn_uphy0_pipe_l00 request bit
When HIGH, reset relative logic</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_USB2PHY0_EHCIPHY_REQ</name>
              <description>resetn_usb2phy0_ehciphy request bit
When HIGH, reset relative logic</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_USB2PHY0_UTMI_PORT1_REQ</name>
              <description>resetn_usb2phy0_utmi_port1 request bit
When HIGH, reset relative logic</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_USB2PHY0_UTMI_PORT0_REQ</name>
              <description>resetn_usb2phy0_utmi_port0 request bit
When HIGH, reset relative logic</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_USB2PHY0_POR_REQ</name>
              <description>resetn_usb2phy0_por request bit
When HIGH, reset relative logic</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_SOFTRST_CON10</name>
          <description>Internal software reset control register10</description>
          <addressOffset>0x428</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>HRESETN_CRYPTO0_M_REQ</name>
              <description>hresetn_crypto0_m request bit
When HIGH, reset relative logic</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HRESETN_CRYPTO0_S_REQ</name>
              <description>hresetn_crypto0_s request bit
When HIGH, reset relative logic</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HRESETN_ROM_REQ</name>
              <description>hresetn_rom request bit
When HIGH, reset relative logic</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HRESETN_PERILP0_NOC_REQ</name>
              <description>hresetn_perilp0_noc request bit
When HIGH, reset relative logic</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HRESETN_PERILP0_REQ</name>
              <description>hresetn_perilp0 request bit
When HIGH, reset relative logic</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARESETN_ADB400_SLV1_REQ</name>
              <description>aresetn_adb400_slv1 request bit
When HIGH, reset relative logic</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARESETN_ADB400_SLV0_REQ</name>
              <description>aresetn_adb400_slv0 request bit
When HIGH, reset relative logic</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARESETN_ADB400_MST1_REQ</name>
              <description>aresetn_adb400_mst1 request bit
When HIGH, reset relative logic</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARESETN_ADB400_MST0_REQ</name>
              <description>aresetn_adb400_mst0 request bit
When HIGH, reset relative logic</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARESETN_INTMEM_REQ</name>
              <description>aresetn_intmem request bit
When HIGH, reset relative logic</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARESETN_TZMA_REQ</name>
              <description>aresetn_tzma request bit
When HIGH, reset relative logic</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARESETN_DMAC1_PERILP0_REQ</name>
              <description>aresetn_dmac1_perilp0 request bit
When HIGH, reset relative logic</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARESETN_DMAC0_PERILP0_REQ</name>
              <description>aresetn_dmac0_perilp0 request bit
When HIGH, reset relative logic</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARESETN_GIC500_REQ</name>
              <description>aresetn_gic500 request bit
When HIGH, reset relative logic</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARESETN_DCF_REQ</name>
              <description>aresetn_dcf request bit
When HIGH, reset relative logic</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARESETN_PERILP0_NOC_REQ</name>
              <description>aresetn_perilp0_noc request bit
When HIGH, reset relative logic</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_SOFTRST_CON11</name>
          <description>Internal software reset control register11</description>
          <addressOffset>0x42c</addressOffset>
          <size>32</size>
          <resetValue>0x14</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>HRESETN_SDIOAUDIO_BRG_REQ</name>
              <description>hresetn_sdioaudio_brg request bit
When HIGH, reset relative logic</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HRESETN_SD_NOC_REQ</name>
              <description>hresetn_sd_noc request bit
When HIGH, reset relative logic</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARESETN_GIC_NOC_REQ</name>
              <description>aresetn_gic_noc request bit
When HIGH, reset relative logic</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_CRYPTO1_REQ</name>
              <description>resetn_crypto1 request bit
When HIGH, reset relative logic</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HRESETN_CRYPTO1_M_REQ</name>
              <description>hresetn_crypto1_m request bit
When HIGH, reset relative logic</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HRESETN_CRYPTO1_S_REQ</name>
              <description>hresetn_crypto1_s request bit
When HIGH, reset relative logic</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_PERILP1_GRF_REQ</name>
              <description>presetn_perilp1_grf request bit
When HIGH, reset relative logic</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_PERILP1_SGRF_REQ</name>
              <description>presetn_perilp1_sgrf request bit
When HIGH, reset relative logic</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_CRYPTO0_REQ</name>
              <description>resetn_crypto0 request bit
When HIGH, reset relative logic</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PORESETN_CM0S_REQ</name>
              <description>poresetn_cm0s request bit
When HIGH, reset relative logic</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DBGRESETN_CM0S_REQ</name>
              <description>dbgresetn_cm0s request bit
When HIGH, reset relative logic</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HRESETN_CM0S_REQ</name>
              <description>hresetn_cm0s request bit
When HIGH, reset relative logic</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HRESETN_CM0S_NOC_REQ</name>
              <description>hresetn_cm0s_noc request bit
When HIGH, reset relative logic</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_DCF_REQ</name>
              <description>presetn_dcf request bit
When HIGH, reset relative logic</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_SOFTRST_CON12</name>
          <description>Internal software reset control register12</description>
          <addressOffset>0x430</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PRESETN_MAILBOX0_REQ</name>
              <description>presetn_mailbox0 request bit
When HIGH, reset relative logic</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_I2C7_REQ</name>
              <description>presetn_i2c7 request bit
When HIGH, reset relative logic</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_I2C3_REQ</name>
              <description>presetn_i2c3 request bit
When HIGH, reset relative logic</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_I2C6_REQ</name>
              <description>presetn_i2c6 request bit
When HIGH, reset relative logic</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_I2C2_REQ</name>
              <description>presetn_i2c2 request bit
When HIGH, reset relative logic</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_I2C5_REQ</name>
              <description>presetn_i2c5 request bit
When HIGH, reset relative logic</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_I2C1_REQ</name>
              <description>presetn_i2c1 request bit
When HIGH, reset relative logic</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_EFUSE_1024S_REQ</name>
              <description>presetn_efuse_1024s request bit
When HIGH, reset relative logic</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_EFUSE_1024_REQ</name>
              <description>presetn_efuse_1024 request bit
When HIGH, reset relative logic</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_PERILP1_NOC_REQ</name>
              <description>presetn_perilp1_noc request bit
When HIGH, reset relative logic</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HRESETN_SPDIF_8CH_REQ</name>
              <description>hresetn_spdif_8ch request bit
When HIGH, reset relative logic</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HRESETN_I2S2_REQ</name>
              <description>hresetn_i2s2 request bit
When HIGH, reset relative logic</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HRESETN_I2S1_REQ</name>
              <description>hresetn_i2s1 request bit
When HIGH, reset relative logic</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HRESETN_I2S0_REQ</name>
              <description>hresetn_i2s0 request bit
When HIGH, reset relative logic</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HRESETN_PERILP1_NOC_REQ</name>
              <description>hresetn_perilp1_noc request bit
When HIGH, reset relative logic</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HRESETN_PERILP1_REQ</name>
              <description>hresetn_perilp1 request bit
When HIGH, reset relative logic</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_SOFTRST_CON13</name>
          <description>Internal software reset control register13</description>
          <addressOffset>0x434</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>RESETN_SPI5_REQ</name>
              <description>resetn_spi5 request bit
When HIGH, reset relative logic</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_SPI4_REQ</name>
              <description>resetn_spi4 request bit
When HIGH, reset relative logic</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_SPI2_REQ</name>
              <description>resetn_spi2 request bit
When HIGH, reset relative logic</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_SPI1_REQ</name>
              <description>resetn_spi1 request bit
When HIGH, reset relative logic</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_SPI0_REQ</name>
              <description>resetn_spi0 request bit
When HIGH, reset relative logic</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_SPI5_REQ</name>
              <description>presetn_spi5 request bit
When HIGH, reset relative logic</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_SPI4_REQ</name>
              <description>presetn_spi4 request bit
When HIGH, reset relative logic</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_SPI2_REQ</name>
              <description>presetn_spi2 request bit
When HIGH, reset relative logic</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_SPI1_REQ</name>
              <description>presetn_spi1 request bit
When HIGH, reset relative logic</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_SPI0_REQ</name>
              <description>presetn_spi0 request bit
When HIGH, reset relative logic</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_TSADC_REQ</name>
              <description>presetn_tsadc request bit
When HIGH, reset relative logic</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_SARADC_REQ</name>
              <description>presetn_saradc request bit
When HIGH, reset relative logic</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_UART3_REQ</name>
              <description>presetn_uart3 request bit
When HIGH, reset relative logic</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_UART2_REQ</name>
              <description>presetn_uart2 request bit
When HIGH, reset relative logic</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_UART1_REQ</name>
              <description>presetn_uart1 request bit
When HIGH, reset relative logic</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_UART0_REQ</name>
              <description>presetn_uart0 request bit
When HIGH, reset relative logic</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_SOFTRST_CON14</name>
          <description>Internal software reset control register14</description>
          <addressOffset>0x438</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>HRESETN_SDIOAUDIO_NOC_REQ</name>
              <description>hresetn_sdioaudio_noc request bit
When HIGH, reset relative logic</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_I2C7_REQ</name>
              <description>resetn_i2c7 request bit
When HIGH, reset relative logic</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_I2C3_REQ</name>
              <description>resetn_i2c3 request bit
When HIGH, reset relative logic</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_I2C6_REQ</name>
              <description>resetn_i2c6 request bit
When HIGH, reset relative logic</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_I2C2_REQ</name>
              <description>resetn_i2c2 request bit
When HIGH, reset relative logic</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_I2C5_REQ</name>
              <description>resetn_i2c5 request bit
When HIGH, reset relative logic</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_I2C1_REQ</name>
              <description>resetn_i2c1 request bit
When HIGH, reset relative logic</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_TSADC_REQ</name>
              <description>resetn_tsadc request bit
When HIGH, reset relative logic</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_UART3_REQ</name>
              <description>resetn_uart3 request bit
When HIGH, reset relative logic</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_UART2_REQ</name>
              <description>resetn_uart2 request bit
When HIGH, reset relative logic</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_UART1_REQ</name>
              <description>resetn_uart1 request bit
When HIGH, reset relative logic</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_UART0_REQ</name>
              <description>resetn_uart0 request bit
When HIGH, reset relative logic</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_SPDIF_8CH_REQ</name>
              <description>resetn_spdif_8ch request bit
When HIGH, reset relative logic</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_I2S2_REQ</name>
              <description>resetn_i2s2 request bit
When HIGH, reset relative logic</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_I2S1_REQ</name>
              <description>resetn_i2s1 request bit
When HIGH, reset relative logic</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_I2S0_REQ</name>
              <description>resetn_i2s0 request bit
When HIGH, reset relative logic</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_SOFTRST_CON15</name>
          <description>Internal software reset control register15</description>
          <addressOffset>0x43c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>RESETN_DP_I2S_REQ</name>
              <description>resetn_dp_i2s request bit
When HIGH, reset relative logic</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_DP_CORE_REQ</name>
              <description>resetn_dp_core request bit
When HIGH, reset relative logic</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_MIPI_DSI1_REQ</name>
              <description>presetn_mipi_dsi1 request bit
When HIGH, reset relative logic</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_MIPI_DSI0_REQ</name>
              <description>presetn_mipi_dsi0 request bit
When HIGH, reset relative logic</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CRESETN_DP_CTRL_REQ</name>
              <description>cresetn_dp_ctrl request bit
When HIGH, reset relative logic</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SRESETN_DP_CTRL_REQ</name>
              <description>sresetn_dp_ctrl request bit
When HIGH, reset relative logic</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_DP_CTRL_REQ</name>
              <description>presetn_dp_ctrl request bit
When HIGH, reset relative logic</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_HDMI_CTRL_REQ</name>
              <description>presetn_hdmi_ctrl request bit
When HIGH, reset relative logic</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_HDCP_REQ</name>
              <description>presetn_hdcp request bit
When HIGH, reset relative logic</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_HDCP_NOC_REQ</name>
              <description>presetn_hdcp_noc request bit
When HIGH, reset relative logic</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HRESETN_HDCP_REQ</name>
              <description>hresetn_hdcp request bit
When HIGH, reset relative logic</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HRESETN_HDCP_NOC_REQ</name>
              <description>hresetn_hdcp_noc request bit
When HIGH, reset relative logic</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARESETN_HDCP_REQ</name>
              <description>aresetn_hdcp request bit
When HIGH, reset relative logic</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARESETN_HDCP_NOC_REQ</name>
              <description>aresetn_hdcp_noc request bit
When HIGH, reset relative logic</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARESETN_VIO_NOC_REQ</name>
              <description>aresetn_vio_noc request bit
When HIGH, reset relative logic</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_SOFTRST_CON16</name>
          <description>Internal software reset control register16</description>
          <addressOffset>0x440</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>RESETN_ISP1_REQ</name>
              <description>resetn_isp1 request bit
When HIGH, reset relative logic</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_ISP0_REQ</name>
              <description>resetn_isp0 request bit
When HIGH, reset relative logic</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HRESETN_ISP1_REQ</name>
              <description>hresetn_isp1 request bit
When HIGH, reset relative logic</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HRESETN_ISP0_REQ</name>
              <description>hresetn_isp0 request bit
When HIGH, reset relative logic</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HRESETN_ISP1_NOC_REQ</name>
              <description>hresetn_isp1_noc request bit
When HIGH, reset relative logic</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HRESETN_ISP0_NOC_REQ</name>
              <description>hresetn_isp0_noc request bit
When HIGH, reset relative logic</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARESETN_ISP1_NOC_REQ</name>
              <description>aresetn_isp1_noc request bit
When HIGH, reset relative logic</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARESETN_ISP0_NOC_REQ</name>
              <description>aresetn_isp0_noc request bit
When HIGH, reset relative logic</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_HDCP_CTRL_REQ</name>
              <description>resetn_hdcp_ctrl request bit
When HIGH, reset relative logic</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_HDMI_CTRL_REQ</name>
              <description>resetn_hdmi_ctrl request bit
When HIGH, reset relative logic</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_DPTX_SPDIF_REC_REQ</name>
              <description>resetn_dptx_spdif_rec request bit
When HIGH, reset relative logic</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_VIO_GRF_REQ</name>
              <description>presetn_vio_grf request bit
When HIGH, reset relative logic</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_GASKET_REQ</name>
              <description>presetn_gasket request bit
When HIGH, reset relative logic</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_SOFTRST_CON17</name>
          <description>Internal software reset control register17</description>
          <addressOffset>0x444</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PRESETN_EDP_CTRL_REQ</name>
              <description>presetn_edp_ctrl request bit
When HIGH, reset relative logic</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_EDP_NOC_REQ</name>
              <description>presetn_edp_noc request bit
When HIGH, reset relative logic</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_VOP1_PWM_REQ</name>
              <description>resetn_vop1_pwm request bit
When HIGH, reset relative logic</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_VOP0_PWM_REQ</name>
              <description>resetn_vop0_pwm request bit
When HIGH, reset relative logic</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DRESETN_VOP1_REQ</name>
              <description>dresetn_vop1 request bit
When HIGH, reset relative logic</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DRESETN_VOP0_REQ</name>
              <description>dresetn_vop0 request bit
When HIGH, reset relative logic</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HRESETN_VOP1_REQ</name>
              <description>hresetn_vop1 request bit
When HIGH, reset relative logic</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HRESETN_VOP0_REQ</name>
              <description>hresetn_vop0 request bit
When HIGH, reset relative logic</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HRESETN_VOP1_NOC_REQ</name>
              <description>hresetn_vop1_noc request bit
When HIGH, reset relative logic</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HRESETN_VOP0_NOC_REQ</name>
              <description>hresetn_vop0_noc request bit
When HIGH, reset relative logic</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARESETN_VOP1_REQ</name>
              <description>aresetn_vop1 request bit
When HIGH, reset relative logic</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARESETN_VOP0_REQ</name>
              <description>aresetn_vop0 request bit
When HIGH, reset relative logic</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARESETN_VOP1_NOC_REQ</name>
              <description>aresetn_vop1_noc request bit
When HIGH, reset relative logic</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARESETN_VOP0_NOC_REQ</name>
              <description>aresetn_vop0_noc request bit
When HIGH, reset relative logic</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_SOFTRST_CON18</name>
          <description>Internal software reset control register18</description>
          <addressOffset>0x448</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PMU_SRSTN_REQ</name>
              <description>pmu_srstn request bit
When HIGH, reset relative logic</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARESETN_USB3_GRF_REQ</name>
              <description>aresetn_usb3_grf request bit
When HIGH, reset relative logic</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARESETN_USB3_OTG1_REQ</name>
              <description>aresetn_usb3_otg1 request bit
When HIGH, reset relative logic</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARESETN_USB3_OTG0_REQ</name>
              <description>aresetn_usb3_otg0 request bit
When HIGH, reset relative logic</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARESETN_USB3_NOC_REQ</name>
              <description>aresetn_usb3_noc request bit
When HIGH, reset relative logic</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_PVTM_GPU_REQ</name>
              <description>resetn_pvtm_gpu request bit
When HIGH, reset relative logic</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARESETN_GPU_GRF_REQ</name>
              <description>aresetn_gpu_grf request bit
When HIGH, reset relative logic</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARESETN_GPU_NOC_REQ</name>
              <description>aresetn_gpu_noc request bit
When HIGH, reset relative logic</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARESETN_GPU_REQ</name>
              <description>aresetn_gpu request bit
When HIGH, reset relative logic</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_SOFTRST_CON19</name>
          <description>Internal software reset control register19</description>
          <addressOffset>0x44c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PRESETN_ALIVE_SGRF_REQ</name>
              <description>presetn_alive_sgrf request bit
When HIGH, reset relative logic</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_INTR_ARB_PMU_REQ</name>
              <description>presetn_intr_arb_pmu request bit
When HIGH, reset relative logic</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMER11_SRSTN_REQ</name>
              <description>timer11_srstn request bit
When HIGH, reset relative logic</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMER10_SRSTN_REQ</name>
              <description>timer10_srstn request bit
When HIGH, reset relative logic</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMER9_SRSTN_REQ</name>
              <description>timer9_srstn request bit
When HIGH, reset relative logic</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMER8_SRSTN_REQ</name>
              <description>timer8_srstn request bit
When HIGH, reset relative logic</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMER7_SRSTN_REQ</name>
              <description>timer7_srstn request bit
When HIGH, reset relative logic</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMER6_SRSTN_REQ</name>
              <description>timer6_srstn request bit
When HIGH, reset relative logic</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMER_6_11_PSRSTN_REQ</name>
              <description>timer_6_11_psrstn request bit
When HIGH, reset relative logic</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMER5_SRSTN_REQ</name>
              <description>timer5_srstn request bit
When HIGH, reset relative logic</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMER4_SRSTN_REQ</name>
              <description>timer4_srstn request bit
When HIGH, reset relative logic</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMER3_SRSTN_REQ</name>
              <description>timer3_srstn request bit
When HIGH, reset relative logic</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMER2_SRSTN_REQ</name>
              <description>timer2_srstn request bit
When HIGH, reset relative logic</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMER1_SRSTN_REQ</name>
              <description>timer1_srstn request bit
When HIGH, reset relative logic</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMER0_SRSTN_REQ</name>
              <description>timer0_srstn request bit
When HIGH, reset relative logic</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMER_0_5_PSRSTN_REQ</name>
              <description>timer_0_5_psrstn request bit
When HIGH, reset relative logic</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_SOFTRST_CON20</name>
          <description>Internal software reset control register20</description>
          <addressOffset>0x450</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PRESETN_UPHY1_TCPDCTRL_REQ</name>
              <description>presetn_uphy1_tcpdctrl request bit
When HIGH, reset relative logic</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_UPHY0_TCPDCTRL_REQ</name>
              <description>presetn_uphy0_tcpdctrl request bit
When HIGH, reset relative logic</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_UPHY1_TCPHY_REQ</name>
              <description>presetn_uphy1_tcphy request bit
When HIGH, reset relative logic</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_UPHY0_TCPHY_REQ</name>
              <description>presetn_uphy0_tcphy request bit
When HIGH, reset relative logic</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_UPHY0_APB_REQ</name>
              <description>presetn_uphy0_apb request bit
When HIGH, reset relative logic</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_UPHY0_DPTX_REQ</name>
              <description>presetn_uphy0_dptx request bit
When HIGH, reset relative logic</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_INTR_ARB_REQ</name>
              <description>presetn_intr_arb request bit
When HIGH, reset relative logic</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_WDT1_REQ</name>
              <description>presetn_wdt1 request bit
When HIGH, reset relative logic</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_WDT0_REQ</name>
              <description>presetn_wdt0 request bit
When HIGH, reset relative logic</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_ALIVE_NOC_REQ</name>
              <description>presetn_alive_noc request bit
When HIGH, reset relative logic</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_GRF_REQ</name>
              <description>presetn_grf request bit
When HIGH, reset relative logic</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_GPIO4_REQ</name>
              <description>presetn_gpio4 request bit
When HIGH, reset relative logic</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_GPIO3_REQ</name>
              <description>presetn_gpio3 request bit
When HIGH, reset relative logic</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_GPIO2_REQ</name>
              <description>presetn_gpio2 request bit
When HIGH, reset relative logic</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_GLB_SRST_FST_VALUE</name>
          <description>The first global software reset config value</description>
          <addressOffset>0x500</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GLB_SRST_FST_VALUE</name>
              <description>The first global software reset config value
If config 0xfdb9, it will generate first global software reset</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_GLB_SRST_SND_VALUE</name>
          <description>The second global software reset config value</description>
          <addressOffset>0x504</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GLB_SRST_SND_VALUE</name>
              <description>The second global software reset config value
If config 0xeca8, it will generate second global software reset</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_GLB_CNT_TH</name>
          <description>Global soft reset counter threshold</description>
          <addressOffset>0x508</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GLB_RST_CNT_TH</name>
              <description>global reset wait counter threshold
wait cycles n(at xin_24m)</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_MISC_CON</name>
          <description>Output clock selection for test</description>
          <addressOffset>0x50c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CORE_DBGRST_WFIEN</name>
              <description>A53/A72 dbg reset wait for STANDBYWFI enable
1'b0 : A53 dbg reset has no relation to STANDBYWFI status
1'b1 : A53 dgb reset is asserted after STANDBYWFI valid</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CORE_WRST_WIFEN</name>
              <description>A53/A72 warm reset wait for STANDBYWFI enable
1'b0 : A53/A72 warm reset has no relation to STANDBYWFI
status
1'b1 : A53/A72 warm reset is asserted after STANDBYWFI valid</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CORE_SRST_WFIEN</name>
              <description>A53/A72 software reset wait for STANDBYWFI enable
1'b0 : A53/A72 software reset has no relation to STANDBYWFI
status
1'b1 : A53/A72 software reset is asserted after STANDBYWFI
valid</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DBGRSTN_EN</name>
              <description>A53/A72 DBGRSTN reset enable
1'b0 : disable A53/A72 DBGRSTN reset
1'b1 : enable A53/A72 DBGRSTN reset</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WARMRSTN_EN</name>
              <description>A53/A72 warm reset enable
1'b0 : disable A53/A72 warm reset
1'b1 : enable A53/A72 warm reset</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TESTCLK_SEL</name>
              <description>Output clock selection for test
4'h0: clk_core_b_2wrap
4'h1: clk_core_l_2wrap
4'h2: aclk_cci_2wrap
4'h3: aclk_perihp_2wrap
4'h4: aclk_perilp0_2wrap
4'h5: hclk_perilp1_2wrap
4'h6: aclk_center_2wrap
4'h7: clk_ddrc_2wrap
4'h8: aclk_gpu_2wrap
4'h9: clk_rga_core_2wrap
4'ha: clk_vdu_core_2wrap
4'hb: clk_pciephy_ref100m
4'hc: dclk_vop0_2wrap
4'hd: clk_rtc
4'he: clkout_24m
4'hf: clk_wifi</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_GLB_RST_CON</name>
          <description>Global reset trigger select</description>
          <addressOffset>0x510</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PMU_GLBRST_WDT_CTRL</name>
              <description>if pmu reset by wdt resetn src select
1'b0: pmu reset by wdt rstn
1'b1: pmu does not reset by wdt rstn</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMU_GLB_SRST_CTRL</name>
              <description>pmu reset by global soft reset select
2'b00: pmu reset by first global soft reset
2'b01: pmu reset by second global soft reset
2'b10: pmu not reset by any global soft reset</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WDT_GLB_SRST_CTRL</name>
              <description>watch_dog trigger global soft reset select
1'b0: watch_dog trigger second global reset
1'b1: watch_dog trigger first global reset</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TSADC_GLB_SRST_CTRL</name>
              <description>TSADC trigger global soft reset select
1'b0:    tsadc trigger second global reset
1'b1:    tsadc trigger first global reset</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_GLB_RST_ST</name>
          <description>Global reset status</description>
          <addressOffset>0x514</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SND_GLB_WDT_RST_ST</name>
              <description>second global watch_dog triggered reset flag
1'b0: last hot reset is not second global watch_dog triggered
reset
1'b1: last hot reset is second global watch_dog triggered reset</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>FST_GLB_WDT_RST_ST</name>
              <description>first global watch_dog triggered reset flag
1'b0: last hot reset is not first global watch_dog triggered reset
1'b1: last hot reset is first global watch_dog triggered reset</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>SND_GLB_TSADC_RST_ST</name>
              <description>second global TSADC triggered reset flag
1'b0: last hot reset is not second global TSADC triggered reset
1'b1: last hot reset is second global TSADC triggered reset</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>FST_GLB_TSADC_RST_ST</name>
              <description>first global TSADC triggered reset flag
1'b0: last hot reset is not first global TSADC triggered reset
1'b1: last hot reset is first global TSADC triggered reset</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>SND_GLB_RST_ST</name>
              <description>second global rst flag
1'b0: last hot reset is not second global reset
1'b1: last hot reset is second global reset</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>FST_GLB_RST_ST</name>
              <description>first global rst flag
1'b0: last hot reset is not first global reset
1'b1: last hot reset is first global reset</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_SDMMC_CON0</name>
          <description>sdmmc control0</description>
          <addressOffset>0x580</addressOffset>
          <size>32</size>
          <resetValue>0x4</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>SDMMC_CON0</name>
              <description>sdmmc con0 register
refer to chapter SDMMC</description>
              <bitRange>[15:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_SDMMC_CON1</name>
          <description>sdmmc control1</description>
          <addressOffset>0x584</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>SDMMC_CON1</name>
              <description>sdmmc con1 register
refer to chapter SDMMC</description>
              <bitRange>[15:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_SDIO0_CON0</name>
          <description>sdio0 control0</description>
          <addressOffset>0x588</addressOffset>
          <size>32</size>
          <resetValue>0x4</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>SDIO_CON0</name>
              <description>sdio_con0 register
refer to chapter SDIO</description>
              <bitRange>[15:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRU_SDIO0_CON1</name>
          <description>sdio0 control1</description>
          <addressOffset>0x58c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>SDIO_CON1</name>
              <description>sdio_con1 register
refer to chapter SDIO</description>
              <bitRange>[15:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PMUSGRF</name>
      <version>1.0</version>
      <groupname>PMUSGRF</groupname>
      <baseAddress>0xff330000</baseAddress>
      <registers>
        <register>
          <name>fast_boot_addr</name>
          <description>fast_boot_addr</description>
          <addressOffset>0xc180</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>ddr_rgn_con9</name>
          <description>ddr_rgn_con9</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>ddr_rgn_con8</name>
          <description>ddr_rgn_con8</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>ddr_rgn_con5</name>
          <description>ddr_rgn_con5</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>ddr_rgn_con4</name>
          <description>ddr_rgn_con4</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>ddr_rgn_con7</name>
          <description>ddr_rgn_con7</description>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>ddr_rgn_con6</name>
          <description>ddr_rgn_con6</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>ddr_rgn_con1</name>
          <description>ddr_rgn_con1</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>ddr_rgn_con0</name>
          <description>ddr_rgn_con0</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>ddr_rgn_con3</name>
          <description>ddr_rgn_con3</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>ddr_rgn_con2</name>
          <description>ddr_rgn_con2</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>slv_secure_con4</name>
          <description>slv_secure_con4</description>
          <addressOffset>0xe3d4</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>slv_secure_con1</name>
          <description>slv_secure_con1</description>
          <addressOffset>0xe3c4</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>slv_secure_con0</name>
          <description>slv_secure_con0</description>
          <addressOffset>0xe3c0</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>slv_secure_con3</name>
          <description>slv_secure_con3</description>
          <addressOffset>0xe3d0</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>slv_secure_con2</name>
          <description>slv_secure_con2</description>
          <addressOffset>0xe3cc</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>soc_con22</name>
          <description>soc_con22</description>
          <addressOffset>0x8058</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>ddr_rgn_con13</name>
          <description>ddr_rgn_con13</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>ddr_rgn_con12</name>
          <description>ddr_rgn_con12</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>soc_con18</name>
          <description>soc_con18</description>
          <addressOffset>0xe048</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>soc_con19</name>
          <description>soc_con19</description>
          <addressOffset>0x804c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>soc_con12</name>
          <description>soc_con12</description>
          <addressOffset>0x8030</addressOffset>
          <size>32</size>
          <resetValue>0xfff</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMAC1_BOOT_PERIPH_NS_LOW</name>
              <description>0 indicates secure, 1 indicates non-secure.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WRITE_ENABLE</name>
              <description>write_enable</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>soc_con13</name>
          <description>soc_con13</description>
          <addressOffset>0x8034</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMAC1_BOOT_ADDR</name>
              <description>0 indicates secure, 1 indicates non-secure.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WRITE_ENABLE</name>
              <description>write_enable</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>soc_con10</name>
          <description>soc_con10</description>
          <addressOffset>0x8028</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMAC0_BOOT_ADDR</name>
              <description>0 indicates secure, 1 indicates non-secure.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WRITE_ENABLE</name>
              <description>write_enable</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>soc_con11</name>
          <description>soc_con11</description>
          <addressOffset>0x802c</addressOffset>
          <size>32</size>
          <resetValue>0x9</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMAC1_PERIPH_NS_0</name>
              <description>(CFG)</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WRITE_ENABLE</name>
              <description>write_enable</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>soc_con16</name>
          <description>soc_con16</description>
          <addressOffset>0xe040</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>soc_con17</name>
          <description>soc_con17</description>
          <addressOffset>0xe044</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>soc_con14</name>
          <description>soc_con14</description>
          <addressOffset>0x8038</addressOffset>
          <size>32</size>
          <resetValue>0xff</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMAC1_BOOT_PERIPH_NS_HIGH</name>
              <description>0 indicates secure, 1 indicates non-secure.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WRITE_ENABLE</name>
              <description>write_enable</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>soc_con15</name>
          <description>soc_con15</description>
          <addressOffset>0x803c</addressOffset>
          <size>32</size>
          <resetValue>0xffff</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMAC1_BOOT_IRQ_NS</name>
              <description>0 indicates secure, 1 indicates non-secure.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WRITE_ENABLE</name>
              <description>write_enable</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>soc_con8</name>
          <description>soc_con8</description>
          <addressOffset>0x8020</addressOffset>
          <size>32</size>
          <resetValue>0xfff9</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMAC0_PERIPH_NS_0</name>
              <description>CFG_NS</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WRITE_ENABLE</name>
              <description>write_enable</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>soc_con9</name>
          <description>soc_con9</description>
          <addressOffset>0x8024</addressOffset>
          <size>32</size>
          <resetValue>0xfff</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMAC0_BOOT_PERIPH_NS</name>
              <description>0 indicates secure, 1 indicates non-secure.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WRITE_ENABLE</name>
              <description>write_enable</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>soc_con0</name>
          <description>soc_con0</description>
          <addressOffset>0xc000</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SGRF_CON_PERILP_M0_JTAG_RSTREQN</name>
              <description>Always be 0</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SGRF_CON_M0_PERILP_SYSRSTREQ_EN</name>
              <description>Enable for SYSRESETREQ</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CA53_JTAG_0</name>
              <description>CA53 JTAG</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CA53_JTAG_1</name>
              <description>CA53 JTAG</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CA53_JTAG_2</name>
              <description>CA53 JTAG</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CA53_JTAG_3</name>
              <description>CA53 JTAG</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>soc_con1</name>
          <description>soc_con1</description>
          <addressOffset>0xc004</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BOOT_ADDRESS_WRITEMASK</name>
              <description>boot_address_writemask</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>BOOT_ADDRESS</name>
              <description>Warm boot address for CPU. Could be DMAC0 BOOT ADDR</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>soc_con3</name>
          <description>soc_con3</description>
          <addressOffset>0xe00c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BOOTROM_REMAP_SHADOW</name>
              <description>Remaps 0xFFFF0000 to BOOTROM or INTMEM0. From page 892. **NOTE**: might be bootrom_remap instead.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SRAM1_SECURE</name>
              <description>pmusram (SRAM1) secure</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STIMER_SECURE</name>
              <description>stimer secure</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CA53_WDT_PCLK</name>
              <description>ca53 wdt pclk</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CM0_WDT_PCLK</name>
              <description>cm0 wdt pclk</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>soc_con4</name>
          <description>soc_con4</description>
          <addressOffset>0xe010</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TZMA_SIZE</name>
              <description>Controls the region considered secure by the TZMA (TrustZone Memory Adapter). See p990 of the TRM Part 1. Secure region size is set in 4KB increments, from 0KB to 192KB.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>soc_con5</name>
          <description>soc_con5</description>
          <addressOffset>0xe014</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>Write 1 to enable writing to bit in lower 16 bits.</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>MASTER_SECURITY_0</name>
              <description>master_security_0</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>soc_con6</name>
          <description>soc_con6</description>
          <addressOffset>0xe018</addressOffset>
          <size>32</size>
          <resetValue>0x2000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SGRF_CON_PERIM0_SECURE_CTRL</name>
              <description>Master security attribute</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WRITE_ENABLE</name>
              <description>Write 1 to enable writing to bit in lower 16 bits.</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>MASTER_SECURITY_1</name>
              <description>master_security_1</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>soc_con7</name>
          <description>soc_con7</description>
          <addressOffset>0xe01c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>Write 1 to enable writing to bit in lower 16 bits.</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>MASTER_SECURITY_2</name>
              <description>master_security_2</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>perilp_con8</name>
          <description>perilp_con8</description>
          <addressOffset>0x8120</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GRF_CON_M0_PERILP_IRQLATENCY</name>
              <description>Minimum number of cycles between an interrupt that becomes pended in the NVIC, and the vector fetch for that interrupt being issued</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>efuse_read_mask</name>
          <description>efuse_read_mask</description>
          <addressOffset>0xc204</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>perilp_con2</name>
          <description>perilp_con2</description>
          <addressOffset>0x8108</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GRF_CON_M0_PERILP_STCALIB_NOREF</name>
              <description>Indicates that no alternative reference clock source has been integrated. Tie HIGH if STCLKEN has been tied off.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GRF_CON_M0_PERILP_STCALIB_SKEW</name>
              <description>Tie this LOW if the system timer clock, the external reference clock, or SCLK as indicated by STCALIB[25] (grf_con_m0_perilp_stcalib_noref), can guarantee an exact multiple of 10ms. Otherwise, tie this signal HIGH.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GRF_CON_M0_PERILP_STCALIB_TENMS_23_16</name>
              <description>See also: grf_con_m0_perilp_stcalib_tenms_15_0</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WRITE_MASK</name>
              <description>write_mask</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>perilp_con3</name>
          <description>perilp_con3</description>
          <addressOffset>0x810c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write_mask</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PERILP_REMAP_FLASH_ROM_MID</name>
              <description>middle 16 bits of 0x00000000-0x1FFFFFFF remap</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>perilp_con0</name>
          <description>perilp_con0</description>
          <addressOffset>0x8100</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SGRF_PERILP_CM0S_RSTHOLD</name>
              <description>Reset hold control</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SGRF_CON_DBGEN_M0_PERIL</name>
              <description>Serial Wire Debug enable</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SGRF_CON_NMI_M0_PERILP</name>
              <description>Non maskable interrupt</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SGRF_CON_DBGRESTART_M0_PERILP</name>
              <description>External restart request</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SGRF_CON_EDBGRQ_M0_PERILP</name>
              <description>External debug request</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SGRF_CON_RXEV_M0_PERILP</name>
              <description>A HIGH level on this input causes the architecture defined Event Register to be set in the Cortex-M0 processor. This causes a WFE instruction to complete. It also awakens the processor if it is sleeping as the result of encountering a WFE instruction when the Event Register is clear.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WRITE_MASK</name>
              <description>write_mask</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>perilp_con1</name>
          <description>perilp_con1</description>
          <addressOffset>0x8104</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GRF_CON_M0_PERILP_STCALIB_TENMS_15_0</name>
              <description>See also: grf_con_m0_perilp_stcalib_tenms_23_16</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WRITE_MASK</name>
              <description>write_mask</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>perilp_con6</name>
          <description>perilp_con6</description>
          <addressOffset>0x8118</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write_mask</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PERILP_REMAP_PERIPHERALS_MID</name>
              <description>middle 16 bits of 0xA0000000-0xDFFFFFFF remap.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>perilp_con7</name>
          <description>perilp_con7</description>
          <addressOffset>0x811c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write_mask</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PERILP_REMAP_FLASH_ROM_HIGH</name>
              <description>top 4 bits of 0x00000000-0x1FFFFFFF remap</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PERILP_REMAP_ON_CHIP_RAM_HIGH</name>
              <description>top 4 bits of 0x20000000-0x3FFFFFFF remap</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PERILP_REMAP_OFF_CHIP_RAM_HIGH</name>
              <description>Top 4 bits of 0x60000000-0x7FFFFFFF and 0x80000000-0x9FFFFFFF memory regions.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PERILP_REMAP_PERIPHERALS_HIGH</name>
              <description>top 4 bits of 0xA0000000-0xDFFFFFFF remap</description>
              <bitRange>[15:12]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>perilp_con4</name>
          <description>perilp_con4</description>
          <addressOffset>0x8110</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write_mask</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PERILP_REMAP_ON_CHIP_RAM_MID</name>
              <description>middle 16 bits of 0x20000000-0x3FFFFFFF remap</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>perilp_con5</name>
          <description>perilp_con5</description>
          <addressOffset>0x8114</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write_mask</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PERILP_REMAP_OFF_CHIP_RAM_MID</name>
              <description>Middle 16 bits of 0x60000000-0x7FFFFFFF and 0x80000000-0x9FFFFFFF memory regions.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ddr_rgn_con19</name>
          <description>ddr_rgn_con19</description>
          <addressOffset>0x4c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>ddr_rgn_con18</name>
          <description>ddr_rgn_con18</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>ddr_rgn_con15</name>
          <description>ddr_rgn_con15</description>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>ddr_rgn_con14</name>
          <description>ddr_rgn_con14</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>ddr_rgn_con17</name>
          <description>ddr_rgn_con17</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>ddr_rgn_con16</name>
          <description>ddr_rgn_con16</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>ddr_rgn_con11</name>
          <description>ddr_rgn_con11</description>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>ddr_rgn_con10</name>
          <description>ddr_rgn_con10</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>soc_con21</name>
          <description>soc_con21</description>
          <addressOffset>0x8054</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>soc_con20</name>
          <description>soc_con20</description>
          <addressOffset>0x8050</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>pmu_con8</name>
          <description>pmu_con8</description>
          <addressOffset>0xc120</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SGRF_CON_IRQLATENCY_M0</name>
              <description>Minimum number of cycles between an interrupt that becomes pended in the NVIC, and the vector fetch for that interrupt being issued</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WRITE_MASK</name>
              <description>write_mask</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>pmu_con1</name>
          <description>pmu_con1</description>
          <addressOffset>0xc104</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SGRF_CON_M0_STCALIB_TENMS_15_0</name>
              <description>See also: sgrf_con_m0_stcalib_tenms_23_16</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WRITE_MASK</name>
              <description>write_mask</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>pmu_con0</name>
          <description>pmu_con0</description>
          <addressOffset>0xc100</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SGRF_PMU_CM0_NMI</name>
              <description>Non maskable interrupt</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SGRF_PMU_ENABLE</name>
              <description>Internal PMU enable</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SGRF_MCU_DBGRESTART</name>
              <description>External restart request</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SGRF_MCU_EDBGRQ</name>
              <description>External debug request</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SGRF_MCU_RXEV</name>
              <description>A HIGH level on this input causes the architecture defined Event Register to be set in the Cortex-M0 processor. This causes a WFE instruction to complete. It also awakens the processor if it is sleeping as the result of encountering a WFE instruction when the Event Register is clear.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SGRF_MCU_DBGEN</name>
              <description>Serial Wire Debug enable</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SGRF_PMU_CM0S_RSTHOLD</name>
              <description>Reset hold control</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SGRF_PMU_CM0_MST_CTRL</name>
              <description>Master security attribute</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BOOTROM_REMAP</name>
              <description>Remaps 0xFFFF0000 to BOOTROM or INTMEM0. From page 29. **NOTE**: might be bootrom_remap_shadow instead.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WRITE_MASK</name>
              <description>write_mask</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>pmu_con3</name>
          <description>pmu_con3</description>
          <addressOffset>0xc10c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write_mask</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PMU_REMAP_FLASH_ROM_MID</name>
              <description>middle 16 bits of 0x00000000-0x1FFFFFFF remap</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>pmu_con2</name>
          <description>pmu_con2</description>
          <addressOffset>0xc108</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SGRF_CON_M0_STCALIB_NOREF</name>
              <description>Indicates that no alternative reference clock source has been integrated. Tie HIGH if STCLKEN has been tied off.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SGRF_CON_M0_STCALIB_SKEW</name>
              <description>Tie this LOW if the system timer clock, the external reference clock, or SCLK as indicated by STCALIB[25] (sgrf_con_m0_stcalib_noref), can guarantee an exact multiple of 10ms. Otherwise, tie this signal HIGH.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SGRF_CON_M0_STCALIB_TENMS_23_16</name>
              <description>See also: sgrf_con_m0_stcalib_tenms_15_0</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WRITE_MASK</name>
              <description>write_mask</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>pmu_con5</name>
          <description>pmu_con5</description>
          <addressOffset>0xc114</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write_mask</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PMU_REMAP_OFF_CHIP_RAM_MID</name>
              <description>Middle 16 bits of 0x60000000-0x7FFFFFFF and 0x80000000-0x9FFFFFFF memory regions.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>pmu_con4</name>
          <description>pmu_con4</description>
          <addressOffset>0xc110</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write_mask</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PMU_REMAP_ON_CHIP_RAM_MID</name>
              <description>middle 16 bits of 0x20000000-0x3FFFFFFF remap</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>pmu_con7</name>
          <description>pmu_con7</description>
          <addressOffset>0xc11c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write_mask</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PMU_REMAP_FLASH_ROM_HIGH</name>
              <description>top 4 bits of 0x00000000-0x1FFFFFFF remap</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMU_REMAP_ON_CHIP_RAM_HIGH</name>
              <description>top 4 bits of 0x20000000-0x3FFFFFFF remap</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMU_REMAP_OFF_CHIP_RAM_HIGH</name>
              <description>Top 4 bits of 0x60000000-0x7FFFFFFF and 0x80000000-0x9FFFFFFF memory regions.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMU_REMAP_PERIPHERALS_HIGH</name>
              <description>top 4 bits of 0xA0000000-0xDFFFFFFF remap</description>
              <bitRange>[15:12]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>pmu_con6</name>
          <description>pmu_con6</description>
          <addressOffset>0xc118</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write_mask</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PMU_REMAP_PERIPHERALS_MID</name>
              <description>middle 16 bits of 0xA0000000-0xDFFFFFFF remap</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>pmu_slv_con1</name>
          <description>pmu_slv_con1</description>
          <addressOffset>0xc244</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>pmu_slv_con0</name>
          <description>pmu_slv_con0</description>
          <addressOffset>0xc240</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>perilp_status</name>
          <description>perilp_status</description>
          <addressOffset>0x8140</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>efuse_prg_mask</name>
          <description>efuse_prg_mask</description>
          <addressOffset>0xc200</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>ddr_rgn_con33</name>
          <description>ddr_rgn_con33</description>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>ddr_rgn_con32</name>
          <description>ddr_rgn_con32</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>ddr_rgn_con31</name>
          <description>ddr_rgn_con31</description>
          <addressOffset>0x7c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>ddr_rgn_con30</name>
          <description>ddr_rgn_con30</description>
          <addressOffset>0x78</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>ddr_rgn_con34</name>
          <description>ddr_rgn_con34</description>
          <addressOffset>0x88</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>reserved13</name>
          <description>reserved13</description>
          <addressOffset>0xe3c8</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>ddr_rgn_con24</name>
          <description>ddr_rgn_con24</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>ddr_rgn_con25</name>
          <description>ddr_rgn_con25</description>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>ddr_rgn_con26</name>
          <description>ddr_rgn_con26</description>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>ddr_rgn_con27</name>
          <description>ddr_rgn_con27</description>
          <addressOffset>0x6c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>ddr_rgn_con20</name>
          <description>ddr_rgn_con20</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>ddr_rgn_con21</name>
          <description>ddr_rgn_con21</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>ddr_rgn_con22</name>
          <description>ddr_rgn_con22</description>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <resetValue>0xffff</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMAC1_RGN_S</name>
              <description>1 indicates secure, 0 indicates non-secure.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DMAC0_RGN_S</name>
              <description>1 indicates secure, 0 indicates non-secure.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WRITE_ENABLE</name>
              <description>write_enable</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ddr_rgn_con23</name>
          <description>ddr_rgn_con23</description>
          <addressOffset>0x5c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>ddr_rgn_con28</name>
          <description>ddr_rgn_con28</description>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>ddr_rgn_con29</name>
          <description>ddr_rgn_con29</description>
          <addressOffset>0x74</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>WDT2</name>
      <version>1.0</version>
      <groupname>WDT</groupname>
      <baseAddress>0xff380000</baseAddress>
      <registers>
        <register>
          <name>WDT_CR</name>
          <description>Control Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0xa</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RST_PLUSE_LENTH</name>
              <description>Reset pulse length.
This is used to select the number of pclk cycles
for which the system reset stays asserted.
000: 2 pclk cycles
001: 4 pclk cycles
010: 8 pclk cycles
011: 16 pclk cycles
100: 32 pclk cycles
101: 64 pclk cycles
110: 128 pclk cycles
111: 256 pclk cycles</description>
              <bitRange>[4:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESP_MODE</name>
              <description>Response mode.
Selects the output response generated to a timeout.
0: Generate a system reset.
1: First generate an interrupt and if it is not cleared by the time a
second timeout occurs then generate a system reset.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WDT_EN</name>
              <description>Writable when the configuration parameter WDT_ALWAYS_EN=0,
otherwise, it is readable. This bit is used to enable and disable the
watchdog. When disabled, the counter dose not decrement .Thus,
no interrupt or system reset is generated. Once this bit has been
enabled, it can be cleared only by a system reset.
0: WDT disabled;
1: WDT enabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_TORR</name>
          <description>Timeout range Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIMEOUT_PERIOD</name>
              <description>Timeout period.
This field is used to select the timeout period from
which the watchdog counter restarts. A change of the timeout
period takes effect only after the next counter restart (kick).
The range of values available for a 32-bit watchdog counter are:
0000: 0x0000ffff
0001: 0x0001ffff
0010: 0x0003ffff
0011: 0x0007ffff
0100: 0x000fffff
0101: 0x001fffff
0110: 0x003fffff
0111: 0x007fffff
1000: 0x00ffffff
1001: 0x01ffffff
1010: 0x03ffffff
1011: 0x07ffffff
1100: 0x0fffffff
1101: 0x1fffffff
1110: 0x3fffffff
1111: 0x7fffffff</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_CCVR</name>
          <description>Current counter value Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CUR_CNT</name>
              <description>Current counter value
This register, when read, is the current value of the internal
counter. This value is read coherently whenever it is read</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_CRR</name>
          <description>Counter restart Register</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNT_RESTART</name>
              <description>Counter restart
This register is used to restart the WDT counter. As a safety feature
to prevent accidental restarts, the value 0x76 must be written. A
restart also clears the WDT interrupt. Reading this register returns
zero.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_STAT</name>
          <description>Interrupt status Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WDT_STATUS</name>
              <description>This register shows the interrupt status of the WDT.
1: Interrupt is active regardless of polarity;
0: Interrupt is inactive.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_EOI</name>
          <description>Interrupt clear Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WDT_INT_CLR</name>
              <description>Clears the watchdog interrupt.
This can be used to clear the interrupt without restarting the
watchdog counter.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="WDT2">
      <name>WDT1</name>
      <version>1.0</version>
      <groupname>WDT</groupname>
      <baseAddress>0xff840000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="WDT2">
      <name>WDT0</name>
      <version>1.0</version>
      <groupname>WDT</groupname>
      <baseAddress>0xff848000</baseAddress>
    </peripheral>
    <peripheral>
      <name>GPIO0</name>
      <version>1.0</version>
      <groupname>GPIO</groupname>
      <baseAddress>0xff720000</baseAddress>
      <registers>
        <register>
          <name>GPIO_SWPORTA_DR</name>
          <description>Port A data register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIO_SWPORTA_DR</name>
              <description>Values written to this register are output on the I/O signals for
Port A if the corresponding data direction bits for Port A are set to
Output mode. The value read back is equal to the last value
written to this register.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIO_SWPORTA_DDR</name>
          <description>Port A data direction register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIO_SWPORTA_DDR</name>
              <description>Values written to this register independently control the direction
of the corresponding data bit in Port A.
0: Input (default)
1: Output</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIO_INTEN</name>
          <description>Interrupt enable register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIO_INT_EN</name>
              <description>Allows each bit of Port A to be configured for interrupts.
Whenever a 1 is written to a bit of this register, it configures the
corresponding bit on Port A to become an interrupt; otherwise,
Port A operates as a normal GPIO signal.
Interrupts are disabled on the corresponding bits of Port A if the
corresponding data direction register is set to Output.
0: Configure Port A bit as normal GPIO signal (default)
1: Configure Port A bit as interrupt</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIO_INTMASK</name>
          <description>Interrupt mask register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIO_INT_MASK</name>
              <description>Controls whether an interrupt on Port A can create an
interrupt for the interrupt controller by not masking it. Whenever
a 1 is written to a bit in this register, it masks the interrupt
generation capability for this signal; otherwise interrupts are
allowed through.
0: Interrupt bits are unmasked (default)
1: Mask interrupt</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIO_INTTYPE_LEVEL</name>
          <description>Interrupt level register</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIO_INTTYPE_LEVEL</name>
              <description>Controls the type of interrupt that can occur on Port A.
0: Level-sensitive (default)
1: Edge-sensitive</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIO_INT_POLARITY</name>
          <description>Interrupt polarity register</description>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIO_INT_POLARITY</name>
              <description>Controls the polarity of edge or level sensitivity that can occur on
input of Port A.
0: Active-low (default)
1: Active-high</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIO_INT_STATUS</name>
          <description>Interrupt status of port A</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIO_INT_STATUS</name>
              <description>Interrupt status of Port A</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIO_INT_RAWSTATUS</name>
          <description>Raw Interrupt status of port A</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIO_INT_RAWSTATUS</name>
              <description>Raw interrupt of status of Port A (premasking bits)</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIO_DEBOUNCE</name>
          <description>Debounce enable register</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIO_DEBOUNCE</name>
              <description>Controls whether an external signal that is the source of an
interrupt needs to be debounced to remove any spurious glitches.
Writing a 1 to a bit in this register enables the debouncing
circuitry. A signal must be valid for two periods of an external
clock before it is internally processed.
0: No debounce (default)
1: Enable debounce</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIO_PORTA_EOI</name>
          <description>Port A clear interrupt register</description>
          <addressOffset>0x4c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIO_PORTA_EOI</name>
              <description>Controls the clearing of edge type interrupts from Port A. When a
1 is written into a corresponding bit of this register, the interrupt
is cleared. All interrupts are cleared when Port A is not configured
for interrupts.
0: No interrupt clear (default)
1: Clear interrupt</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIO_EXT_PORTA</name>
          <description>Port A external port register</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIO_EXT_PORTA</name>
              <description>When Port A is configured as Input, then reading this location
reads the values on the signal. When the data direction of Port A
is set as Output, reading this location reads the data register for
Port A.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIO_LS_SYNC</name>
          <description>Level_sensitive synchronization enable register</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIO_LS_SYNC</name>
              <description>Writing a 1 to this register results in all level-sensitive interrupts
being synchronized to pclk_intr.
0: No synchronization to pclk_intr (default)
1: Synchronize to pclk_intr</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="GPIO0">
      <name>GPIO1</name>
      <version>1.0</version>
      <groupname>GPIO</groupname>
      <baseAddress>0xff730000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="GPIO0">
      <name>GPIO2</name>
      <version>1.0</version>
      <groupname>GPIO</groupname>
      <baseAddress>0xff780000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="GPIO0">
      <name>GPIO3</name>
      <version>1.0</version>
      <groupname>GPIO</groupname>
      <baseAddress>0xff788000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="GPIO0">
      <name>GPIO4</name>
      <version>1.0</version>
      <groupname>GPIO</groupname>
      <baseAddress>0xff790000</baseAddress>
    </peripheral>
    <peripheral>
      <name>EMMCCORE</name>
      <version>1.0</version>
      <groupname>EMMCCORE</groupname>
      <baseAddress>0xfe330000</baseAddress>
      <registers>
        <register>
          <name>EMMCCORE_SADDR</name>
          <description>System address/ Argument 2register/System address/ Argument 2 register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SADDR</name>
              <description>This register contains the physical system memory address used
for DMA transfers or the second argument for the Auto CMD23.
(1) SDMA System Address
This register contains the system memory address for a SDMA
transfer. When the Host Controller stops a SDMA transfer, this
register shall point to the system address of the next contiguous
data position. It can be accessed only if no transaction is
executing (i.e., after a transaction has stopped). Read operations
during transfers may return an invalid value. The Host Driver
shall initialize this register before starting a SDMA transaction.
After SDMA has stopped, the next system address of the next
contiguous data position can be read from this register.
The SDMA transfer waits at the every boundary specified by the
Host SDMA Buffer Boundary in the Block Size register. The Host
Controller generates DMA Interrupt to request the Host Driver to
update this register. The Host Driver sets the next system
address of the next data position to this register.
When the most upper byte of this register (003h) is written, the
Host Controller restarts the SDMA transfer.
When restarting SDMA by the Resume command or by setting
Continue Request in the Block Gap Control register, the Host
Controller shall start at the next contiguous address stored here
in the SDMA System Address register. ADMA does not use this
register.
(2) Argument 2
This register is used with the Auto CMD23 to set a 32-bit block
count value to the argument of the CMD23 while executing Auto
CMD23.
If Auto CMD23 is used with ADMA, the full 32-bit block count
value can be used. If Auto CMD23 is used without AMDA, the
available block count value is limited by the Block Count register.
65535 blocks is the maximum value in this case.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EMMCCORE_BLKSIZ</name>
          <description>Block size register</description>
          <addressOffset>0x4</addressOffset>
          <size>16</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>HOSTSDMABUFFERSIZE</name>
              <description>To perform long DMA transfer, System Address register shall be
updated at every system boundary during DMA transfer. These
bits specify the size of contiguous buffer in the system memory.
The DMA transfer shall wait at the every boundary specified by
these fields and the HC generates the DMA Interrupt to request
the HD to update the System Address register.
These bits shall support when the DMA Support in the Capabilities
register is set to 1 and this function is active when the DMA
Enable in the Transfer Mode register is set to 1.
3'h0: 4KB(Detects A11 Carry out)
3'h1: 8KB(Detects A12 Carry out)
3'h2: 16KB(Detects A13 Carry out)
3'h3: 32KB(Detects A14 Carry out)
3'h4: 64KB(Detects A15 Carry out)
3'h5: 128KB(Detects A16 Carry out)
3'h6: 256KB(Detects A17 Carry out)
3'h7: 512KB(Detects A18 Carry out)</description>
              <bitRange>[14:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TRANSFERBLOCKSIZE</name>
              <description>This register specifies the block size for block data transfers for
CMD17, CMD18, CMD24, CMD25, and CMD53. It can be accessed
only if no transaction is executing (i.e after a transaction has
stopped). Read operations during transfer return an invalid value
and write operations shall be ignored.
12'h0000: No Data Transfer
12'h0001: 1 Byte
12'h0002: 2 Bytes
12'h0003: 3 Bytes
12'h0004: 4 Bytes
........
12'h01FF: 511 Bytes
12'h0200: 512 Bytes
........
12'h0800: 2048 Bytes</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EMMCCORE_BLKCNT</name>
          <description>Block count register</description>
          <addressOffset>0x6</addressOffset>
          <size>16</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>BLOCKCOUNTFORCURRENTTRANSFER</name>
              <description>This register is enabled when Block Count Enable in the Transfer
Mode register is set to 1 and is valid only for multiple block
transfers. The HC decrements the block count after each block
transfer and stops when the count reaches zero. It can be
accessed only if no transaction is executing (i.e. after a
transaction has stopped). Read operations during transfer return
an invalid value and write operations shall be ignored.
When saving transfer context as a result of Suspend command,
the number of blocks yet to be transferred can be determined by
reading this register. When restoring transfer context prior to
issuing a Resume command, the HD shall restore the previously
save block count.
16'h0000: Stop Count
16'h0001: 1 block
16'h0002: 2 blocks
........
16'hFFFF: 65535 blocks</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EMMCCORE_ARG</name>
          <description>Argument register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COMMANDARGUMENT1</name>
              <description>The SD Command Argument is specified as bit39-8 of Command-
Format.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EMMCCORE_TRANSMOD</name>
          <description>Transfer mode register</description>
          <addressOffset>0xc</addressOffset>
          <size>16</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>MULTIBLOCKSELECT</name>
              <description>This bit enables multiple block data transfers.
0: Single Block
1: Multiple Block</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATATRANSFERDIRECTIONSELECT</name>
              <description>This bit defines the direction of data transfers.
0: Write (Host to Card)
1: Read (Card to Host)</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTOCMDENABLE</name>
              <description>This field determines use of auto command functions
0: Auto Command Disabled
1: Auto CMD12 Enable
2: Auto CMD23 Enable
3: Reserved
There are two methods to stop Multiple-block read and write
operation.
(1) Auto CMD12 Enable
Multiple-block read and write commands for memory require
CMD12 to stop the operation. When this field is set to 01b, the
Host Controller issues CMD12 automatically when last block
transferis completed. Auto CMD12 error is indicated to the Auto
CMD Error Status register. The Host Driver shall not set this bit if
the command does not require CMD12.
(2) Auto CMD23 Enable
When this bit field is set to 10b, the Host Controller issues a
CMD23 automatically before issuing a command specified in the
Command Register
The following conditions are required to use the Auto CMD23.
a. Auto CMD23 Supported (Host Controller Version is 3.00 or
later)
b. A memory card that supports CMD23 (SCR[33]=1)
c. If DMA is used, it shall be ADMA
d. Only when CMD18 or CMD25 is issued
By writing the Command register, the Host Controller issues a
CMD23 first and then issues a command specified by the
Command Index in Command register 32-bit block count value
for CMD23 is set to SDMA System Address / Argument 2 register</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKCOUNTENABLE</name>
              <description>This bit is used to enable the Block count register, which is only
relevant for multiple block transfers. When this bit is 0, the Block
Count register is disabled, which is useful in executing an infinite
transfer.
0: Disable
1: Enable</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DMAENABLE</name>
              <description>DMA can be enabled only if DMA Support bit in the Capabilities
register is set. If this bit is set to 1, a DMA operation shall begin
when the HD writes to the upper byte of Command register
(00Fh).
0: Disable
1: Enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EMMCCORE_CMD</name>
          <description>Command register</description>
          <addressOffset>0xe</addressOffset>
          <size>16</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>CMDTYPE</name>
              <description>0: Normal
1: Suspend
2: Resume
3: Abort
There are three types of special commands. Suspend, Resume
and Abort. These bits shall bet set to 00b for all other commands.
Suspend Command
If the Suspend command succeeds, the HC shall assume the SD
Bus has been released and that it is possible to issue the next
command which uses the DAT line. The HC shall de-assert Read
Wait for read transactions and stop checking busy for write
transactions. The Interrupt cycle shall start, in 4-bit mode. If the
Suspend command fails, the HC shall maintain its current state.
and the HD shall restart the transfer by setting Continue Request
in the Block Gap Control Register.
Resume Command
The HD re-starts the data transfer by restoring the registers in
the range of 000-00Dh. The HC shall check for busy before
starting write transfers.
Abort Command
If this command is set when executing a read transfer, the HC
shall stop reads to the buffer. If this command is set when
executing a write transfer, the HC shall stop driving the DAT line.
After issuing the Abort command, the HD should issue a software
reset.</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATAPRESENTSEL</name>
              <description>0: No Data Present
1: Data Present
This bit is set to 1 to indicate that data is present and shall be
transferred using the DAT line. If is set to 0 for the following:
a. Commands using only CMD line (ex. CMD52)
b. Commands with no data transfer but using busy signal on
DAT[0] line (R1b or R5b ex. CMD38)
c Resume Command</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMDINDEXCHKENA</name>
              <description>If this bit is set to 1, the HC shall check the index field in the
response to see if it has the same value as the command index.
If it is not, it is reported as a Command Index Error. If this bit is
set to 0, the Index field is not checked.
0: Disable
1: Enable</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMDCRCCHKENA</name>
              <description>If this bit is set to 1, the HC shall check the CRC field in the
response. If an error is detected, it is reported as a Command
CRC Error. If this bit is set to 0, the CRC field is not checked.
0: Disable
1: Enable</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESPTYPESEL</name>
              <description>Response Type Select
0: No Response
1: Response length 136
2: Response length 48
3: Response length 48 check Busy after response</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EMMCCORE_RESP0</name>
          <description>Response register bit [31:0]</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RESP</name>
              <description>Response register bit [31:0]</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EMMCCORE_RESP1</name>
          <description>Response register bit [63:32]</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RESP</name>
              <description>Response register bit [63:32]</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EMMCCORE_RESP2</name>
          <description>Response register bit [95:64]</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RESP</name>
              <description>Response register bit [95:64]</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EMMCCORE_RESP3</name>
          <description>Response register bit [127:98]</description>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RESP</name>
              <description>Response register bit [127:98]</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EMMCCORE_BUFFER</name>
          <description>Buffer data port register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BUFFERDATA</name>
              <description>The Host Controller Buffer can be accessed through this 32-bit
Data Port Register.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EMMCCORE_PRESTS</name>
          <description>Present state register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x1fff0000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DAT74LINESIGNALLEVEL</name>
              <description>This status is used to check DAT line level to recover from errors,
and for debugging.
[28]: DAT[7]
[27]: DAT[6]
[26]: DAT[5]
[25]: DAT[4]</description>
              <bitRange>[28:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMDLINESIGNALLEVEL</name>
              <description>This status is used to check CMD line level to recover from errors,
and for debugging.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DAT30LINESIGNALLEVEL</name>
              <description>DAT[3:0] Line Signal Level
This status is used to check DAT line level to recover from errors,
and for debugging. This is especially useful in detecting the busy
signal level from DAT[0].
[23]: DAT[3]
[22]: DAT[2]
[21]: DAT[1]
[20]: DAT[0]</description>
              <bitRange>[23:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WRPRTSWPINLVL</name>
              <description>Write Protect Switch Pin Level.
The Write Protect Switch is supported for memory and combo
cards. This bit reflects the SDWP# pin.
0: Write protected (SDWP# = 0)
1: Write enabled (SDWP# = 1)</description>
              <bitRange>[19:19]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CARDDETECTPINLEVEL</name>
              <description>This bit reflects the inverse value of the SDCD# pin.
0: No Card present (SDCD# = 1)
1: Card present (SDCD# = 0)</description>
              <bitRange>[18:18]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CARDSTATESTABLE</name>
              <description>0: Reset of Debouncing
1: No Card or Inserted
This bit is used for testing. If it is 0, the Card Detect Pin Level is
not stable. If this bit is set to 1, it means the Card Detect Pin
Level is stable. The Software Reset For All in the Software Reset
Register shall not affect this bit.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CARDINSERTED</name>
              <description>0: Reset or Debouncing or NoCard
1: Card Inserted
This bit indicates whether a card has been inserted. Changing
from 0 to 1 generates a Card Insertion interrupt in the Normal
Interrupt Status register and changing from 1 to 0 generates a
Card Removal Interrupt in the Normal Interrupt Status register.
The Software Reset For All in the Software Reset register shall
not affect this bit.
If a Card is removed while its power is on and its clock is
oscillating, the HC shall clear SD Bus Power in the Power Control
register and SD Clock Enable in the Clock control register. In
addition the HD should clear the HC by the Software Reset For All
in Software register. The card detect is active regardless of the
SD Bus Power.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BUFFERREADENABLE</name>
              <description>0: Read Disable
1: Read Enable
This status is used for non-DMA read transfers.
This read only flag indicates that valid data exists in the host side
buffer status. If this bit is 1, readable data exists in the buffer. A
change of this bit from 1 to 0 occurs when all the block data is
read from the buffer. A change of this bit from 0 to 1 occurs
when all the block data is ready in the buffer and generates the
Buffer Read Ready Interrupt.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BUFFERWRITEENABLE</name>
              <description>0: Write Disable
1: Write Enable
This status is used for non-DMA write transfers.
This read only flag indicates if space is available for write data. If
this bit is 1, data can be written to the buffer. A change of this bit
from 1 to 0 occurs when all the block data is written to the
buffer. A change of this bit from 0 to 1 occurs when top of block
data can be written to the buffer and generates the Buffer Write
Ready Interrupt.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>READTRANSACTIVE</name>
              <description>1: Transferring data
0: No valid data
This status is used for detecting completion of a read transfer.
This bit is set to 1 for either of the following conditions:
a. After the end bit of the read command
b. When writing a 1 to continue Request in the Block Gap Control
register to restart a read transfer
This bit is cleared to 0 for either of the following conditions:
a. When the last data block as specified by block length is
transferred to the system.
b. When all valid data blocks have been transferred to the system
and no current block transfers are being sent as a result of the
Stop At Block Gap Request set to 1. A transfer complete interrupt
is generated when this bit changes to 0.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WRITETRANSACTIVE</name>
              <description>1: transferring data
0: No valid data
This status indicates a write transfer is active. If this bit is 0, it
means no valid write data exists in the HC. This bit is set in either
of the following cases:
a. After the end bit of the write command.
b. When writing a 1 to Continue Request in the Block Gap Control
register to restart a write transfer.
This bit is cleared in either of the following cases:
a. After getting the CRC status of the last data block as specified
by the transfer count (Single or Multiple).
b. After getting a CRC status of any block where data
transmission is about to be stopped by a Stop At Block Gap
Request.
During a write transaction, a Block Gap Event interrupt is
generated when this bit is changed to 0, as a result of the Stop At
Block Gap Request being set. This status is useful for the HD in
determining when to issue commands during write busy.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RETUNINGREQ</name>
              <description>Re-Tuning Request
1: Sampling clock needs re-tuning
0: Fixed or well tuned sampling clock
Host Controller may request Host Driver to execute re-tuning
sequence by setting this bit when the data window is shifted by
temperature drift and a tuned sampling point does not have a
good margin to receive correct data.
This bit is cleared when a command is issued with setting Execute
Tuning in the Host Control 2 register.
Changing of this bit from 0 to 1 generates Re-Tuning Event. Refer
to Normal Interrupt registers for more detail.
This bit isn't set to 1 if Sampling Clock Select in the Host Control
2 register is set to 0 (using fixed sampling clock).</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DATLINEACTIVE</name>
              <description>This bit indicates whether one of the DAT line on SD bus is in use.
1: DAT line active
0: DAT line inactive</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DATINHIBIT</name>
              <description>1: cannot issue command which uses the DAT line
0: Can issue command which uses the DAT line
This status bit is generated if either the DAT Line Active or the
Read transfer Active is set to 1. If this bit is 0, it indicates the HC
can issue the next SD command. Commands with busy signal
belong to Command Inhibit (DAT) (ex. R1b, R5b type).
Changing from 1 to 0 generates a Transfer Complete interrupt in
the Normal interrupt status register.
Note: The SD Host Driver can save registers in the range of 000-
00Dh for a suspend transaction after this bit has changed from 1
to 0.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CMDINHIBIT</name>
              <description>If this bit is 0, it indicates the CMD line is not in use and the HC
can issue a SD command using the CMD line. This bit is set
immediately after the Command register is written. This bit is
cleared when the command response is received.
Even if the Command Inhibit (DAT) is set to 1, Commands using
only the CMD line can be issued if this bit is 0. Changing from 1
to 0 generates a Command complete interrupt in the Normal
Interrupt Status register. If the HC cannot issue the command
because of a command conflict error or because of Command Not
Issued By Auto CMD12 Error, this bit shall remain 1 and the
Command Complete is not set. Status issuing Auto CMD12 is not
read from this bit.
Auto CMD12 and Auto CMD23 consist of two responses. In this
case, this bit is not cleared by the response of CMD12 or CMD23
but cleared by the response of a read/write command. Status
issuing Auto CMD12 is not read from this bit. So if a command is
issued during Auto CMD12 operation, Host Controller shall
manage to issue two commands: CMD12 and a command set by
Command register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EMMCCORE_HOSTCTRL1</name>
          <description>Host control 1 register</description>
          <addressOffset>0x28</addressOffset>
          <size>8</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>CARDDETSGINALDET</name>
              <description>This bit selects source for card detection.
1: The card detect test level is selected
0: SDCD# is selected (for normal use)</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CARDDETTESTLEVEL</name>
              <description>This bit is enabled while the Card Detect Signal Selection is set to
1 and it indicates card inserted or not.
Generates (card ins or card removal) interrupt when the normal
int sts enable bit is set.
1: Card Inserted
0: No Card</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EXTENDEDDATATRANSWIDTH</name>
              <description>This bit controls 8-bit bus width mode for embedded device.
Support of this function is indicated in 8-bit Support for
Embedded Device in the Capabilities register. If a device supports
8-bit bus mode, this bit may be set to 1. If this bit is 0, bus width
is controlled by Data Transfer Width in the Host Control 1
register.This bit is not effective when multiple devices are
installed on a bus slot (Slot Type is set to 10b in the Capabilities
register). In this case, each device bus width is controlled by Bus
Width Preset field in the Shared Bus register.
1: 8-bit Bus Width
0: Bus Width is Selected by Data Transfer Width</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASELECT</name>
              <description>One of supported DMA modes can be selected. The host driver
shall check support of DMA modes by referring the Capabilities
register.
0: SDMA is selected
1: 32-bit Address ADMA1 is selected
2: 32-bit Address ADMA2 is selected
3: 64-bit Address ADMA2 is selected</description>
              <bitRange>[4:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HIGHSPEEDENA</name>
              <description>1: High Speed Mode
0: Normal Speed Mode
This bit is optional. Before setting this bit, the HD shall check the
High Speed Support in the capabilities register. If this bit is set to
0 (default), the HC outputs CMD line and DAT lines at the falling
edge of the SD clock (up to 25 MHz/20MHz for eMMC). If thisbit
is set to 1, the HC outputs CMD line and DAT lines at the rising
edge of the SD clock (up to 50 MHz for SD/52MHz for eMMC)/
208Mhz (for SD3.0).
If Preset Value Enable in the Host Control 2 register is set to 1,
Host Driver needs to reset SD Clock Enable before changing this
field to avoid generating clock glitches. After setting this field, the
Host Driver sets SD Clock Enable again</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATATRANSWIDTH</name>
              <description>1: 4 bit mode
0: 1 bit mode
This bit selects the data width of the HC. The HD shall select it to
match the data width of the SD card.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EMMCCORE_PWRCTRL</name>
          <description>Power control register</description>
          <addressOffset>0x29</addressOffset>
          <size>8</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>SDBUSPOWER</name>
              <description>1: Power on
0: Power off</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EMMCCORE_BLKGAPCTRL</name>
          <description>Block gap control register</description>
          <addressOffset>0x2a</addressOffset>
          <size>8</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>BOOTACKCHK</name>
              <description>To check for the boot acknowledge in boot operation.
1: wait for boot ack from eMMC card
0: Will not wait for boot ack from eMMC card</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALTBOOTEN</name>
              <description>To start boot code access in alternative mode.
1: To start alternate boot mode access
0: To stop alternate boot mode access</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BOOTEN</name>
              <description>To start boot code access.
1: To start boot code access
0: To stop boot code access</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPIMODE</name>
              <description>SPI mode enable bit.
1: SPI mode
0: SD mode</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INTATBLKGAP</name>
              <description>Interrupt At Block Gap.
This bit is valid only in 4-bit mode of the SDIO card and selects a
sample point in the interrupt cycle. Setting to 1 enables interrupt
detection at the block gap for a multiple block transfer. If the SD
card cannot signal an interrupt during a multiple block transfer,
this bit should be set to 0. When the HD detects an SD card
insertion, it shall set this bit according to the CCCR of the SDIO
card.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>READWAITCONTROL</name>
              <description>1: Enable Read Wait Control
0: Disable Read Wait Control
The read wait function is optional for SDIO cards. If the card
supports read wait, set this bit to enable use of the read wait
protocol to stop read data using DAT[2] line. Otherwise the HC
has to stop the SD clock to hold read data, which restricts
commands generation. When the HD detects an SD card
insertion, it shall set this bit according to the CCCR of the SDIO
card. If the card does not support read wait, this bit shall never
be set to 1 otherwise DAT line conflict may occur.
If this bit is set to 0, Suspend / Resume cannot be supported</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CONTINUEREQUEST</name>
              <description>1: Restart
0: Ignored
This bit is used to restart a transaction which was stopped using
the Stop At Block Gap Request. To cancel stop at the block gap,
set Stop At block Gap Request to 0 and set this bit to restart the
transfer.
The HC automatically clears this bit in either of the following
cases:
a. In the case of a read transaction, the DAT Line Active changes
from 0 to 1 as a read transaction restarts.
b. In the case of a write transaction, the Write transfer active
changes from 0 to 1 as the write transaction restarts.
Therefore it is not necessary for Host driver to set this bit to 0. If
Stop At Block Gap Request is set to 1, any write to this bit is
ignored.</description>
              <bitRange>[1:1]</bitRange>
              <access>write-only</access>
              <modifiedWriteValues>clear</modifiedWriteValues>
            </field>
            <field>
              <name>STOPATBLKGAPREQ</name>
              <description>1: Stop
0: Transfer
This bit is used to stop executing a transaction at the next block
gap for non-DMA,SDMA and ADMA transfers. Until the transfer
complete is set to 1, indicating a transfer completion the HD shall
leave this bit set to 1. Clearing both the Stop At Block Gap
Request and Continue Request shall not cause the transaction to
restart. Read Wait is used to stop the read transaction at the
block gap. The HC shall honour Stop At Block Gap Request for
write transfers, but for read transfers it requires that the SD card
support Read Wait.
Therefore the HD shall not set this bit during read transfers
unless the SD card supports Read Wait and has set Read Wait
Control to 1. In case ofwrite transfers in which the HD writes data
to the Buffer Data Port register, the HD shall set this bit after all
block data is written. If this bit is set to 1, the HD shall not write
data to Buffer data port register. This bit affects Read Transfer
Active, Write Transfer Active, DAT line active and Command
Inhibit (DAT) in the Present State register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EMMCCORE_CLKCTRL</name>
          <description>Clock control Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>16</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>SDCLKFREQSEL</name>
              <description>SDCLK Frequency Select.
This register is used to select the frequency of the SDCLK pin.
The frequency is not programmed directly; rather this register
holds the divisor of the Base Clock Frequency For SD clock in the
capabilities register. Only the following settings are allowed.
(1) 8-bit Divided Clock Mode
8'h80: base clock divided by 256
8'h40: base clock divided by 128
8'h20: base clock divided by 64
8'h10: base clock divided by 32
8'h08: base clock divided by 16
8'h04: base clock divided by 8
8'h02: base clock divided by 4
8'h01: base clock divided by 2
8'h00: base clock(10MHz-63MHz)
Setting 8'h00 specifies the highest frequency of the SD Clock.
When setting multiple bits, the most significant bit is used as the
divisor. But multiple bits should not be set. The two default
divider values can be calculated by the frequency that is defined
by the Base Clock Frequency For SD Clock in the Capabilities
register.
a. 25 MHz divider value
b. 400 KHz divider value
The frequency of the SDCLK is set by the following formula:
Clock Frequency = (Baseclock) / divisor.
Thus choose the smallest possible divisor which results in a clock
frequency that is less than or equal to the target frequency.
Maximum Frequency for SD = 50Mhz (base clock)
Maximum Frequency for eMMC = 52Mhz (base clock)
Minimum Frequency = 195.3125Khz (50Mhz / 256), same
calculation for eMMC also.
(2) 10-bit Divided Clock Mode
Host Controller supports this mandatory mode instead of the 8-
bit Divided Clock Mode. The length of divider is extended to10
bits and all divider values shall be supported.
10'h3FF:1/2046 Divided Clock
N: 1/2N Divided Clock (Duty 50%)
10'h002: 1/4 Divided Clock
10'h001: 1/2 Divided Clock
10'h000: Base Clock (10MHz-254MHz)</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDCLKFREQSELUPPER</name>
              <description>Field0001 Abstract
Upper Bits of SDCLK Frequency Select.
Bit 07-06 is assigned to bit 09-08 of clock divider in SDCLK
Frequency Select</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKGENSEL</name>
              <description>Clock Generator Select.
1: Programmable Clock Mode
0: Divided Clock Mode
This bit is used to select the clock generator mode in SDCLK
Frequency Select.
If the Programmable Clock Mode is supported (non-zero value is
set to Clock Multiplier in the Capabilities register), this bit
attribute is RW, and if not supported, this bit attribute is RO and
zero is read.
This bit depends on the setting of Preset Value Enable in the Host
Control 2 register.
If the Preset Value Enable= 0, this bit is set by Host Driver.
If the Preset Value Enable= 1, this bit is automatically set to a
value specified in one of Preset Value registers.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDCLKENA</name>
              <description>SD Clock Enable.
1: Enable
0: Disable
The HC shall stop SDCLK when writing this bit to 0. SDCLK
frequency Select can be changed when this bit is 0. Then, the HC
shall maintain the same clock frequency until SDCLK is stopped
(Stop at SDCLK = 0). If the HC detects the No Card state, this bit
shall be cleared.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INTERNALCLOCKSTABLE</name>
              <description>Internal Clock Stable.
1: Ready
0: Not Ready
This bit is set to 1 when SD clock is stable after writing to
Internal Clock Enable in this register to 1. The SD Host Driver
shall wait to set SD Clock Enable until this bit is set to 1.
Note: This is useful when using PLL for a clock oscillator that
requires setup time.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INTERNALCLOCKENABLE</name>
              <description>1: Oscillate
0: Stop
This bit is set to 0 when the HD is not using the HC or the HC
awaits a wakeup event. The HC should stop its internal clock to
go very low power state. Still, registers shall be able to be read
and written. Clock starts to oscillate when this bit is set to 1.
When clock oscillation is stable, the HC shall set Internal Clock
Stable in this register to 1. This bit shall not affect card detection.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EMMCCORE_TIMEOUT</name>
          <description>Timeout control register</description>
          <addressOffset>0x2e</addressOffset>
          <size>8</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>DATATIMEOUTCOUNTERVALUE</name>
              <description>This value determines the interval by which DAT line time-outs
are detected.
Refer to the Data Time-out Error in the Error Interrupt
Statusregister for information on factors that dictate time-out
generation. Time-out clock frequency will be generated by
dividing the sdclockTMCLK by this value. When setting this
register, prevent inadvertent time-out events by clearing the
Data Time-out Error Status Enable (in the Error Interrupt Status
Enable register).
4'hf: Reserved
4'he: TMCLK * 2^27
......
4'h1: TMCLK * 2^14
4'h0: TMCLK * 2^13</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EMMCCORE_SWRST</name>
          <description>Software reset register</description>
          <addressOffset>0x2f</addressOffset>
          <size>8</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>SOFTWARERESETDAT</name>
              <description>Software Reset for DAT Line.
1: Reset
0: Work
Only part of data circuit is reset. The following registers and bits
are cleared by this bit:
a. Buffer Data Port Register:
Buffer is cleared and Initialized
b. Present State register:
Buffer read Enable
Buffer write Enable
Read Transfer Active
Write Transfer Active
DAT Line Active
Command Inhibit (DAT)
c. Block Gap Control register:
Continue Request
Stop At Block Gap Request
d. Normal Interrupt Status register:
Buffer Read Ready
Buffer Write Ready
Block Gap Event
Transfer Complete</description>
              <bitRange>[2:2]</bitRange>
              <access>write-only</access>
              <modifiedWriteValues>clear</modifiedWriteValues>
            </field>
            <field>
              <name>SOFTWARERESETCMD</name>
              <description>Only part of command circuit is reset.
1: Reset
0: Work
The following registers and bits are cleared by this bit:
a. Present State register:
Command Inhibit (CMD)
b. Normal Interrupt Status register:
Command Complete</description>
              <bitRange>[1:1]</bitRange>
              <access>write-only</access>
              <modifiedWriteValues>clear</modifiedWriteValues>
            </field>
            <field>
              <name>SOFTWARERESETALL</name>
              <description>Software Reset for All
1: Reset
0: Work
This reset affects the entire HC except for the card detection
circuit. Register bits of type ROC, RW, RW1C, RWAC are cleared
to 0. During its initialization, the HD shall set this bit to 1 to reset
the HC.
The HC shall reset this bit to 0 when capabilities registers are
valid and the HD can read them. Additional use of Software Reset
For All may not affect the value of the Capabilities registers. If
this bit is set to 1, the SD card shall reset itself and must be
reinitialized by the HD.</description>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
              <modifiedWriteValues>clear</modifiedWriteValues>
            </field>
          </fields>
        </register>
        <register>
          <name>EMMCCORE_NORINTSTS</name>
          <description>Normal interrupt status register</description>
          <addressOffset>0x30</addressOffset>
          <size>16</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>ERRORINTERRUPT</name>
              <description>0: No Error
1: Error
If any of the bits inthe Error Interrupt Status Register are set,
then this bit is set. Therefore the HD can test for an error by
checking this bit first.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BOOTTERMINATEINTERRUPT</name>
              <description>This status is set if the boot operation get terminated
0: Boot operation is not terminated
1: Boot operation is terminated</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>BOOTACKRCV</name>
              <description>This status is set if the boot acknowledge is received from device.
0: Boot ack is not received
1: Boot ack is received</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>RETUNINGEVENT</name>
              <description>1: Re-Tuning should be performed
0: Re-Tuning is not required
This status is set if Re-Tuning Request in the Present State
register changes from 0 to 1.
Host Controller requestsHost Driver to perform re-tuning for next
data transfer. Current data transfer (not large block count) can
be completed without re-tuning.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CARDINTERRUPT</name>
              <description>0: No Card Interrupt
1: Generate Card Interrupt
Writing this bit to 1 does not clear this bit. It is cleared by
resetting the SD card interrupt factor. In 1-bit mode, the HC shall
detect the Card Interrupt without SD Clock to support wakeup.
In 4-bit mode, the card interrupt signal is sampled during the
interrupt cycle, so there are some sample delays between the
interrupt signal from the card and the interrupt to the Host
system.
when this status has been set and the HD needs to start this
interrupt service, Card Interrupt Status Enable in the Normal
Interrupt Status register shall be set to 0 in order to clear the
card interrupt statuses latched in the HC and stop driving the
Host System. After completion of the card interrupt service (the
reset factor in the SD card and the interrupt signal may not be
asserted), set Card Interrupt Status Enable to 1 and start
sampling the interrupt signal again.
Interrupt detected by DAT[1] is supported when there is a card
per slot.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CARDREMOVAL</name>
              <description>0: Card State Stable or Debouncing
1: Card Removed
This status is set if the Card Inserted in the Present State register
changes from 1 to 0.
When the HD writes this bit to 1 to clear this status the status of
the Card Inserted in the Present State registershould be
confirmed.
Because the card detect may possibly be changed when the HD
clear this bit an Interrupt event may not be generated.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>CARDINSERTION</name>
              <description>0: Card State Stable or Debouncing
1: Card Inserted
This status is set if the Card Inserted in the Present State register
changes from 0 to 1.
When the HD writes this bit to 1 to clear this status the status of
the Card Inserted in the Present State registershould be
confirmed.
Because the card detect may possibly be changed when the HD
clear this bit an Interrupt event may not be generated.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>BUFFERREADREADY</name>
              <description>0: Not Ready to read Buffer
1: Ready to read Buffer
This status is set if the Buffer Read Enable changes from 0 to 1.
Buffer Read Ready is set to 1 for every CMD19 execution in
tuning procedure.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>BUFFERWRITEREADY</name>
              <description>0: Not Ready to Write Buffer
1: Ready to Write Buffer
This status is set if the Buffer Write Enable changes from 0 to 1.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>DMAINTERRUPT</name>
              <description>0: No DMA Interrupt
1: DMA Interrupt is Generated
This status is set if the HC detects the Host DMA Buffer Boundary
in the Block Size regiser.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>BLOCKGAPEVENT</name>
              <description>0: No Block Gap Event
1: Transaction stopped at Block Gap
If the Stop At Block Gap Request in the Block Gap Control
Register is set, this bit is set.
a. Read Transaction:
This bit is set at the falling edge of the DAT Line Active Status
(When the transaction is stopped at SD Bus timing. The Read
Wait must be supported inorder to use this function).
b. Write Transaction:
This bit is set at the falling edge of Write Transfer Active Status
(After getting CRC status at SD Bus timing).</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>TRANSFERCOMPLETE</name>
              <description>0: No Data Transfer Complete
1: Data Transfer Complete
This bit is set when a read / write transaction is completed.
a. Read Transaction:
This bit is set at the falling edge of Read Transfer Active Status.
There are two cases in which the Interrupt is generated. The first
is when a data transfer is completed as specified by data length
(After the last data has been read to the Host System). The
second is when data has stopped at the block gap and completed
the data transfer by setting the Stop At Block Gap Request in the
Block Gap Control Register (After valid data has been read to the
Host System).
b. Write Transaction:
This bit is set at the falling edge of the DAT Line Active Status.
There are two cases in which the Interrupt is generated. The first
is when the last data is written to the card as specified by data
length and Busy signal is released. The second is when data
transfers are stopped at the block gap by setting Stop At Block
Gap Request in the Block Gap Control Register and data transfers
completed. (Aftervalid data is written to the SD card and the busy
signal is released).
c. In case of command with busy
This bit is set when busy is deasserted.
Note:
a. Transfer Complete has higher priority than Data Time-out
Error. If both bits are set to 1, the data transfer can be
considered complete
b. While performing tuning procedure (Execute Tuning is set to
1), Transfer Complete is not set to 1</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>COMMANDCOMPLETE</name>
              <description>0: No Command Complete
1: Command Complete
This bit is set when we get the end bit of the command response
(Except Auto CMD12 and Auto CMD23)
Note: Command Time-out Error has higher priority than
Command Complete. If both are set to 1, it can be considered
that the response was not received correctly.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
          </fields>
        </register>
        <register>
          <name>EMMCCORE_ERRINTSTS</name>
          <description>Error interrupt status register</description>
          <addressOffset>0x32</addressOffset>
          <size>16</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>TARGETRESPERR</name>
              <description>0: no error
1: error
Occurs when detecting ERROR in m_hresp(dma transaction)</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>ADMAERR</name>
              <description>1: Error
0: No error
This bit is set when the Host Controller detects errors during
ADMA based data transfer. The state of the ADMA at an error
occurrence is saved in the ADMA Error Status Register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>AUTOCMDERR</name>
              <description>0: No Error
1: Error
Auto CMD12 and Auto CMD23 use this error status.
This bit is set when detecting that one of the bits D00-D04 in
Auto CMD Error Status register has changed from 0 to 1. In case
of Auto CMD12, this bit is set to 1, not only when the errors in
Auto CMD12 occur but also when Auto CMD12 is not executed
due to the previous command error.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>CURRENTLIMITERR</name>
              <description>0: No Error
1: Power Fail
By setting the SD Bus Power bit in the Power Control Register,
the HC is requested to supply power for the SD Bus. If the HC
supports the Current Limit Function, it can be protected from an
Illegal card by stopping power supply to the card in which case
this bit indicates a failure status. Reading 1 means the HC is not
supplying power to SD card due to some failure. Reading 0
means that the HC is supplying power and no error has occurred.
This bit shall always set to be 0, if the HC does not support this
function.
Note: The current_Limit_Error is to be implemented if customer
application requires it.. By default it is not implementedas there
is no specific requirement from Customers.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>DATAENDBITERR</name>
              <description>0: No Error
1: Error
Occurs when detecting 0 at the end bit position of read data
which uses the DAT line or the end bit position of the CRC status.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>DATACRCERR</name>
              <description>0: No Error
1: Error
Occurs when detecting CRC error when transferring read data
which uses the DAT line or when detecting the Write CRC Status
having a value of other than "010".</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>DATATIMEOUTERR</name>
              <description>0: No Error
1: Timeout
Occurs when detecting one of following timeout conditions.
a. Busy Timeout for R1b, R5b type.
b. Busy Timeout after Write CRC status
c. Write CRC status Timeout
d. Read Data Timeout</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>CMDINDEXERR</name>
              <description>0: No Error
1: Error
Occurs if a Command Index error occurs in the Command
Response.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>CMDENDBITERR</name>
              <description>0: No Error
1: End Bit Error Generated
Occurs when detecting that the end bit of a command response is
0.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMDCRCERR</name>
              <description>0: No Error
1: CRC Error Generated
Command CRC Error is generated in two cases.
a. If a response is returned and the Command Time-out Error is
set to 0, this bit is set to 1 when detecting a CRT error in the
command response
b. The HC detects a CMD line conflict by monitoring the CMD line
when a command is issued. If the HC drives the CMD line to 1
level, but detects 0 level on the CMD line at the next SDCLK
edge, then the HC shall abort the command (Stop driving CMD
line) and set this bit to 1. The Command Timeout Error shall also
be set to 1 to distinguish CMD line conflict.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>CMDTIMEOUTERR</name>
              <description>0: No Error
1: Timeout
Occurs only if the no response is returned within 64 SDCLK cycles
from the end bit of the command. If the HC detects a CMD line
conflict, in which case Command CRC Error shall also be set. This
bit shall be set without waiting for 64 SDCLK cycles because the
command will be aborted by the HC.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
          </fields>
        </register>
        <register>
          <name>EMMCCORE_NORINTSTSENA</name>
          <description>Normal interrupt status enable register</description>
          <addressOffset>0x34</addressOffset>
          <size>16</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>BOOTTERMINATEINTERRUPT</name>
              <description>0: Masked
1: Enabled</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BOOTACKRCV</name>
              <description>0: Masked
1: Enabled</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RETUNINGEVENT</name>
              <description>0: Masked
1: Enabled</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CARDINTERRUPT</name>
              <description>0: Masked
1: Enabled</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CARDREMOVAL</name>
              <description>0: Masked
1: Enabled</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CARDINSERTION</name>
              <description>0: Masked
1: Enabled</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUFFERREADREADY</name>
              <description>0: Masked
1: Enabled</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUFFERWRITEREADY</name>
              <description>0: Masked
1: Enabled</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DMAINTERRUPT</name>
              <description>0: Masked
1: Enabled</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKGAPEVENT</name>
              <description>0: Masked
1: Enabled</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TRANSFERCOMPLETE</name>
              <description>0: Masked
1: Enabled</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMMANDCOMPLETE</name>
              <description>0: Masked
1: Enabled</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EMMCCORE_ERRINTSTSENA</name>
          <description>Error interrupt status enable register</description>
          <addressOffset>0x36</addressOffset>
          <size>16</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>TARGETRESPERR</name>
              <description>0: Masked
1: Enabled</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADMAERR</name>
              <description>0: Masked
1: Enabled</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTOCMDERR</name>
              <description>0: Masked
1: Enabled</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CURRENTLIMITERR</name>
              <description>0: Masked
1: Enabled</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATAENDBITERR</name>
              <description>0: Masked
1: Enabled</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATACRCERR</name>
              <description>0: Masked
1: Enabled</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATATIMEOUTERR</name>
              <description>0: Masked
1: Enabled</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMDINDEXERR</name>
              <description>0: Masked
1: Enabled</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMDENDBITERR</name>
              <description>0: Masked
1: Enabled</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMDCRCERR</name>
              <description>0: Masked
1: Enabled</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMDTIMEOUTERR</name>
              <description>0: Masked
1: Enabled</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EMMCCORE_NORINTSIGENA</name>
          <description>Normal interrupt signal enable register</description>
          <addressOffset>0x38</addressOffset>
          <size>16</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>BOOTTERMINATEINTERRUPT</name>
              <description>0: Masked
1: Enabled</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BOOTACKRCV</name>
              <description>0: Masked
1: Enabled</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RETUNINGEVENT</name>
              <description>0: Masked
1: Enabled</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CARDINTERRUPT</name>
              <description>0: Masked
1: Enabled</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CARDREMOVAL</name>
              <description>0: Masked
1: Enabled</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CARDINSERTION</name>
              <description>0: Masked
1: Enabled</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUFFERREADREADY</name>
              <description>0: Masked
1: Enabled</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUFFERWRITEREADY</name>
              <description>0: Masked
1: Enabled</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DMAINTERRUPT</name>
              <description>0: Masked
1: Enabled</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKGAPEVENT</name>
              <description>0: Masked
1: Enabled</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TRANSFERCOMPLETE</name>
              <description>0: Masked
1: Enabled</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMMANDCOMPLETE</name>
              <description>0: Masked
1: Enabled</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EMMCCORE_ERRINTSIGENA</name>
          <description>Error interrupt signal enable register</description>
          <addressOffset>0x3a</addressOffset>
          <size>16</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>TARGETRESPERR</name>
              <description>0: Masked
1: Enabled</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADMAERR</name>
              <description>0: Masked
1: Enabled</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTOCMDERR</name>
              <description>0: Masked
1: Enabled</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CURRENTLIMITERR</name>
              <description>0: Masked
1: Enabled</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATAENDBITERR</name>
              <description>0: Masked
1: Enabled</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATACRCERR</name>
              <description>0: Masked
1: Enabled</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATATIMEOUTERR</name>
              <description>0: Masked
1: Enabled</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMDINDEXERR</name>
              <description>0: Masked
1: Enabled</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMDENDBITERR</name>
              <description>0: Masked
1: Enabled</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMDCRCERR</name>
              <description>0: Masked
1: Enabled</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMDTIMEOUTERR</name>
              <description>0: Masked
1: Enabled</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EMMCCORE_ACMDERRSTS</name>
          <description>Auto CMD error status register</description>
          <addressOffset>0x3c</addressOffset>
          <size>16</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>CMDNOTISSBYACMD12ERR</name>
              <description>Command Not Issued By Auto CMD12 Error.
Setting this bit to 1 means CMD_wo_DAT is not executed due to
an Auto CMD12 error (D04 - D01) in this register.
This bit is set to 0 when Auto CMD Error is generated by Auto
CMD23.
0: No Error
1: Not Issued</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ACMDINDEXERR</name>
              <description>Auto CMD Index Error.
Occurs if the Command Index error occurs in response to a
command.
0: No Error
1: Error</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ACMDENDBITERR</name>
              <description>Auto CMD End Bit Error.
Occurs when detecting that the end bit of command response is
0.
0: No Error
1: End Bit Error Generated</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ACMDCRCERR</name>
              <description>Auto CMD CRC Error
Occurs when detecting a CRC error in the command response.
0: No Error
1: CRC Error Generated</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ACMDTIMEOUTERR</name>
              <description>Auto CMD Timeout Error
Occurs if the no response is returned within 64 SDCLK cycles
from the end bit of the command.
If this bit is set to 1, the other error status bits (D04 - D02) are
meaningless.
0: No Error
1: Timeout</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ACMD12NOTEXE</name>
              <description>Auto CMD12 not Executed
If memory multiple block data transfer is not started due to
command error, this bit is not set because it is not necessary to
issue Auto CMD12. Setting this bit to 1 means the HC cannot
issue Auto CMD12 to stop memory multiple block transfer due to
some
error. If this bit isset to 1, other error status bits (D04 - D01) are
meaningless.
This bit is set to 0 when Auto CMD Error is generated by Auto
CMD23.
0: Executed
1: Not Executed</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EMMCCORE_HOSTCTRL2</name>
          <description>Host Control 2 Register</description>
          <addressOffset>0x3e</addressOffset>
          <size>16</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>PRESETVALUEENABLE</name>
              <description>1: Automatic Selection by Preset Value are Enabled
0: SDCLK and Driver Strength are controlled by Host Driver
As the operating SDCLK frequency and I/O driver strength
depend on the Host System implementation, it is difficult to
determine these parameters in the Standard Host Driver. When
Preset Value Enable is set to automatic. This bit enablesthe
functions defined in the Preset Value registers.
If this bit is set to 0, SDCLK Frequency Select, Clock Generator
Select in the Clock Control register and Driver Strength Select in
Host Control 2 register are set by Host Driver.
If this bit is set to 1, SDCLK Frequency Select, Clock Generator
Select in the Clock Control register and Driver Strength Select in
Host Control 2 register are set by Host Controller as specified in
the Preset Value registers.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ASYNINTEN</name>
              <description>Asynchronous Interrupt Enable
This bit can be set to 1 if a card support asynchronous interrupt
and Asynchronous Interrupt Support is set to 1 in the Capabilities
register. Asynchronous interrupt is effective when DAT[1]
interrupt is used in 4-bit SD mode(and zero is set to Interrupt Pin
Select in the Shared Bus Control register). If this bit is set to 1,
the Host Driver can stop the SDCLK during asynchronous
interrupt period to save power. During this period, the Host
Controller continues to deliver CardInterrupt to the host when it
is asserted by the card.
1: Enabled
0: Disabled</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLINGCLOCKSELECT</name>
              <description>Sampling Clock Select
This bit is set by tuning procedure when Execute Tuning is
cleared. Writing 1 to this bit is meaningless and ignored. Setting
1 means that tuning is completed successfully and setting 0
means that tuning is failed. Host Controller uses this bit to select
sampling clock to receive CMD and DAT. This bit is cleared by
writing 0. Change of this bit is not allowed while the Host
Controller is receiving response or a read data block.
1: Tuned clock is used to sample data
0: Fixed clock is used to sample data</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EXECUTETUNING</name>
              <description>This bit is set to 1 to start tuning procedure and automatically
cleared when tuning procedure is completed. The result of tuning
is indicated to Sampling Clock Select. Tuning procedure is
aborted by writing 0 for more detail about tuning procedure.
1: Execute Tuning
0: Not Tuned or Tuning Completed</description>
              <bitRange>[6:6]</bitRange>
              <access>write-only</access>
              <modifiedWriteValues>clear</modifiedWriteValues>
            </field>
            <field>
              <name>UHSMODESELECT</name>
              <description>UHS Mode Select.
This field is used to select one of UHS-I modes and effective
when 1.8V Signaling Enable is set to 1.
If Preset Value Enable in the Host Control 2 register is set to 1,
Host Controller sets SDCLK Frequency Select, Clock Generator
Select in the Clock Control register and Driver Strength Select
according to Preset Value registers. In this case, one of preset
value registers is selected by this field. Host Driver needs to reset
SD Clock Enable before changing this field to avoid generating
clock glitch. After setting this field, Host Driver sets SD Clock
Enable again.
3'h0: SDR12
3'h1: SDR25
3'h2: SDR50
3'h3: SDR104
3'h4: DDR50
3'h5: HS400
others: Reserved
When SDR50, SDR104 or DDR50 is selected for SDIO card,
interrupt detection at the block gap shall not be used. Read Wait
timing is changed for these modes. Refer to the SDIO
Specification Version 3.00 for more detail.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EMMCCORE_FEACMD</name>
          <description>Force event register for Auto CMD error status</description>
          <addressOffset>0x50</addressOffset>
          <size>16</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>CMDERR</name>
              <description>Force Event for command not issued by Auto CMD12 Error
1: Interrupt is generated
0: No interrupt</description>
              <bitRange>[7:7]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>INDEXERR</name>
              <description>Force Event for Auto CMD Index Error
1: Interrupt is generated
0: No interrupt</description>
              <bitRange>[4:4]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>ENDERR</name>
              <description>Force Event for Auto CMD End bit Error
1: Interrupt is generated
0: No interrupt</description>
              <bitRange>[3:3]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CRCERR</name>
              <description>Force Event for Auto CMD CRC Error
1: Interrupt is generated
0: No interrupt</description>
              <bitRange>[2:2]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>TIMEOUTERR</name>
              <description>Force Event for Auto CMD timeout Error
1: Interrupt is generated
0: No interrupt</description>
              <bitRange>[1:1]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>NOTEXE</name>
              <description>Force Event for Auto CMD12 NOT Executed
1: Interrupt is generated
0: No interrupt</description>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EMMCCORE_FEERRINT</name>
          <description>Force event register for error interrupt status</description>
          <addressOffset>0x52</addressOffset>
          <size>16</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>VENDORERR</name>
              <description>Force Event for Vendor Specific Error Status</description>
              <bitRange>[15:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ADMAERR</name>
              <description>Force Event for ADMA Error
1: Interrupt is generated
0: No interrupt</description>
              <bitRange>[9:9]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>ACMDERR</name>
              <description>Force Event for Auto CMD Error
1: Interrupt is generated
0: No interrupt</description>
              <bitRange>[8:8]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CURRENTERR</name>
              <description>Force Event for Current Limit Error
1: Interrupt is generated
0: No interrupt</description>
              <bitRange>[7:7]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DATENDBITERR</name>
              <description>Force Event for Data End Bit Error
1: Interrupt is generated
0: No interrupt</description>
              <bitRange>[6:6]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DATCRCERR</name>
              <description>Force Event for Data CRC Error
1: Interrupt is generated
0: No interrupt</description>
              <bitRange>[5:5]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DATTIMEOUTERR</name>
              <description>Force Event for Data Timeout Error
1: Interrupt is generated
0: No interrupt</description>
              <bitRange>[4:4]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CMDINDEXERR</name>
              <description>Force Event for Command Index Error
1: Interrupt is generated
0: No interrupt</description>
              <bitRange>[3:3]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CMDENDBITERR</name>
              <description>Force Event for Command End Bit Error
1: Interrupt is generated
0: No interrupt</description>
              <bitRange>[2:2]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CMDCRCERR</name>
              <description>Force Event for Command CRC Error
1: Interrupt is generated
0: No interrupt</description>
              <bitRange>[1:1]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CMDTIMEOUTERR</name>
              <description>Force Event for Command Timeout Error
1: Interrupt is generated
0: No interrupt</description>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EMMCCORE_ADMAERRSTS</name>
          <description>ADMA error status register</description>
          <addressOffset>0x54</addressOffset>
          <size>16</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>LENMISMATCH</name>
              <description>ADMA Length Mismatch Error.
While Block Count Enable being set, the total data length
specified by the Descriptor table is different from that specified
by the Block Count and Block Length. Total data length can not
be divided by the block length.
1: Error
0: No error</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ADMAERRORSTATE</name>
              <description>This field indicates the state of ADMA when error is occurred
during ADMA data transfer. This field never indicates "10"
because ADMA never stops in this state.
0: ST_STOP (Stop DMA) Points to next of the error descriptor
1: ST_FDS (Fetch Descriptor) Points to the error descriptor
2: Never set this state (Not used)
3: ST_TFR (Transfer Data) Points to the next of the error
descriptor</description>
              <bitRange>[1:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EMMCCORE_PVALINIT</name>
          <description>Preset value register for Initialization</description>
          <addressOffset>0x60</addressOffset>
          <size>16</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>CLOCKGENERATORSELECTVALUE</name>
              <description>This bit is effective when Host Controller supports programmable
clockgenerator.
1: Programmable Clock Generator
0: Host Controller Ver2.00 Compatible Clock Generator</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SDCLKFREQUENCYSELECTVALUE</name>
              <description>10-bit preset value to set SDCLK Frequency Select in the Clock
Control Register is described by a host system.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EMMCCORE_PVALDS</name>
          <description>Preset value register for Default Speed</description>
          <addressOffset>0x62</addressOffset>
          <size>16</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>CLOCKGENERATORSELECTVALUE</name>
              <description>This bit is effective when Host Controller supports programmable
clockgenerator.
1: Programmable Clock Generator
0: Host Controller Ver2.00 Compatible Clock Generator</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SDCLKFREQUENCYSELECTVALUE</name>
              <description>10-bit preset value to set SDCLK Frequency Select in the Clock
Control Register is described by a host system.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EMMCCORE_PVALHS</name>
          <description>Preset value register for High Speed</description>
          <addressOffset>0x64</addressOffset>
          <size>16</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>CLOCKGENERATORSELECTVALUE</name>
              <description>This bit is effective when Host Controller supports programmable
clockgenerator.
1: Programmable Clock Generator
0: Host Controller Ver2.00 Compatible Clock Generator</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SDCLKFREQUENCYSELECTVALUE</name>
              <description>10-bit preset value to set SDCLK Frequency Select in the Clock
Control Register is described by a host system.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EMMCCORE_PVALSDR12</name>
          <description>Preset value register for SDR12</description>
          <addressOffset>0x66</addressOffset>
          <size>16</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>CLOCKGENERATORSELECTVALUE</name>
              <description>This bit is effective when Host Controller supports programmable
clockgenerator.
1: Programmable Clock Generator
0: Host Controller Ver2.00 Compatible Clock Generator</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SDCLKFREQUENCYSELECTVALUE</name>
              <description>10-bit preset value to set SDCLK Frequency Select in the Clock
Control Register is described by a host system.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EMMCCORE_PVALSDR25</name>
          <description>Preset value register for SDR25</description>
          <addressOffset>0x68</addressOffset>
          <size>16</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>CLOCKGENERATORSELECTVALUE</name>
              <description>This bit is effective when Host Controller supports programmable
clockgenerator.
1: Programmable Clock Generator
0: Host Controller Ver2.00 Compatible Clock Generator</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SDCLKFREQUENCYSELECTVALUE</name>
              <description>10-bit preset value to set SDCLK Frequency Select in the Clock
Control Register is described by a host system.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EMMCCORE_PVALSDR50</name>
          <description>Preset value register for SDR50</description>
          <addressOffset>0x6a</addressOffset>
          <size>16</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>CLOCKGENERATORSELECTVALUE</name>
              <description>This bit is effective when Host Controller supports programmable
clockgenerator.
1: Programmable Clock Generator
0: Host Controller Ver2.00 Compatible Clock Generator</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SDCLKFREQUENCYSELECTVALUE</name>
              <description>10-bit preset value to set SDCLK Frequency Select in the Clock
Control Register is described by a host system.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EMMCCORE_PVALSDR104</name>
          <description>Preset value register for SDR104</description>
          <addressOffset>0x6c</addressOffset>
          <size>16</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>CLOCKGENERATORSELECTVALUE</name>
              <description>This bit is effective when Host Controller supports programmable
clockgenerator.
1: Programmable Clock Generator
0: Host Controller Ver2.00 Compatible Clock Generator</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SDCLKFREQUENCYSELECTVALUE</name>
              <description>10-bit preset value to set SDCLK Frequency Select in the Clock
Control Register is described by a host system.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EMMCCORE_PVALDDR50</name>
          <description>Preset value register for DDR50</description>
          <addressOffset>0x6e</addressOffset>
          <size>16</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>CLOCKGENERATORSELECTVALUE</name>
              <description>This bit is effective when Host Controller supports programmable
clockgenerator.
1: Programmable Clock Generator
0: Host Controller Ver2.00 Compatible Clock Generator</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SDCLKFREQUENCYSELECTVALUE</name>
              <description>10-bit preset value to set SDCLK Frequency Select in the Clock
Control Register is described by a host system.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EMMCCORE_BOOTTIMEOUT</name>
          <description>Boot timeout control register</description>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BOOTTIMEOUT</name>
              <description>Boot Data Timeout Counter Value
This value determines the interval by which DAT line time-outs
are detected during boot operation for eMMC card.
The value is in number of sd clock.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EMMCCORE_PVALHS400</name>
          <description>Preset value register for HS400</description>
          <addressOffset>0x74</addressOffset>
          <size>16</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>DRIVERSTRENGTHSELECTVALUE</name>
              <description>Driver Strength is supported by 1.8V signaling bus speed modes.
This field is meaningless for 3.3V signaling.
2'b11: Driver Type D is Selected
2'b10: Driver Type C is Selected
2'b01: Driver Type A is Selected
2'b00: Driver Type B is Selected</description>
              <bitRange>[15:14]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CLOCKGENERATORSELECTVALUE</name>
              <description>This bit is effective when Host Controller supports programmable
clockgenerator.
1: Programmable Clock Generator
0: Host Controller Ver2.00 Compatible Clock Generator</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SDCLKFREQUENCYSELECTVALUE</name>
              <description>10-bit preset value to set SDCLK Frequency Select in the Clock
Control Register is described by a host system.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EMMCCORE_VENDOR</name>
          <description>Vendor register</description>
          <addressOffset>0x78</addressOffset>
          <size>16</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>ENHANCEDSTROBE</name>
              <description>This bit enables the enhanced strobe logic of the Host Controller</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EMMCCORE_SLOTINTSTS</name>
          <description>Slot interrupt status register</description>
          <addressOffset>0xfc</addressOffset>
          <size>16</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>INTSLOT0</name>
              <description>This status bit indicates the OR of Interrupt signal and Wakeup
signal for slot</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EMMCCORE_VERSION</name>
          <description>Host controller version register</description>
          <addressOffset>0xfe</addressOffset>
          <size>16</size>
          <resetValue>0x1002</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>VENDORVERSION</name>
              <description>The Vendor Version Number is set to 0x10 (1.0)</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPECIFICATIONVERSION</name>
              <description>The Host Controller Version Number is set to 0x02 (SD Host
Specification Version 3.00).</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EMMCCORE_CQVER</name>
          <description>Command queueing version register</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <resetValue>0x510</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MAJOR</name>
              <description>eMMC Major Version Number (digit left of decimal point), in BCD
format</description>
              <bitRange>[11:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MINOR</name>
              <description>eMMC Minor Version Number(digit right of decimal point), in BCD
format</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SUFFIX</name>
              <description>eMMC Version Suffix (2nd digit right of decimal point), in BCD
format</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EMMCCORE_CQCAP</name>
          <description>Command queueing capabilities register</description>
          <addressOffset>0x204</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ITCFMUL</name>
              <description>nternal Timer Clock Frequency Multiplier
ITCFMUL and ITCFVAL indicate the frequency of the clock used
for interrupt coalescing timer and for determining the SQS polling
period. See ITCFVAL definition for details.
4'h0: 0.001 MHz
4'h1: 0.01 MHz
4'h2: 0.1 MHz
4'h3: 1 MHz
4'h4: 10 MHz
Other values are reserved</description>
              <bitRange>[15:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ITCFVAL</name>
              <description>Internal Timer Clock Frequency Value
TCFMUL and ITCFVAL indicate the frequency of the clock used for
interrupt coalescing timer and for determining the polling period
when using periodic SEND_QUEUE_ STATUS (CMD13) polling.
The clock frequency is calculated as ITCFVAL* ITCFMUL.
For example, to encode 19.2 MHz, ITCFVAL shall be C0h (= 192
decimal) and ITCFMUL shall be 2h (0.1 MHz)
192 * 0.1 MHz=19.2 MHz</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EMMCCORE_CQCFG</name>
          <description>Command queueing configuration register</description>
          <addressOffset>0x208</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DCMDENA</name>
              <description>Direct Command (DCMD) Enable
This bit indicates to the hardware whether the Task Descriptor in
slot #31 of the TDL is a Data Transfer Task Descriptor, or a
Direct Command Task Descriptor.
CQE uses this bit when a task is issued in slot #31, to determine
how to decode the Task Descriptor.
1: Task descriptor in slot #31 is a DCMD Task Descriptor
0: Task descriptor in slot #31 is a Data Transfer Task Descriptor</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TASKDESCRIPTORSIZE</name>
              <description>This bit indicates whether the task descriptor size is 128 bits or
64 bits as detailed in Data Structures section. This bit can only be
configured when Command Queueing Enable bit is 0 (command
queueing is disabled)
1: Task descriptor size is 128 bits
0: Task descriptor size is 64 bits</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CQENA</name>
              <description>Command Queueing Enable
Software shall write 1 this bit when in order to enable command
queueing mode (i.e. enable CQE).
When this bit is 0, CQE is disabled and software controls the
eMMC bus using the legacy eMMC host controller.
Before software writes 1 to this bit, software shall verify that the
eMMC host controller is in idle state and there are no commands
or data transfers ongoing.
When software wants to exit command queueing mode, it shall
clear all previous tasks if such exist before setting this bit to 0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EMMCCORE_CQCTRL</name>
          <description>Command queueing controlregister/Command queueing control register</description>
          <addressOffset>0x20c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLEARALLTASKS</name>
              <description>Software shall write 1 this bit when it wants to clear all the tasks
sent to the device.
This bit can only be written when CQE is in halt state (i.e. Halt bit
is 1).
When software writes 1, the value of the register is updated to 1,
and CQE shall reset CQTDBR register and all other context
information for all unfinished tasks.
Then CQE will clear this bit.
Software should poll on this bit until it is set to back 0 and may
then resume normal operation, by clearing the Halt bit.
CQE does not communicate to the device that the tasks were
cleared. It is software's responsibility to order the device to
discard the tasks in its queue using CMDQ_TASK_MGMT
command.
Writing 0 to this register shall have no effect.</description>
              <bitRange>[8:8]</bitRange>
              <access>write-only</access>
              <modifiedWriteValues>clear</modifiedWriteValues>
            </field>
            <field>
              <name>HALT</name>
              <description>Host software shall write 1 to the bit when it wants to acquire
software control over the eMMC bus and disable CQE from issuing
commands on the bus.
For example, issuing a Discard Task command
(CMDQ_TASK_MGMT).
When software writes 1, CQE shall complete the ongoing task if
such a task is in progress.
Once the task is completed and CQE is in idle state, CQE shall not
issue new commands and shall indicate so to software by setting
this bit to 1.
Software may poll on this bit until it is set to 1, and may only
then send commands on the eMMC bus.
In order to exit halt state (i.e. resume CQE activity), software
shall clear this bit (write 0). Writing 0 when the value is already 0
shall have no effect.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EMMCCORE_CQINTSTS</name>
          <description>Command queueing interruptstatus register/Command queueing interrupt status register</description>
          <addressOffset>0x210</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TERR</name>
              <description>Task Error Interrupt
This bit is asserted when task error is detected due to invalid task
descriptor</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>TCL</name>
              <description>Task Cleared
This status bit is asserted (if CQISTE.TCL=1) when a task clear
operation is completed by CQE. The completed task clear
operation is either an individual task clear (CQTCLR) or clearing
of all tasks (CQCTL).</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>RED</name>
              <description>Response Error Detected Interrupt
This status bit is asserted (if CQISTE.RED=1) when a response is
received with an error bit set in the device status field.
Software uses CQRMEM register to configure which device status
bit fields may trigger an interrupt, and which are masked.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>TCC</name>
              <description>Task Complete Interrupt
This status bit is asserted(if CQISTE.TCC=1) when at least one of
the following two conditions are met:
a. A task is completed and the INT bit is set in its Task Descriptor
b. Interrupt caused by Interrupt Coalescing logic</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>HAC</name>
              <description>Halt Complete Interrupt
This status bit is asserted (if CQISTE.HAC=1) when halt bit in
CQCTL register transitions from 0 to 1 indicating that host
controller has completed its current ongoing task and has entered
halt state.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
          </fields>
        </register>
        <register>
          <name>EMMCCORE_CQINTSTSENA</name>
          <description>Command queueing interruptstatus enable register/Command queueing interrupt status enable register</description>
          <addressOffset>0x214</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TERR</name>
              <description>Task Error Interrupt
1: enable
0: disable</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TCL</name>
              <description>Task Cleared
1: enable
0: disable</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RED</name>
              <description>Response Error Detected Interrupt
1: enable
0: disable</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TCC</name>
              <description>Task Complete Interrupt
1: enable
0: disable</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HAC</name>
              <description>Halt Complete Interrupt
1: enable
0: disable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EMMCCORE_CQINTSIGENA</name>
          <description>Command queueing interruptsignal enable register/Command queueing interrupt signal enable register</description>
          <addressOffset>0x218</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TERR</name>
              <description>Task Error Interrupt
1: enable
0: disable</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TCL</name>
              <description>Task Cleared
1: enable
0: disable</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RED</name>
              <description>Response Error Detected Interrupt
1: enable
0: disable</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TCC</name>
              <description>Task Complete Interrupt
1: enable
0: disable</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HAC</name>
              <description>Halt Complete Interrupt
1: enable
0: disable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EMMCCORE_CQINTCOAL</name>
          <description>Command queueing interruptcoalescing register/Command queueing interrupt coalescing register</description>
          <addressOffset>0x21c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INTCOALENA</name>
              <description>Interrupt Coalescing Enable/Disable:
When set to 0 by software, command responses are neither
counted nor timed. Interrupts are still triggered by completion of
tasks with INT=1 in the Task Descriptor.
When set to 1, the interrupt coalescing mechanism is enabled
and coalesced interrupts are generated.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ICSB</name>
              <description>Interrupt Coalescing Status Bit :
This bit indicates to software whether any tasks (with INT=0)
have completed and counted towards interrupt coalescing (i.e.,
ICSB is set ifand only if IC counter &gt; 0).
1: At least one task completion has been counted (IC counter &gt;0)
0: No task completions have occurred since last counter reset (IC
counter =0)</description>
              <bitRange>[20:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RESET</name>
              <description>Counter and Timer Reset(ICCTR):
When host driver writes 1, the interrupt coalescing timer and
counter are reset</description>
              <bitRange>[16:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>ICCTHWEN</name>
              <description>Interrupt Coalescing Counter Threshold Write Enable:
When software writes 1, the value ICCTH is updated with the
contents written at the same cycle.
When software writes 0, the value in ICCTH is not updated.
NOTE: Write operations to ICCTH are only allowed when the task
queue is empty.</description>
              <bitRange>[15:15]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>ICCTH</name>
              <description>Interrupt Coalescing Counter Threshold (ICCTH):
Software uses this field to configure the number of task
completions (only tasks withINT=0 in the Task Descriptor) which
are required in order to generate an interrupt.
Counter Operation: As data transfer tasks with INT=0 complete,
they are counted byCQE. The counter is reset by software during
the interrupt service routine.
The counter stops counting when it reaches the value configured
in ICCTH.
The maximum allowed value is 31
NOTE : When ICCTH is 0, task completions are not counted, and
counting-based interrupts are not generated.
In order to write to this field, the ICCTHWEN bit must be set at
the same write operation.</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ICTOVALWEN</name>
              <description>Interrupt Coalescing Timeout Value Write Enable:
When software writes 1, the value ICTOVAL is updated with the
contents written at the same cycle.
When software writes 0, the value in ICTOVAL is not updated.
NOTE: Write operations to ICTOVAL are only allowed when the
task queue is empty.</description>
              <bitRange>[7:7]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>ICTOVAL</name>
              <description>Interrupt Coalescing Timeout Value (ICTOVAL):
Software uses this field to configure the maximum time allowed
between the completion of a task on the bus and the generation
of an interrupt.
Timer Operation: The timer is reset by software during the
interrupt service routine.
It starts running when a data transfer task with INT=0 is
completed, after the timer was reset. When the timer reaches the
value configured in ICTOVAL field it generates an interrupt and
stops.
The timer's unit is equal to 1024 clock periods of the clock whose
frequency is specified in the Internal Timer Clock Frequency field
CQCAP register.
The minimum value is 01h (1024 clock periods) and the
maximum value is 7Fh (127*1024 clock periods).
For example, a CQCAP field value of 0 indicates a 19.2 MHz clock
frequency (period = 52.08 ns). If the setting in ICTOVAL is 10h,
the calculated polling period is 16*1024*52.08 ns= 853.33 us.
NOTE:When ICTOVAL is 0, the timer is not running, and timer-
based interrupts are not generated.In order to write to this field,
the ICTOVALWEN bit must be set at the same write operation.</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EMMCCORE_CQTDLBA</name>
          <description>Command queueing task descriptor list base address register</description>
          <addressOffset>0x220</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TDLBA</name>
              <description>Task Descriptor List Base Address
This register stores the LSB bits (bits 31:0) of the byte address of
the head of the Task Descriptor List in system memory.
The size of the task descriptor list is 32 * (Task Descriptor size +
Transfer Descriptor size) as configured by Host driver.
This address shall be set on Byte1 KByte boundary. The lower 10
bits of this register shall be set to 0 by software and shall be
ignored by CQE.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EMMCCORE_CQTDLBAU</name>
          <description>Command queueing task descriptor list base address upper 32bits register</description>
          <addressOffset>0x224</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TDLBA</name>
              <description>Task Descriptor List Base Address
This register stores the MSB bits (bits 63:32) of the byte address
of the head of the Task Descriptor List in system memory.
The size of the task descriptor list is 32 * (Task Descriptor size +
Transfer Descriptor size) as configured by Host driver.
This register is reserved when using 32-bit addressing mode.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EMMCCORE_CQTDB</name>
          <description>Command queueing task doorbell register</description>
          <addressOffset>0x228</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TASKDOORBELL</name>
              <description>Command Queueing Task Doorbell
Software shall configure TDLBA and TDLBAU, and enable CQE in
CQCFG before using this register.
Writing 1 to bit n of this register triggers CQE to start processing
the task encoded in slot n of the TDL.
CQE always processes tasks in-order according to the order
submitted to the list by CQTDBR write transactions.
CQE processes Data Transfer tasks by reading the Task
Descriptor and sending QUEUED_TASK_PARAMS (CMD44) and
QUEUED_TASK_ADDRESS (CMD45) commands to the device.
CQE processes DCMD tasks (in slot #31, when enabled) by
reading the Task Descriptor, and generating the command
encoded by its index and argument.
The corresponding bit is cleared to 0 by CQE in one of the
following events:
a. When a task execution is completed (with success or error)
b. The task is cleared using CQTCLR register
c. All tasks are cleared using CQCTL register
d. CQE is disabled using CQCFG register
Software may initiate multiple tasks at the same time (batch
submission) by writing 1 to multiple bits of this register in the
same transaction.
In the case of batch submission:
CQE shall process the tasks in order of the task index, starting
with the lowest index.
If one or more tasks in the batch are marked with QBR, the
ordering of execution will be based on said processing order.
Writing 0 by software shall have no impact on the hardware, and
will not change the value of the register bit.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EMMCCORE_CQTDBN</name>
          <description>Command queueing task doorbell/Command queueing task doorbell notification register</description>
          <addressOffset>0x22c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TCN</name>
              <description>Task Complete Notification
CQE shall set bit n of this register (at the same time it clears bit n
of CQTDBR) when a task execution is completed (with success or
error).
When receiving interrupt for task completion, software may read
this register to know which tasks have finished.
After reading this register, software may clear the relevant bit
fields by writing 1 to the corresponding bits.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EMMCCORE_CQDQSTS</name>
          <description>Command queueing device queuestatus register/Command queueing device queue status register</description>
          <addressOffset>0x230</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DQS</name>
              <description>Device Queue Status
Every time the Host controller receives a queue status register
(QSR) from the device, it updates this register with the response
of status command, i.e. the device's queue status.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EMMCCORE_CQDPT</name>
          <description>Command queueing devicepending tasks register/Command queueing device pending tasks register</description>
          <addressOffset>0x234</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DPT</name>
              <description>Device Pending Tasks
Bit n of this register is set if and only if QUEUED_TASK_PARAMS
(CMD44) and QUEUED_TASK_ADDRESS (CMD45) were sent for
this specific task and if this task hasn&#8217;t been executed yet.
CQE shall set this bit after receiving a successful response for
CMD45. CQE shall clear this bit after the task has completed
execution.
Software needs to read this register in the task-discard
procedure, when the controlleris halted, to determine if the task
is queued in the device. If the task is queued, the driver sends a
CMDQ_TASK_MGMT (CMD48) to the device ordering it to discard
the task. Then software clears the task in the CQE. Only then the
software orders CQE to resume its operation using CQCTL
register.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EMMCCORE_CQTCLR</name>
          <description>Command queueing task clearregister/Command queueing task clear register</description>
          <addressOffset>0x238</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CQTC</name>
              <description>Command Queueing Task Clear
Writing 1 to bit n of this register orders CQE to clear a task which
software has previously issued.
This bit can only be written when CQE is in Halt state as indicated
in CQCFG register Halt bit.
When software writes 1 to a bit in this register, CQE updates the
value to 1, and starts clearing the data structures related to the
task. CQE clears the bit fields (sets a value of 0) in CQTCLR and
in CQTDBR once clear operation is complete.
Software should poll on the CQTCLR until it is cleared to verify
clear operation was complete.
Writing to this register only clears the task in the CQE and does
not have impact on the device. In order to discard the task in the
device, host softwareshall send CMDQ_TASK _MGMT while CQE is
still in Halt state.
Host driver is not allowed to use this register to clear multiple
tasks at the same time. Clearing multiple tasks can be done using
CQCTL register.
Writing 0 to a register bit shall have no impact.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EMMCCORE_CQSSC1</name>
          <description>Command queueing send statusconfiguration register 1/Command queueing send status configuration register 1</description>
          <addressOffset>0x240</addressOffset>
          <size>32</size>
          <resetValue>0x11000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SSCBC</name>
              <description>Send Status Command Block Counter
This field indicates to CQE when to send SEND_QUEUE_STATUS
(CMD13) command to inquire the status of the device's task
queue.
A value of n means CQE shall send status command on the CMD
line, during the transfer of data block BLOCK_CNT-n, on the data
lines, where BLOCK_CNT is the number of blocks inthe current
transaction.
A value of 0 means that SEND_QUEUE_STATUS (CMD13)
command shall not be sent during the transaction. Instead it will
be sentonly when the data lines are idle.
A value of 1 means that STATUS command is to be sent during
the last block of the transaction.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSCIT</name>
              <description>Send Status Command Idle Timer
This field indicates to CQE the polling period to use when using
periodic SEND_QUEUE_STATUS (CMD13) polling.
Periodic polling is used when tasks are pending in the device, but
no data transfer is in progress. When a SEND_QUEUE_STATUS
response indicating that no task is ready for execution, CQE
counts the configured time until it issues the next
SEND_QUEUE_STATUS.
Timer units are clock periods of the clock whose frequency is
specified in the Internal Timer Clock Frequency field CQCAP
egister.
The minimum value is 0001h (1 clock period) and the maximum
value is FFFFh (65535 clock periods). Default interval is: 4096
clock periods.
For example, a CQCAP field value of 0 indicates a 19.2 MHz clock
frequency (period = 52.08 ns). If the setting in CQSST is 1000h,
the calculated polling period is 4096*52.08 ns= 213.33 us.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EMMCCORE_CQSSC2</name>
          <description>Command queueing send statusconfiguration register 2/Command queueing send status configuration register 2</description>
          <addressOffset>0x244</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SQRCA</name>
              <description>Send Queue RCA
This field provides CQE with the contents of the 16-bit RCA field
in SEND_QUEUE_ STATUS (CMD13) command. argument.
CQE shall copy this field to bits 31:16 of the argument when
transmitting SEND_ QUEUE_STATUS (CMD13) command</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EMMCCORE_CQCRDT</name>
          <description>Command queueing command response for direct-command task register</description>
          <addressOffset>0x248</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DCLR</name>
              <description>Direct Command Last Response
This register contains the response of the command generated by
the last direct-command (DCMD) task which was sent.
CQE shall update this register when it receives the response for a
DCMD task.
This register is considered valid only after bit 31 of CQTDBR
register is cleared by CQE.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EMMCCORE_CQRMEM</name>
          <description>Command queueing responsemode error mask register/Command queueing response mode error mask register</description>
          <addressOffset>0x250</addressOffset>
          <size>32</size>
          <resetValue>0xfdf9a080</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RMEM</name>
              <description>Response Mode Error Mask
This bit is used as in interrupt mask on the device status filed
which is received in R1/R1b responses.
Bit Value Description (for any bit i):
1: When a R1/R1b response is received, with bit i in the device
status set, a RED interrupt is generated
0: When a R1/R1b response is received, bit i in the device status
is ignored
The reset value of this register is set to trigger an interrupt on all
'Error' type bits in the device status.
NOTE: Responses to CMD13 (SQS) encode the QSR, so they are
ignored by this logic.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EMMCCORE_CQTEI</name>
          <description>Command queueing task errorinformation register/Command queueing task error information register</description>
          <addressOffset>0x254</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DTECI</name>
              <description>Data Transfer Error Command Index
This field indicates the index of the command which was executed
on the data lines when an error occurred.
The index shall be set to EXECUTE_READ_TASK (CMD46) or
EXECUTE_WRITE_TASK (CMD47) according to the data direction.
The field is updated if a data transfer is in progress when an error
is detected by CQE, or indicated by eMMC controller.</description>
              <bitRange>[21:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RMEFV</name>
              <description>Response Mode Error Fields Valid
This bit is updated when an error is detected by CQE, or indicated
by eMMC controller.
If a command transaction is in progress when the error is
detected/indicated, the bit is set to 1.
If a no command transaction is in progress when the error is
detected/indicated, the bit is cleared to 0.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RMETID</name>
              <description>Response Mode Error Task ID
This field indicates the ID of the task which was executed on the
command line when an error occurred.
The field is updated if a command transaction is in progress when
an error is detected by CQE, or indicated by eMMC controller.</description>
              <bitRange>[12:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RMECI</name>
              <description>Response Mode Error Command Index
This field indicates the index of the command which was executed
on the command line when an error occurred.
The field is updated if a command transaction is in progress when
an error is detected by CQE, or indicated by eMMC controller.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EMMCCORE_CQCRI</name>
          <description>Command queueing commandresponse index register/Command queueing command response index register</description>
          <addressOffset>0x258</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LCRI</name>
              <description>Last Command Response Index
This field stores the index of the last received command
response. CQE shall update the value every time a command
response is received.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EMMCCORE_CQCRA</name>
          <description>Command queueing commandresponse argument register/Command queueing command response argument register</description>
          <addressOffset>0x25c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LCRA</name>
              <description>Last Command Response Argument
This field stores the argument of the last received command. CQE
shall update the value every time a command response is
received.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PMU</name>
      <version>1.0</version>
      <groupname>PMU</groupname>
      <baseAddress>0xff310000</baseAddress>
      <registers>
        <register>
          <name>PMU_WAKEUP_CFG0</name>
          <description>pmu wakeup configure register 0</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIO0D_POSEDGE_EN</name>
              <description>gpio0d posedge pulse wakeup enable
0: disable
1: enable</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO0C_POSEDGE_EN</name>
              <description>gpio0c posedge pulse wakeup enable
0: disable
1: enable</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO0B_POSEDGE_EN</name>
              <description>gpio0b posedge pulse wakeup enable
0: disable
1: enable</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO0A_POSEDGE_EN</name>
              <description>gpio0a posedge pulse wakeup enable
0: disable
1: enable</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_WAKEUP_CFG1</name>
          <description>pmu wakeup configure register 1</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIO0D_NEGEDGE_EN</name>
              <description>gpio0d negedge pulse wakeup enable
0: disable
1: enable</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO0C_NEGEDGE_EN</name>
              <description>gpio0c negedge pulse wakeup enable
0: disable
1: enable</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO0B_NEGEDGE_EN</name>
              <description>gpio0b negedge pulse wakeup enable
0: disable
1: enable</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO0A_NEGEDGE_EN</name>
              <description>gpio0a negedge pulse wakeup enable
0: disable
1: enable</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_WAKEUP_CFG2</name>
          <description>pmu wakeup configure register 2</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIO1D_POSEDGE_EN</name>
              <description>gpio1d posedge pulse wakeup enable
0: disable
1: enable</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO1C_POSEDGE_EN</name>
              <description>gpio1c posedge pulse wakeup enable
0: disable
1: enable</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO1B_POSEDGE_EN</name>
              <description>gpio1b posedge pulse wakeup enable
0: disable
1: enable</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO1A_POSEDGE_EN</name>
              <description>gpio1a posedge pulse wakeup enable
0: disable
1: enable</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_WAKEUP_CFG3</name>
          <description>pmu wakeup configure register 3</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIO1D_NEGEDGE_EN</name>
              <description>gpio1d negedge pulse wakeup enable
0: disable
1: enable</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO1C_NEGEDGE_EN</name>
              <description>gpio1c negedge pulse wakeup enable
0: disable
1: enable</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO1B_NEGEDGE_EN</name>
              <description>gpio1b negedge pulse wakeup enable
0: disable
1: enable</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO1A_NEGEDGE_EN</name>
              <description>gpio1a negedge pulse wakeup enable
0: disable
1: enable</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_WAKEUP_CFG4</name>
          <description>pmu wakeup configure register 4</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PCIE_EN</name>
              <description>pcie interrupt wakeup enable
0: disable
1: enable</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM_EN</name>
              <description>pwm interrupt wakeup enable
0: disable
1: enable</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMEOUT_EN</name>
              <description>pmu time out wakeup enable
0: disable
1: enable</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WDT_M0_EN</name>
              <description>m3 watch dog wakeup enable
0: disable
1: enable</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SFT_EN</name>
              <description>software wakeup enable
0: disable
1: enable</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>USBDEV_EN</name>
              <description>usb device detect wakeup enable
0: disable
1: enable</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMER_EN</name>
              <description>timer wakeup enable
0: disable
1: enable</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDMMC_EN</name>
              <description>sdmmc detect wakeup enable
0: disable
1: enable</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDIO_EN</name>
              <description>sdio detect wakeup enable
0: disable
1: enable</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO_INT_EN</name>
              <description>gpio interrupt wakeup enable
0: disable
1: enable</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT_CLUSTER_B_EN</name>
              <description>cluster_b interrupt wakeup enable
0: disable
1: enable</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT_CLUSTER_L_EN</name>
              <description>cluster_l interrupt wakeup enable
0: disable
1: enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_PWRDN_CON</name>
          <description>pmu power down configure register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PD_SDIOAUDIO_PWRDWN_EN</name>
              <description>pd_sdioaudio power down enable
0: disable
1: enable</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_SD_PWRDWN_EN</name>
              <description>pd_sd power down enable
0: disable
1: enable</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_GIC_PWRDWN_EN</name>
              <description>pd_gic power down enable
0: disable
1: enable</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_EDP_PWRDWN_EN</name>
              <description>pd_edp power down enable
0: disable
1: enable</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_USB3_PWRDWN_EN</name>
              <description>pd_usb3 power down enable
0: disable
1: enable</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_EMMC_PWRDWN_EN</name>
              <description>pd_emmc power down enable
0: disable
1: enable</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_GMAC_PWRDWN_EN</name>
              <description>pd_gmac power down enable
0: disable
1: enable</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_HDCP_PWRDWN_EN</name>
              <description>pd_hdcp power down enable
0: disable
1: enable</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_ISP1_PWRDWN_EN</name>
              <description>pd_isp1 power down enable
0: disable
1: enable</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_ISP0_PWRDWN_EN</name>
              <description>pd_isp0 power down enable
0: disable
1: enable</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_VO_PWRDWN_EN</name>
              <description>pd_vo power down enable
0: disable
1: enable</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_IEP_PWRDWN_EN</name>
              <description>pd_perihp power down enable
0: disable
1: enable</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_RGA_PWRDWN_EN</name>
              <description>pd_rga power down enable
0: disable
1: enable</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_VDU_PWRDWN_EN</name>
              <description>pd_vdu power down enable
0: disable
1: enable</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_VCODEC_PWRDWN_EN</name>
              <description>pd_perihp power down enable
0: disable
1: enable</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_GPU_PWRDWN_EN</name>
              <description>pd_gpu power down enable
0: disable
1: enable</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_VIO_PWRDWN_EN</name>
              <description>pd_vio power down enable
0: disable
1: enable</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_CENTER_PWRDWN_EN</name>
              <description>pd_center power down enable
0: disable
1: enable</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_PERIHP_PWRDWN_EN</name>
              <description>pd_perihp power down enable
0: disable
1: enable</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_PERILP_PWRDWN_EN</name>
              <description>pd_perilp power down enable
0: disable
1: enable</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_CCI_PWRDWN_EN</name>
              <description>pd_cci power down enable
0: disable
1: enable</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_TCPD1_PWRDWN_EN</name>
              <description>pd_tcpd1 power down enable
0: disable
1: enable</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_TCPD0_PWRDWN_EN</name>
              <description>pd_tcpd0 power down enable
0: disable
1: enable</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_SCU_B_PWRDWN_EN</name>
              <description>pd_scu_b power down enable
0: disable
1: enable</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_SCU_L_PWRDWN_EN</name>
              <description>pd_scu_l power down enable
0: disable
1: enable</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_A72_B1_PWRDWN_EN</name>
              <description>pd_a72_b0 power down enable
0: disable
1: enable</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_A72_B0_PWRDWN_EN</name>
              <description>pd_a72_b0 power down enable
0: disable
1: enable</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_A53_L3_PWRDWN</name>
              <description>pd_a53_l3 power down enable
0: disable
1: enable</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_A53_L2_PWRDWN</name>
              <description>pd_a53_l2 power down enable
0: disable
1: enable</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_A53_L1_PWRDWN</name>
              <description>pd_a53_l1 power down enable
0: disable
1: enable</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_A53_L0_PWRDWN_EN</name>
              <description>pd_a53_l0 power down enable
0: disable
1: enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_PWRDN_ST</name>
          <description>pmu power down status register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PD_SDIOAUDIO_PWR_STAT</name>
              <description>pd_sdioaudio power state
0: powered up
1: powered down</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_SD_PWR_STAT</name>
              <description>pd_sd power state
0: powered up
1: powered down</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_GIC_PWR_STAT</name>
              <description>pd_gic power state
0: powered up
1: powered down</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_EDP_PWR_STAT</name>
              <description>pd_edp power state
0: powered up
1: powered down</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_USB3_PWR_STAT</name>
              <description>pd_usb3 power state
0: powered up
1: powered down</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_EMMC_PWR_STAT</name>
              <description>pd_emmc power state
0: powered up
1: powered down</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_GMAC_PWR_STAT</name>
              <description>pd_gmac power state
0: powered up
1: powered down</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_HDCP_PWR_STAT</name>
              <description>pd_hdcp power state
0: powered up
1: powered down</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_ISP1_PWR_STAT</name>
              <description>pd_isp1 power state
0: powered up
1: powered down</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_ISP0_PWR_STAT</name>
              <description>pd_isp0 power state
0: powered up
1: powered down</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_VO_PWR_STAT</name>
              <description>pd_vo power state
0: powered up
1: powered down</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_IEP_PWR_STAT</name>
              <description>pd_iep power state
0: powered up
1: powered down</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_RGA_PWR_STAT</name>
              <description>pd_rga power state
0: powered up
1: powered down</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_VDU_PWR_STAT</name>
              <description>pd_vdu power state
0: powered up
1: powered down</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_VCODEC_PWR_STAT</name>
              <description>pd_vcodec power state
0: powered up
1: powered down</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_GPU_PWR_STAT</name>
              <description>pd_gpu power state
0: powered up
1: powered down</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_VIO_PWR_STAT</name>
              <description>pd_vio power state
0: powered up
1: powered down</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_CENTER_PWR_STAT</name>
              <description>pd_center power state
0: powered up
1: powered down</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_PERIHP_PWR_STAT</name>
              <description>pd_peri power state
0: powered up
1: powered down</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_PERILP_PWR_STAT</name>
              <description>pd_bus power stat
0: powered up
1: powered down</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_CCI_PWR_STAT</name>
              <description>pd_core power state
0: powered up
1: powered down</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_TCPD1_PWR_STAT</name>
              <description>pd_tcpd1 power state
0: powered up
1: powered down</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_TCPD0_PWR_STAT</name>
              <description>pd_tcpd0 power state
0: powered up
1: powered down</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_SCU_B_PWR_STAT</name>
              <description>pd_scu_b power state
0: powered up
1: powered down</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PD_SCU_L_PWR_STAT</name>
              <description>pd_scu_l power state
0: powered up
1: powered down</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PD_A72_B1_PWR_STAT</name>
              <description>pd_a72_b1 power state
0: powered up
1: powered down</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PD_A72_B0_PWR_STAT</name>
              <description>pd_a72_b0 power state
0: powered up
1: powered down</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PD_A53_L3_PWR_STAT</name>
              <description>pd_a53_l3 power state
0: powered up
1: powered down</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PD_A53_L2_PWR_STAT</name>
              <description>pd_a53_l2 power state
0: powered up
1: powered down</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PD_A53_L1_PWR_STAT</name>
              <description>pd_a53_l1 power state
0: powered up
1: powered down</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PD_A53_L0_PWR_STAT</name>
              <description>pd_a53_l0 power state
0: powered up
1: powered down</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_PLL_CON</name>
          <description>PLL low power control register</description>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SFT_PLL_PD</name>
              <description>pll power down configured by sftware.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PLL_PD_CFG</name>
              <description>pll power down configured by hardware</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_PWRMODE_CON</name>
          <description>pmu power mode configure register of common resource</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MAIN_CLUSTER</name>
              <description>use core big for main cluster.
0: core_l ;
1: core_b.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SLEEP_OUTPUT_CFG</name>
              <description>output pmu_sleep instead of ap_pwroff to IO.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DDRIO_RET_HW_DE_REQ</name>
              <description>hardware ddrio retention de-assert request</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_CORE_SRC_GATE_EN</name>
              <description>cpu clock gate enable when in power mode
0: disable
1: enable</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_PERILP_SRC_GATE_EN</name>
              <description>pd_perilp clock gate enable when in power mode
0: disable
1: enable</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_CENTER_SRC_GATE_EN</name>
              <description>pd_center clock gate enable when in power mode
0: disable
1: enable</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DDRIO1_RET_DE_REQ</name>
              <description>ddrio1 retention de-assert request
write one clear</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>DDRIO1_RET_EN</name>
              <description>ddrio1 retention enable when in power mode
0: disable
1: enable</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DDRC1_GATING_EN</name>
              <description>ddr1 controller auto gating when in power mode
0: disable
1: enable</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SREF1_ENTER_EN</name>
              <description>ddr1 self_refresh by hardware when in power mode
0: disable
1: enable</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DDRIO0_RET_DE_REQ</name>
              <description>ddrio0 retention de-assert request
write one clear</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>DDRIO0_RET_EN</name>
              <description>ddrio0 retention enable when in power mode
0: disable
1: enable</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DDRC0_GATING_EN</name>
              <description>ddr0 controller auto gating when in power mode
0: disable
1: enable</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SREF0_ENTER_EN</name>
              <description>ddr0 self_refresh by hardware when in power mode
0: disable
1: enable</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CENTER_PD_EN</name>
              <description>power down pd_center when power mode
0: disable
1: enable</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PERILP_PD_EN</name>
              <description>power down pd_perilp when power mode
0: disable
1: enable</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CCI_PD_EN</name>
              <description>power down pd_cci when power mode
0: disable
1: enable</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCU_PD_EN</name>
              <description>power down main cluster scu when in power mode
0: disable
1: enable</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>L2_IDLE_EN</name>
              <description>wait l2 idle when in power mode
0: disable
1: enable</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>L2_FLUSH_EN</name>
              <description>flush l2 by hardware when in power mode
0: disable
1: enable</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPU0_PD_EN</name>
              <description>power down core0 of cluster_l in power mode
0: disable
1: enable</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PLL_PD_EN</name>
              <description>power down pll when in power mode
0: disable
1: enable</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CHIP_PD_EN</name>
              <description>chip power down enable
0: disable
1: enable</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POWER_OFF_REQ_CFG</name>
              <description>send power off request to PMIC when in power mode
0: disable
1: enable</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMU_USE_LF</name>
              <description>pmu low frequency mode enable when in power mode
0: disable
1: enable</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALIVE_USE_LF</name>
              <description>alive low frequency mode when in power mode
0: disable
1: enable</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OSC_DISABLE</name>
              <description>osc disable when in power mode
1: disable
0: enable</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INPUT_CLAMP_EN</name>
              <description>clamp vd_logic when in power mode
0: disable
1: enable</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKEUP_RESET_EN</name>
              <description>wakeup reset enable when in power mode
0: disable
1: enable</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POWER_MODE_EN</name>
              <description>enter power mode enable, will auto self-clear when in power mode
0: disable
1: enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_SFT_CON</name>
          <description>pmu software configure register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ACINACTM_CLUSTER_B_CFG</name>
              <description>acinactm indicate to cluster_b
0: acinactm to cluster_b is 0
1: acinactm to cluster_b is 1</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>L2FLUSHREQ_CLUSTER_B</name>
              <description>send l2 flush request to cluster_l by software
0: disable
1: enable</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLUSTER_B_CLK_SRC_GATING_CFG</name>
              <description>cluster_b clock source gating configure
0: disable
1: enable</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DBGPWRUPREQ_B_EN</name>
              <description>dbg powered up request function of cluster_b enable
0: disable
1: enable</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DBGNOPWRDWN_B_ENABLE</name>
              <description>dbgnopowerdown function of cluster_b enable
0: disable
1: enable</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACINACTM_CLUSTER_L_CFG</name>
              <description>acinactm indicate to cluster_l
0: acinactm to cluster_l is 0
1: acinactm to cluster_l is 1</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>L2FLUSHREQ_CLUSTER_L</name>
              <description>send l2 flush request to cluster_l by software
0: disable
1: enable</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLUSTER_L_CLK_SRC_GATING_CFG</name>
              <description>cluster_l clock source gating configure
0: disable
1: enable</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DBGPWRUPREQ_L_EN</name>
              <description>dbg powered up request function of cluster_l enable
0: disable
1: enable</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DBGNOPWRDWN_L_ENABLE</name>
              <description>dbgnopowerdown function of cluster_l enable
0: disable
1: enable</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DBGPWRDUP_B0_CFG</name>
              <description>dbg powered up of pd_a72_b0 enable when in power mode
0: disable
1: enable</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DDR1_IO_RET_CFG</name>
              <description>ddr1 io retention configure by software
0: disable
1: enable</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DDRCTL1_C_SYSREQ_CFG</name>
              <description>ddrctl1 idle request configure
0: disable
1: enable</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DDR0_IO_RET_CFG</name>
              <description>ddr0 io retention configure by software
0: disable
1: enable</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DDRCTL0_C_SYSREQ_CFG</name>
              <description>ddrctl idle request configure
0: disable
1: enable</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKEUP_SFT_M0</name>
              <description>m0 configure this bit to wakeup PMU state machine.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DBGPWRDUP_L0_CFG</name>
              <description>dbg powered up of pd_a53_l0 enable when in power mode
0: disable
1: enable</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMU_24M_ENA_CFG</name>
              <description>configure PD_PMU use 24M clock</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALIVE_LF_ENA_CFG</name>
              <description>pd_alive low frequency mode configure by software
0: disable
1: enable</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMU_LF_ENA_CFG</name>
              <description>pd_pmu low frequency mode configure by software
0: disable
1: enable</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OSC_DISABLE_CFG</name>
              <description>osc disable configure by software
1: disable osc
0: enable psc</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INPUT_CLAMP_CFG</name>
              <description>software control of input clamp signal</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKEUP_SFT</name>
              <description>software wakeup request bit
A 0 to 1 pulse posedge will wakeup pmu when in low power mode</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_INT_CON</name>
          <description>pmu interrupt configure register</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WAKEUP_GPIO1_POS_INT_EN</name>
              <description>gpio1 posedge wakeup interrupt enable
0: disable
1: enable</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKEUP_GPIO1_NEG_INT_EN</name>
              <description>gpio1 negedge wakeup interrupt enable
0: disable
1: enable</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKEUP_GPIO0_POS_INT_EN</name>
              <description>gpio posedge wakeup interrupt enable
0: disable
1: enable</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKEUP_GPIO0_NEG_INT_EN</name>
              <description>gpio0 negedge wakeup interrupt enable
0: disable
1: enable</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PWRMODE_WAKEUP_INT_EN</name>
              <description>power mode wakeup interrupt enable
0: disable
1: enable</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMU_INT_EN</name>
              <description>global interrupt enable
0: disable
1: enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_INT_ST</name>
          <description>pmu interrupt status register</description>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WAKEUP_GPIO1_NEG_STATUS</name>
              <description>gpio1 negedge pulse wakeup status
0: not wakeup by gpio1 negedge pulse
1: wakeup by gpio1 negedge pulse</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKEUP_GPIO1_POS_STATUS</name>
              <description>gpio1 posedge pulse wakeup status
0: not wakeup by gpio1 posedge pulse
1: wakeup by gpio1 posedge pulse</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKEUP_GPIO0_POS_STATUS</name>
              <description>gpio0 posedge pulse wakeup status
0: not wakeup by gpio0 posedge pulse
1: wakeup by gpio0 posedge pulse</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKEUP_GPIO0_NEG_STATUS</name>
              <description>gpio0 negedge pulse wakeup status
0: not wakeup by gpio negedge pulse
1: wakeup by gpio negedge pulse</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PWRMODE_WAKEUP_STATUS</name>
              <description>power mode wakeup status
0: not wakeup from power mode
1: wakeup from power mode</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_GPIO0_POS_INT_CON</name>
          <description>pmu gpio0 posedge interrupt configure register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIO0D_POS_INT_EN</name>
              <description>gpio0d posedge pulse interrupt enable
0: disable
1: enable</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO0C_POS_INT_EN</name>
              <description>gpio0c posedge pulse interrupt enable
0: disable
1: enable</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO0B_POS_INT_EN</name>
              <description>gpio0b posedge pulse interrupt enable
0: disable
1: enable</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO0A_POS_INT_EN</name>
              <description>gpio0a posedge pulse interrupt enable
0: disable
1: enable</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_GPIO0_NEG_INT_CON</name>
          <description>pmu gpio0 negedge interrupt configure register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIO0D_NEG_INT_EN</name>
              <description>gpio0d negedge pulse interrupt enable
0: disable
1: enable</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO0C_NEG_INT_EN</name>
              <description>gpio0c negedge pulse interrupt enable
0: disable
1: enable</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO0B_NEG_INT_EN</name>
              <description>gpio0b negedge pulse interrupt enable
0: disable
1: enable</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO0A_NEG_INT_EN</name>
              <description>gpio0a negedge pulse interrupt enable
0: disable
1: enable</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_GPIO1_POS_INT_CON</name>
          <description>pmu gpio1 posedge interrupt configure register</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIO1D_POS_INT_EN</name>
              <description>gpio1d posedge pulse interrupt enable
0: disable
1: enable</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO1C_POS_INT_EN</name>
              <description>gpio1c posedge pulse interrupt enable
0: disable
1: enable</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO1B_POS_INT_EN</name>
              <description>gpio1b posedge pulse interrupt enable
0: disable
1: enable</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO1A_POS_INT_EN</name>
              <description>gpio1a posedge pulse interrupt enable
0: disable
1: enable</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_GPIO1_NEG_INT_CON</name>
          <description>pmu gpio1 negedge interrupt configure register</description>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIO1D_NEG_INT_EN</name>
              <description>gpio1d negedge pulse interrupt enable
0: disable
1: enable</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO1C_NEG_INT_EN</name>
              <description>gpio1c negedge pulse interrupt enable
0: disable
1: enable</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO1B_NEG_INT_EN</name>
              <description>gpio1b negedge pulse interrupt enable
0: disable
1: enable</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO1A_NEG_INT_EN</name>
              <description>gpio1a negedge pulse interrupt enable
0: disable
1: enable</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_GPIO0_POS_INT_ST</name>
          <description>pmu gpio0 posedge interrupt status register</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIO0D_POS_INT_STATUS</name>
              <description>gpio0d posedge pulse interrupt status
0: not wakeup by gpio0d posedge pulse
1: wakeup by gpio0d posedge pulse</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO0C_POS_INT_STATUS</name>
              <description>gpio0c posedge pulse interrupt status
0: not wakeup by gpio0c posedge pulse
1: wakeup by gpio0c posedge pulse</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO0B_POS_INT_STATUS</name>
              <description>gpio0b posedge pulse interrupt status
0: not wakeup by gpio0b posedge pulse
1: wakeup by gpio0b posedge pulse</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO0A_POS_INT_STATUS</name>
              <description>gpio0a posedge pulse interrupt status
0: not wakeup by gpio0a posedge pulse
1: wakeup by gpio0a posedge pulse</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_GPIO0_NEG_INT_ST</name>
          <description>pmu gpio0 negedge interrupt status register</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIO0D_NEG_INT_STATUS</name>
              <description>gpio0d negedge pulse interrupt status
0: not wakeup by gpio0d negedge pulse
1: wakeup by gpio0d negedge pulse</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO0C_NEG_INT_STATUS</name>
              <description>gpio0c negedge pulse interrupt status
0: not wakeup by gpio0c negedge pulse
1: wakeup by gpio0c negedge pulse</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO0B_NEG_INT_STATUS</name>
              <description>gpio0b negedge pulse interrupt status
0: not wakeup by gpio0b negedge pulse
1: wakeup by gpio0b negedge pulse</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO0A_NEG_INT_STATUS</name>
              <description>gpio0a negedge pulse interrupt status
0: not wakeup by gpio0a negedge pulse
1: wakeup by gpio0a negedge pulse</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_GPIO1_POS_INT_ST</name>
          <description>pmu gpio1 posedge interrupt status register</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIO1D_POS_INT_STATUS</name>
              <description>gpio1d posedge pulse interrupt status
0: not wakeup by gpio1d posedge pulse
1: wakeup by gpio1d posedge pulse</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO1C_POS_INT_STATUS</name>
              <description>gpio1c posedge pulse interrupt status
0: not wakeup by gpio1c posedge pulse
1: wakeup by gpio1c posedge pulse</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO1B_POS_INT_STATUS</name>
              <description>gpio1b posedge pulse interrupt status
0: not wakeup by gpio1b posedge pulse
1: wakeup by gpio1b posedge pulse</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO1A_POS_INT_STATUS</name>
              <description>gpio1a posedge pulse interrupt status
0: not wakeup by gpio1a posedge pulse
1: wakeup by gpio1a posedge pulse</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_GPIO1_NEG_INT_ST</name>
          <description>pmu gpio1 negedge interrupt status register</description>
          <addressOffset>0x4c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIO1D_NEG_INT_STATUS</name>
              <description>gpio1d negedge pulse interrupt status
0: not wakeup by gpio1d negedge pulse
1: wakeup by gpio1d negedge pulse</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO1C_NEG_INT_STATUS</name>
              <description>gpio1c negedge pulse interrupt status
0: not wakeup by gpio1c negedge pulse
1: wakeup by gpio1c negedge pulse</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO1B_NEG_INT_STATUS</name>
              <description>gpio1b negedge pulse interrupt status
0: not wakeup by gpio1b negedge pulse
1: wakeup by gpio1b negedge pulse</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO1A_NEG_INT_STATUS</name>
              <description>gpio1a negedge pulse interrupt status
0: not wakeup by gpio1a negedge pulse
1: wakeup by gpio1a negedge pulse</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_PWRDN_INTEN</name>
          <description>pmu power down interrupt enable register/pmu power down configure register</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PD_SDIOAUDIO_PWR_SWITCH_INT_EN</name>
              <description>pd_sdioaudio power switch interrupt enable
0: disable
1: enable</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_SD_PWR_SWITCH_INT_EN</name>
              <description>pd_sd power switch interrupt enable
0: disable
1: enable</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_GIC_PWR_SWITCH_INT_EN</name>
              <description>pd_gic power switch interrupt enable
0: disable
1: enable</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_EDP_PWR_SWITCH_INT_EN</name>
              <description>pd_edp power switch interrupt enable
0: disable
1: enable</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_USB3_PWR_SWITCH_INTERRUPT_EN</name>
              <description>pd_usb3 power switch interrupt enable
0: disable
1: enable</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_EMMC_PWR_SWITCH_INTERRUPT_EN</name>
              <description>pd_emmc power switch interrupt enable
0: disable
1: enable</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_GMAC_PWR_SWITCH_INT_EN</name>
              <description>pd_gmac power switch interrupt enable
0: disable
1: enable</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_HDCP_PWR_SWITCH_INT_EN</name>
              <description>pd_hdcp power    switch interrupt enable
0: disable
1: enable</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_ISP1_PWR_SWITCH_INT_EN</name>
              <description>pd_isp1 power switch interrupt enable
0: disable
1: enable</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_ISP0_PWR_SWITCH_INT_EN</name>
              <description>pd_isp0 power switch interrupt enable
0: disable
1: enable</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_VO_PWR_SWITCH_INT_EN</name>
              <description>pd_vo power switch interrupt enable
0: disable
1: enable</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_IEP_PWR_SWITCH_INT_EN</name>
              <description>pd_perihp power switch interrupt enable
0: disable
1: enable</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_RGA_PWR_SWITCH_INT_EN</name>
              <description>pd_rga power switch interrupt enable
0: disable
1: enable</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_VDU_PWR_SWITCH_INT_EN</name>
              <description>pd_vdu power switch interrupt enable
0: disable
1: enable</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_VCODEC_PWR_SWITCH_INTEN</name>
              <description>pd_perihp power switch interrupt enable
0: disable
1: enable</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_GPU_PWR_SWITCH_INT_EN</name>
              <description>pd_gpu power interrupt    enable
0: disable
1: enable</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_VIO_PWR_SWITCH_INT_EN</name>
              <description>pd_vio power switch interrupt enable
0: disable
1: enable</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_CENTER_PWR_SWITCH_INT_EN</name>
              <description>pd_center power switch interrupt enable
0: disable
1: enable</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_PERIHP_PWR_SWITCH_INT_EN</name>
              <description>pd_perihp power switch interrupt enable
0: disable
1: enable</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_PERILP_PWR_SWITCH_INT_EN</name>
              <description>pd_perilp power switch interrupt enable
0: disable
1: enable</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_CCI_PWR_SWITCH_INT_EN</name>
              <description>pd_cci power switch interrupt enable
0: disable
1: enable</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_TCPD1_PWR_SWITCH_INT_EN</name>
              <description>pd_tcpd1 power switch interrupt enable
0: disable
1: enable</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_TCPD0_PWR_SWITCH_INT_EN</name>
              <description>pd_tcpd0 power switch interrupt enable
0: disable
1: enable</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_SCU_B_PWR_SWITCH_INT_EN</name>
              <description>pd_scu_b power switch interrupt enable
0: disable
1: enable</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_SCU_L_PWR_SWITCH_INT_EN</name>
              <description>pd_scu_l power switch interrupt enable
0: disable
1: enable</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_A72_B1_PWR_SWITCH_INT_EN</name>
              <description>pd_a72_b1 power switch interrupt enable
0: disable
1: enable</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_A72_B0_PWR_SWITCH_INT_EN</name>
              <description>pd_a72_b0 power    enable
0: disable
1: enable</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_A53_L3_PWR_SWITCH_INT_EN</name>
              <description>pd_a53_l3 power switch int enable
0: disable
1: enable</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_A53_L2_PWR_SWITCH_INT_EN</name>
              <description>pd_a53_l2 power switch interrupt enable
0: disable
1: enable</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_A53_L1_PWR_SWITCH_INT_EN</name>
              <description>pd_a53_l1 power switch interrupt enable
0: disable
1: enable</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_A53_L0_PWR_SWITCH_INT_EN</name>
              <description>pd_a53_l0 power switch interrupt enable
0: disable
1: enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_PWRDN_STATUS</name>
          <description>pmu power down interrupt status register/pmu power down status register</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PD_SDIOAUDIO_PWR_STAT</name>
              <description>pd_sdioaudio power state
0: powered up
1: powered down</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>PD_SD_PWR_STAT</name>
              <description>pd_sd power state
0: powered up
1: powered down</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>PD_GIC_PWR_STAT</name>
              <description>pd_gic power state
0: powered up
1: powered down</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>PD_EDP_PWR_STAT</name>
              <description>pd_edp power state
0: powered up
1: powered down</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>PD_USB3_PWR_STAT</name>
              <description>pd_usb3 power state
0: powered up
1: powered down</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>PD_EMMC_PWR_STAT</name>
              <description>pd_emmc power state
0: powered up
1: powered down</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>PD_GMAC_PWR_STAT</name>
              <description>pd_gmac power state
0: powered up
1: powered down</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>PD_HDCP_PWR_STAT</name>
              <description>pd_hdcp power state
0: powered up
1: powered down</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>PD_ISP1_PWR_STAT</name>
              <description>pd_isp1 power state
0: powered up
1: powered down</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>PD_ISP0_PWR_STAT</name>
              <description>pd_isp0 power state
0: powered up
1: powered down</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>PD_VO_PWR_STAT</name>
              <description>pd_vo power state
0: powered up
1: powered down</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>PD_IEP_PWR_STAT</name>
              <description>pd_iep power state
0: powered up
1: powered down</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>PD_RGA_PWR_STAT</name>
              <description>pd_rga power state
0: powered up
1: powered down</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>PD_VDU_PWR_STAT</name>
              <description>pd_vdu power state
0: powered up
1: powered down</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>PD_VCODEC_PWR_STAT</name>
              <description>pd_vcodec power state
0: powered up
1: powered down</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>PD_GPU_PWR_STAT</name>
              <description>pd_gpu power state
0: powered up
1: powered down</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>PD_VIO_PWR_STAT</name>
              <description>pd_vio power state
0: powered up
1: powered down</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>PD_CENTER_PWR_STAT</name>
              <description>pd_center power state
0: powered up
1: powered down</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>PD_PERIHP_PWR_STAT</name>
              <description>pd_perihp power state
0: powered up
1: powered down</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>PD_PERILP_PWR_STAT</name>
              <description>pd_perilp power stat
0: powered up
1: powered down</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>PD_CCI_PWR_STAT</name>
              <description>pd_core power state
0: powered up
1: powered down</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>PD_TCPD1_PWR_STAT</name>
              <description>pd_tcpd1 power state
0: powered up
1: powered down</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>PD_TCPD0_PWR_STAT</name>
              <description>pd_tcpd0 power state
0: powered up
1: powered down</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>PD_SCU_B_PWR_STAT</name>
              <description>pd_scu_b power state
0: powered up
1: powered down</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>PD_SCU_L_PWR_STAT</name>
              <description>pd_scu_l power state
0: powered up
1: powered down</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>PD_A72_B1_PWR_STAT</name>
              <description>pd_a72_b1 power state
0: powered up
1: powered down</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>PD_A72_B0_PWR_STAT</name>
              <description>pd_a72_b0 power state
0: powered up
1: powered down</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>PD_A53_L3_PWR_STAT</name>
              <description>pd_a53_l3 power state
0: powered up
1: powered down</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>PD_A53_L2_PWR_STAT</name>
              <description>pd_a53_l2 power state
0: powered up
1: powered down</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>PD_A53_L1_PWR_STAT</name>
              <description>pd_a53_l1 power state
0: powered up
1: powered down</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>PD_A53_L0_PWR_STAT</name>
              <description>pd_a53_l0 power state
0: powered up
1: powered down</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_WAKEUP_STATUS</name>
          <description>pmu interrupt wakeup status register/pmu interrupt status register</description>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WAKEUP_PCIE_STATUS</name>
              <description>pcie wakeup status
0: not wakeup by pcie
1: wakeup by pcie</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKEUP_PWM_STATUS</name>
              <description>pwm wakeup status
0: not wakeup by pwm
1: wakeup by pwm</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKEUP_TIMEOUT_STATUS</name>
              <description>timeout wakeup status
0: not wakeup by timeout
1: wakeup by timeout</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKEUP_WDT_M0_STATUS</name>
              <description>m0 wdt interrupt wakeup status
0: not wakeup by m0 wdt interrupt
1: wakeup by m0 wdt interrupt</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKEUP_SFT_M0_STATUS</name>
              <description>m0 software control wakeup status
0: not wakeup by software
1: wakeup by software</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKEUP_USBDEV_STATUS</name>
              <description>usbdev detect wakeup status
0: not wakeup by usbdev detect
1: wakeup by usbdev detect</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKEUP_TIMER_STATUS</name>
              <description>timer wakeup status
0: not wakeup by timer
1: wakeup by timer</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKEUP_SDMMC_STATUS</name>
              <description>sdmmc wakeup status
0: not wakeup by sdmmc detect
1: wakeup by sdmmc detect</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKEUP_SDIO_STATUS</name>
              <description>sdio wakeup status
0: not wakeup by sdio detect
1: wakeup by sdio detect</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKEUP_GPIO_INT_STATUS</name>
              <description>gpio interrupt wakeup status
0: not wakeup by gpio int
1: wakeup by gpio int</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKEUP_INT_CLUSTER_B_STATUS</name>
              <description>cluster_b interrupt wakeup status
0: not wakeup by interrupt cluster_b
1: wakeup by interrupt cluster_b</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKEUP_INT_CLUSTER_L_STATUS</name>
              <description>cluster_l interrupt wakeup status
0: not wakeup by interrupt cluster_l
1: wakeup by interrupt cluster_l</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_BUS_CLR</name>
          <description>pmu bus clear register</description>
          <addressOffset>0x5c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLR_SDIOAUDIO</name>
              <description>send idle request to sdioaudio low power interface
0: disable
1: enable</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLR_SD</name>
              <description>send idle request to sd low power interface
0: disable
1: enable</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLR_GIC</name>
              <description>send idle request to gic low power interface
0: disable
1: enable</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLR_PMUM0</name>
              <description>send idle request to pmu m0 low power interface
0: disable
1: enable</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLR_CENTER1</name>
              <description>send idle request to center1 low power interface
0: disable
1: enable</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLR_EMMC</name>
              <description>send idle request to emmc low power interface
0: disable
1: enable</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLR_GMAC</name>
              <description>send idle request to gmac low power interface
0: disable
1: enable</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLR_EDP</name>
              <description>send idle request to edp low power interface
0: disable
1: enable</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLR_PMU</name>
              <description>send idle request to pmu low power interface
0: disable
1: enable</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLR_ALIVE</name>
              <description>send idle request to alive low power interface
0: disable
1: enable</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLR_MSCH1</name>
              <description>send idle request to msch1 low power interface
0: disable
1: enable</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLR_MSCH0</name>
              <description>send idle request to msch0 low power interface
0: disable
1: enable</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLR_VIO</name>
              <description>send idle request to vio low power interface
0: disable
1: enable</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLR_CCIM0</name>
              <description>send idle request to ccim0 low power interface
0: disable
1: enable</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLR_CCIM1</name>
              <description>send idle request to ccim1 low power interface
0: disable
1: enable</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLR_CENTER</name>
              <description>send idle request to center niu
0: disable
1: enable</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLR_PERILPM0</name>
              <description>send idle request to perilp m0 niu
0: disable
1: enable</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLR_USB3</name>
              <description>send idle request to usb3 niu
0: disable
1: enable</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLR_HDCP</name>
              <description>send idle request to hdcp niu
0: disable
1: enable</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLR_ISP1</name>
              <description>send idle request to isp1 niu
0: disable
1: enable</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLR_ISP0</name>
              <description>send idle request to isp0 niu
0: disable
1: enable</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLR_VOPL</name>
              <description>send idle request to vopl niu
0: disable
1: enable</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLR_VOPB</name>
              <description>send idle request to vopb niu
0: disable
1: enable</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLR_IEP</name>
              <description>send idle request to iep niu
0: disable
1: enable</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLR_RGA</name>
              <description>send idle request to rga niu
0: disable
1: enable</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLR_VDU</name>
              <description>send idle request to vdu niu
0: disable
1: enable</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLR_VCODEC</name>
              <description>send idle request to vcodec niu
0: disable
1: enable</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLR_PERIHP</name>
              <description>send idle request to perihp niu
0: disable
1: enable</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLR_PERILP</name>
              <description>send idle request to perilp niu
0: disable
1: enable</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLR_GPU</name>
              <description>send idle request to gpu niu
0: disable
1: enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_BUS_IDLE_REQ</name>
          <description>pmu bus idle request register</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IDLE_REQ_SDIOAUDIO</name>
              <description>send idle request to sdioaudio low power interface
0: disable
1: enable</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IDLE_REQ_SD</name>
              <description>send idle request to sd low power interface
0: disable
1: enable</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IDLE_REQ_GIC</name>
              <description>send idle request to gic low power interface
0: disable
1: enable</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IDLE_REQ_PMUM0</name>
              <description>send idle request to pmu m0 low power interface
0: disable
1: enable</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IDLE_REQ_CENTER1</name>
              <description>send idle request to center1 low power interface
0: disable
1: enable</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IDLE_REQ_EMMC</name>
              <description>send idle request to emmc low power interface
0: disable
1: enable</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IDLE_REQ_GMAC</name>
              <description>send idle request to gmac low power interface
0: disable
1: enable</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IDLE_REQ_EDP</name>
              <description>send idle request to edp low power interface
0: disable
1: enable</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IDLE_REQ_PMU</name>
              <description>send idle request to pmu low power interface
0: disable
1: enable</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IDLE_REQ_ALIVE</name>
              <description>send idle request to alive low power interface
0: disable
1: enable</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IDLE_REQ_MSCH1</name>
              <description>send idle request to msch1 low power interface
0: disable
1: enable</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IDLE_REQ_MSCH0</name>
              <description>send idle request to msch0 low power interface
0: disable
1: enable</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IDLE_REQ_VIO</name>
              <description>send idle request to vio low power interface
0: disable
1: enable</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IDLE_REQ_CCIM1</name>
              <description>send idle request to ccim1 low power interface
0: disable
1: enable</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IDLE_REQ_CCIM0</name>
              <description>send idle request to ccim0 low power interface
0: disable
1: enable</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IDLE_REQ_CENTER</name>
              <description>send idle request to center niu
0: disable
1: enable</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IDLE_REQ_PERILPM0</name>
              <description>send idle request to perilp m0 niu
0: disable
1: enable</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IDLE_REQ_USB3</name>
              <description>send idle request to usb3 niu
0: disable
1: enable</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IDLE_REQ_HDCP</name>
              <description>send idle request to hdcp niu
0: disable
1: enable</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IDLE_REQ_ISP1</name>
              <description>send idle request to isp1 niu
0: disable
1: enable</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IDLE_REQ_ISP0</name>
              <description>send idle request to isp0 niu
0: disable
1: enable</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IDLE_REQ_VOPL</name>
              <description>send idle request to vopl niu
0: disable
1: enable</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IDLE_REQ_VOPB</name>
              <description>send idle request to vopb niu
0: disable
1: enable</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IDLE_REQ_IEP</name>
              <description>send idle request to iep niu
0: disable
1: enable</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IDLE_REQ_RGA</name>
              <description>send idle request to rga niu
0: disable
1: enable</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IDLE_REQ_VDU</name>
              <description>send idle request to vdu niu
0: disable
1: enable</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IDLE_REQ_VCODEC</name>
              <description>send idle request to vcodec niu
0: disable
1: enable</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IDLE_REQ_PERIHP</name>
              <description>send idle request to perihp niu
0: disable
1: enable</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IDLE_REQ_PERILP</name>
              <description>send idle request to perilp niu
0: disable
1: enable</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IDLE_REQ_GPU</name>
              <description>send idle request to gpu niu
0: disable
1: enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_BUS_IDLE_ST</name>
          <description>pmu bus idle status register</description>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IDLE_SDIOAUDIO</name>
              <description>send idle request to sdioaudio low power interface
0: disable
1: enable</description>
              <bitRange>[29:29]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_SD</name>
              <description>send idle request to sd low power interface
0: disable
1: enable</description>
              <bitRange>[28:28]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_GIC</name>
              <description>idle status of gic niu
0: idle status of niu is 0
1: idle status of niu is 1</description>
              <bitRange>[27:27]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_PMUM0</name>
              <description>idle status of pmu m0 niu
0: idle status of niu is 0
1: idle status of niu is 1</description>
              <bitRange>[26:26]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_CENTER1</name>
              <description>idle status of center1 niu
0: idle status of niu is 0
1: idle status of niu is 1</description>
              <bitRange>[25:25]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_EMMC</name>
              <description>idle status of emmc niu
0: idle status of niu is 0
1: idle status of niu is 1</description>
              <bitRange>[24:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_GMAC</name>
              <description>idle status of gmac niu
0: idle status of niu is 0
1: idle status of niu is 1</description>
              <bitRange>[23:23]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_EDP</name>
              <description>idle status of edp niu
0: idle status of niu is 0
1: idle status of niu is 1</description>
              <bitRange>[22:22]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_PMU</name>
              <description>idle status of pmu niu
0: idle status of niu is 0
1: idle status of niu is 1</description>
              <bitRange>[21:21]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_ALIVE</name>
              <description>idle status of alive niu
0: idle status of niu is 0
1: idle status of niu is 1</description>
              <bitRange>[20:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_MSCH1</name>
              <description>idle status of msch1 niu
0: idle status of niu is 0
1: idle status of niu is 1</description>
              <bitRange>[19:19]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_MSCH0</name>
              <description>idle status of msch0 niu
0: idle status of niu is 0
1: idle status of niu is 1</description>
              <bitRange>[18:18]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_VIO</name>
              <description>idle status of vio niu
0: idle status of niu is 0
1: idle status of niu is 1</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_CCIM1</name>
              <description>idle status of ccim1 niu
0: idle status of niu is 0
1: idle status of niu is 1</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_CCIM0</name>
              <description>idle status of ccim0 niu
0: idle status of niu is 0
1: idle status of niu is 1</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_CENTER</name>
              <description>idle status of center niu
0: idle status of niu is 0
1: idle status of niu is 1</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_PERILPM0</name>
              <description>idle status of perilpm0 niu
0: idle status of niu is 0
1: idle status of niu is 1</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_USB3</name>
              <description>idle status of usb3 niu
0: idle status of niu is 0
1: idle status of niu is 1</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_HDCP</name>
              <description>idle status of hdcp niu
0: idle status of niu is 0
1: idle status of niu is 1</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_ISP1</name>
              <description>idle status of isp1 niu
0: idle status of niu is 0
1: idle status of niu is 1</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_ISP0</name>
              <description>idle status of isp0 niu
0: idle status of niu is 0
1: idle status of niu is 1</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_VOPL</name>
              <description>idle status of vopl niu
0: idle status of niu is 0
1: idle status of niu is 1</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_VOPB</name>
              <description>idle status of vopb niu
0: idle status of niu is 0
1: idle status of niu is 1</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_IEP</name>
              <description>idle status of iep niu
0: idle status of niu is 0
1: idle status of niu is 1</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_RGA</name>
              <description>idle status of rga niu
0: idle status of niu is 0
1: idle status of niu is 1</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_VDU</name>
              <description>idle status of vdu niu
0: idle status of niu is 0
1: idle status of niu is 1</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_VCODEC</name>
              <description>idle status of vcodec niu
0: idle status of niu is 0
1: idle status of niu is 1</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_PERIHP</name>
              <description>idle status of perihp niu
0: idle status of niu is 0
1: idle status of niu is 1</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_PERILP</name>
              <description>idle status of perilp niu
0: idle status of niu is 0
1: idle status of niu is 1</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_GPU</name>
              <description>idle status of gpu niu
0: idle status of gpu_niu is 0
1: idle status of gpu_niu is 1</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_BUS_IDLE_ACK</name>
          <description>pmu bus idle ack status register</description>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IDLE_ACK_SDIOAUDIO</name>
              <description>idle acknowledge status from sdioaudio niu
0: idle acknowledge status of niu is 0
1: idle acknowledge status of niu is 1</description>
              <bitRange>[29:29]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_ACK_SD</name>
              <description>idle acknowledge status from sd niu
0: idle acknowledge status of niu is 0
1: idle acknowledge status of niu is 1</description>
              <bitRange>[28:28]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_ACK_GIC</name>
              <description>idle acknowledge status from gic niu
0: idle acknowledge status of niu is 0
1: idle acknowledge status of niu is 1</description>
              <bitRange>[27:27]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_ACK_PMUM0</name>
              <description>idle acknowledge status from pmu m0 niu
0: idle acknowledge status of niu is 0
1: idle acknowledge status of niu is 1</description>
              <bitRange>[26:26]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_ACK_CENTER1</name>
              <description>idle acknowledge status from center1 niu
0: idle acknowledge status of niu is 0
1: idle acknowledge status of niu is 1</description>
              <bitRange>[25:25]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_ACK_EMMC</name>
              <description>idle acknowledge status from emmc niu
0: idle acknowledge status of niu is 0
1: idle acknowledge status of niu is 1</description>
              <bitRange>[24:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_ACK_GMAC</name>
              <description>idle acknowledge status from gmac niu
0: idle acknowledge status of niu is 0
1: idle acknowledge status of niu is 1</description>
              <bitRange>[23:23]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_ACK_EDP</name>
              <description>idle acknowledge status from edp niu
0: idle acknowledge status of niu is 0
1: idle acknowledge status of niu is 1</description>
              <bitRange>[22:22]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_ACK_PMU</name>
              <description>idle acknowledge status from pmu niu
0: idle acknowledge status of niu is 0
1: idle acknowledge status of niu is 1</description>
              <bitRange>[21:21]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_ACK_ALIVE</name>
              <description>idle acknowledge status from alive niu
0: idle acknowledge status of niu is 0
1: idle acknowledge status of niu is 1</description>
              <bitRange>[20:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_ACK_MSCH1</name>
              <description>idle acknowledge status from msch1 niu
0: idle acknowledge status of niu is 0
1: idle acknowledge status of niu is 1</description>
              <bitRange>[19:19]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_ACK_MSCH0</name>
              <description>idle acknowledge status from msch0 niu
0: idle acknowledge status of niu is 0
1: idle acknowledge status of niu is 1</description>
              <bitRange>[18:18]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_ACK_VIO</name>
              <description>idle acknowledge status from vio niu
0: idle acknowledge status of niu is 0
1: idle acknowledge status of niu is 1</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_ACK_CCIM1</name>
              <description>idle acknowledge status from ccim1 niu
0: idle acknowledge status of niu is 0
1: idle acknowledge status of niu is 1</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_ACK_CCIM0</name>
              <description>idle acknowledge status from ccim0 niu
0: idle acknowledge status of niu is 0
1: idle acknowledge status of niu is 1</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_ACK_CENTER</name>
              <description>idle acknowledge status from center niu
0: idle acknowledge status of niu is 0
1: idle acknowledge status of niu is 1</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_ACK_PERILPM0</name>
              <description>idle acknowledge status from perilp m0 niu
0: idle acknowledge status of niu is 0
1: idle acknowledge status of niu is 1</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_ACK_USB3</name>
              <description>idle acknowledge status from usb3 niu
0: idle acknowledge status of niu is 0
1: idle acknowledge status of niu is 1</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_ACK_HDCP</name>
              <description>idle acknowledge status from hdcp niu
0: idle acknowledge status of niu is 0
1: idle acknowledge status of niu is 1</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_ACK_ISP1</name>
              <description>idle acknowledge status from isp1 niu
0: idle acknowledge status of niu is 0
1: idle acknowledge status of niu is 1</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_ACK_ISP0</name>
              <description>idle acknowledge status from isp0 niu
0: idle acknowledge status of niu is 0
1: idle acknowledge status of niu is 1</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_ACK_VOPL</name>
              <description>idle acknowledge status from vopl niu
0: idle acknowledge status of niu is 0
1: idle acknowledge status of niu is 1</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_ACK_VOPB</name>
              <description>idle acknowledge status from vopb niu
0: idle acknowledge status of niu is 0
1: idle acknowledge status of niu is 1</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_ACK_IEP</name>
              <description>idle acknowledge status from iep niu
0: idle acknowledge status of niu is 0
1: idle acknowledge status of niu is 1</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_ACK_RGA</name>
              <description>idle acknowledge status from rga niu
0: idle acknowledge status of niu is 0
1: idle acknowledge status of niu is 1</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_ACK_VDU</name>
              <description>idle acknowledge status from vdu niu
0: idle acknowledge status of niu is 0
1: idle acknowledge status of niu is 1</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_ACK_VCODEC</name>
              <description>idle acknowledge status from vcodec niu
0: idle acknowledge status of niu is 0
1: idle acknowledge status of niu is 1</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_ACK_PERIHP</name>
              <description>idle acknowledge status from perihp niu
0: idle acknowledge status of niu is 0
1: idle acknowledge status of niu is 1</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_ACK_PERILP</name>
              <description>idle acknowledge status from perilp niu
0: idle acknowledge status of niu is 0
1: idle acknowledge status of niu is 1</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_ACK_GPU</name>
              <description>idle acknowledge status from gpu niu
0: idle acknowledge status of niu is 0
1: idle acknowledge status of niu is 1</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_CCI500_CON</name>
          <description>CCI-500 low power control register</description>
          <addressOffset>0x6c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>When bit 16=1, bit 0    can be written by software .
When bit 16=0, bit 0    cannot be written by software;
When bit 17=1, bit 1    can be written by software .
When bit 17=0, bit 1    cannot be written by software;
......
When bit 31=1, bit 15    can be written by software .
When bit 31=0, bit 15    cannot be written by software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>QGATING_CCI500_CFG</name>
              <description>CCI-500 Q-channel clock gating enable.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLR_QREQ_CCI500</name>
              <description>CCI-500 Q-channel request sent by hardware.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>QREQ_CCI500_CFG</name>
              <description>CCI-500 Q-channel request sent by software.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PSTATE_CCI500</name>
              <description>CCI-500 P-channel pstate .</description>
              <bitRange>[4:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLR_PREQ_CCI500</name>
              <description>CCI-500 P-channel request sent by hardware .</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PREQ_CCI500_CFG</name>
              <description>CCI-500 P-channel request sent by software</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_ADB400_CON</name>
          <description>adb-400 low power control register</description>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>When bit 16=1, bit 0    can be written by software .
When bit 16=0, bit 0    cannot be written by software;
When bit 17=1, bit 1    can be written by software .
When bit 17=0, bit 1    cannot be written by software;
......
When bit 31=1, bit 15    can be written by software .
When bit 31=0, bit 15    cannot be written by software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLR_GIC2_CORE_B</name>
              <description>hardware send idle request to path from gic to core_b low power
interface
0: disable
1: enable</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLR_CORE_B_2GIC</name>
              <description>hardware send idle request to path from core_b to gic    low power
interface
0: disable
1: enable</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLR_CORE_B</name>
              <description>hardware send idle request from core_b to cci low power interface
0: disable
1: enable</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLR_GIC2_CORE_L</name>
              <description>hardware send idle request to path from gic to core_l low power
interface
0: disable
1: enable</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLR_CORE_L_2GIC</name>
              <description>hardware send idle request to path from core_l to gic    low power
interface
0: disable
1: enable</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLR_CORE_L</name>
              <description>software send idle request from core_l to cci low power interface
0: disable
1: enable</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLR_CXCS</name>
              <description>hardware send idle request to cxcs low power interface
0: disable
1: enable</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PWRDWN_REQ_GIC2_CORE_B</name>
              <description>send idle request to path from gic to core_b low power interface
0: disable
1: enable</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PWRDWN_REQ_CORE_B_2GIC</name>
              <description>software send idle request to path from core_b to gic    low power
interface
0: disable
1: enable</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PWRDWN_REQ_CORE_B</name>
              <description>software send idle request from core_b to cci low power interface
0: disable
1: enable</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PWRDWN_REQ_GIC2_CORE_L</name>
              <description>send idle request to path from gic to core_l low power interface
0: disable
1: enable</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PWRDWN_REQ_CORE_L_2GIC</name>
              <description>software send idle request to path from core_l to gic    low power
interface
0: disable
1: enable</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PWRDWN_REQ_CORE_L</name>
              <description>software send idle request from core_l to cci low power interface
0: disable
1: enable</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PWRDWN_REQ_CXCS</name>
              <description>software send idle request to cxcs low power interface
0: disable
1: enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_ADB400_ST</name>
          <description>adb-400 low power status register</description>
          <addressOffset>0x74</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IDLE_GIC2_CORE_B</name>
              <description>active status of cxcs low power interface
0: active status    is 0 (inactive)
1: active status    is 1 (active)</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_CORE_B_2GIC</name>
              <description>active status of cxcs low power interface
0: active status    is 0 (inactive)
1: active status    is 1 (active)</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_CORE_B</name>
              <description>active status of cxcs low power interface
0: active status    is 0 (inactive)
1: active status    is 1 (active)</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_GIC2_CORE_L</name>
              <description>active status of cxcs low power interface
0: active status    is 0 (inactive)
1: active status    is 1 (active)</description>
              <bitRange>[11:11]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>IDLE_CORE_L_2GIC</name>
              <description>active status of cxcs low power interface
0: active status    is 0 (inactive)
1: active status    is 1 (active)</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_CORE_L</name>
              <description>active status of cxcs low power interface
0: active status    is 0 (inactive)
1: active status    is 1 (active)</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ACTIVE_CXCS</name>
              <description>active status of cxcs low power interface
0: active status    is 0 (inactive)
1: active status    is 1 (active)</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PWRDWN_ACK_GIC2_CORE_B</name>
              <description>idle acknowledge status from cxcs
0: idle acknowledge status of adb is 0
1: idle acknowledge status of adb is 1</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PWRDWN_ACK_CORE_B_2GIC</name>
              <description>idle acknowledge status from cxcs
0: idle acknowledge status of adb is 0
1: idle acknowledge status of adb is 1</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PWRDWN_ACK_CORE_B</name>
              <description>idle acknowledge status from cxcs
0: idle acknowledge status of adb is 0
1: idle acknowledge status of adb is 1</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PWRDWN_ACK_GIC2_CORE_L</name>
              <description>idle acknowledge status from cxcs
0: idle acknowledge status of adb is 0
1: idle acknowledge status of adb is 1</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PWRDWN_ACK_CORE_L_2GIC</name>
              <description>idle acknowledge status from cxcs
0: idle acknowledge status of adb is 0
1: idle acknowledge status of adb is 1</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PWRDWN_ACK_CORE_L</name>
              <description>idle acknowledge status from cxcs
0: idle acknowledge status of adb is 0
1: idle acknowledge status of adb is 1</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PWRDWN_ACK_CXCS</name>
              <description>idle acknowledge status from cxcs
0: idle acknowledge status of adb is 0
1: idle acknowledge status of adb is 1</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_POWER_ST</name>
          <description>pmu power status register</description>
          <addressOffset>0x78</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>POWER_STATE</name>
              <description>power state of pmu FSM</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_CORE_PWR_ST</name>
          <description>pmu core power status register</description>
          <addressOffset>0x7c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>QACCEPTN_CCI500</name>
              <description>CCI-500 Q-channel accept signal, active low</description>
              <bitRange>[29:29]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>QDENY_CCI500</name>
              <description>CCI-500 Q-channel deny signal, active high</description>
              <bitRange>[28:28]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>QACTIVE_CCI500</name>
              <description>CCI-500 Q-channel active signal, active high</description>
              <bitRange>[27:27]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PACCEPT_CCI500</name>
              <description>CCI-500 P-channel accept signal, active high</description>
              <bitRange>[26:26]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PDENY_CCI500</name>
              <description>CCI-500 P-channel deny signal, active high</description>
              <bitRange>[25:25]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PACTIVE_CCI500</name>
              <description>CCI-500 P-channel active signal, active high</description>
              <bitRange>[24:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STANDBYWFI_CLUSTER_B</name>
              <description>standbywfi status of cluster_b
0: cluster_b standbywfi status is 0
1: cluster_b standbywfi status is 1</description>
              <bitRange>[17:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STANDBYWFE_CLUSTER_B</name>
              <description>standbywfe status of cluster_b
0: cluster_b standbywfe status is 0
1: cluster_b standbywfe status is 1</description>
              <bitRange>[13:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STANDBYWFIL2_CLUSTER_B</name>
              <description>standbywfil2 status of cluster_b
0: cluster_b standbywfil2 status is 0
1: cluster_b standbywfil2 status is 1</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>L2FLUSHDONE_CLUSTER_B</name>
              <description>l2flushdone status of cluster_b
0: cluster_b l2flushdone status is 0
1: cluster_b l2flushdone status is 1</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STANDBYWFI_CLUSTER_L</name>
              <description>standbywfi status of cluster_l
0: cluster_l standbywfi status is 0
1: cluster_l standbywfi status is 1</description>
              <bitRange>[9:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STANDBYWFE_CLUSTER_L</name>
              <description>standbywfe status of cluster_l
0: cluster_l standbywfe status is 0
1: cluster_l standbywfe status is 1</description>
              <bitRange>[5:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STANDBYWFIL2_CLUSTER_L</name>
              <description>standbywfil2 status of cluster_l
0: cluster_l standbywfil2 status is 0
1: cluster_l standbywfil2 status is 1</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>L2FLUSHDONE_CLUSTER_L</name>
              <description>l2flushdone status of cluster_l
0: cluster_l l2flushdone status is 0
1: cluster_l l2flushdone status is 1</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_OSC_CNT</name>
          <description>pmu osc count register</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PMU_OSC_CNT</name>
              <description>pmu osc stable counter value</description>
              <bitRange>[19:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_PLLLOCK_CNT</name>
          <description>pmu pll lock count register</description>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PMU_PLLLOCK_CNT</name>
              <description>pmu pll lock counter value</description>
              <bitRange>[19:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_PLLRST_CNT</name>
          <description>pmu pll reset count register</description>
          <addressOffset>0x88</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PMU_PLLRST_CNT</name>
              <description>pmu pll reset counter value</description>
              <bitRange>[19:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_STABLE_CNT</name>
          <description>pmu power stable count register</description>
          <addressOffset>0x8c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PMU_STABLE_CNT</name>
              <description>pmu PMIC stable counter value</description>
              <bitRange>[19:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_DDRIO_PWRON_CNT</name>
          <description>pmu ddrio power on count register</description>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PMU_DDRIO_PWRON_CNT</name>
              <description>pmu ddrio power on counter value</description>
              <bitRange>[19:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_WAKEUP_RST_CLR_CNT</name>
          <description>pmu wakeup reset clear count register</description>
          <addressOffset>0x94</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PMU_WAKEUP_RST_CNT</name>
              <description>pmu    wakeup reset counter value</description>
              <bitRange>[19:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_DDR_SREF_ST</name>
          <description>pmu ddr self refresh status register</description>
          <addressOffset>0x98</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DDRC1_SREF_DONE_EXT</name>
              <description>ddr controller 1 self re-fresh done, active high</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DDRC0_SREF_DONE_EXT</name>
              <description>ddr controller 0 self re-fresh done, active high</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_SCU_L_PWRDN_CNT</name>
          <description>pmu scu_l power down count register</description>
          <addressOffset>0x9c</addressOffset>
          <size>32</size>
          <resetValue>0x5dc0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PMU_SCU_L_PWRDN_CNT</name>
              <description>pmu scu_l power down counter value</description>
              <bitRange>[19:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_SCU_L_PWRUP_CNT</name>
          <description>pmu scu_l power up count register</description>
          <addressOffset>0xa0</addressOffset>
          <size>32</size>
          <resetValue>0x5dc0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PMU_SCU_L_PWRUP_CNT</name>
              <description>pmu scu_l power up counter value</description>
              <bitRange>[19:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_SCU_B_PWRDN_CNT</name>
          <description>pmu scu_b power down count register</description>
          <addressOffset>0xa4</addressOffset>
          <size>32</size>
          <resetValue>0x5dc0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PMU_SCU_B_PWRDN_CNT</name>
              <description>pmu scu_b power down counter value</description>
              <bitRange>[19:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_SCU_B_PWRUP_CNT</name>
          <description>pmu scu_b power up count register</description>
          <addressOffset>0xa8</addressOffset>
          <size>32</size>
          <resetValue>0x5dc0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PMU_SCU_B_PWRUP_CNT</name>
              <description>pmu scu_b power up counter value</description>
              <bitRange>[19:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_GPU_PWRDN_CNT</name>
          <description>pmu gpu power down count register</description>
          <addressOffset>0xac</addressOffset>
          <size>32</size>
          <resetValue>0x5dc0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PMU_GPU_PWRDN_CNT</name>
              <description>pmu gpu power down counter value</description>
              <bitRange>[19:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_GPU_PWRUP_CNT</name>
          <description>pmu gpu power up count register</description>
          <addressOffset>0xb0</addressOffset>
          <size>32</size>
          <resetValue>0x5dc0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PMU_GPU_PWRUP_CNT</name>
              <description>pmu gpu power up counter value</description>
              <bitRange>[19:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_CENTER_PWRDN_CNT</name>
          <description>pmu center power down count register</description>
          <addressOffset>0xb4</addressOffset>
          <size>32</size>
          <resetValue>0x5dc0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PMU_CENTER_PWRDN_CNT</name>
              <description>pmu center power down counter value</description>
              <bitRange>[19:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_CENTER_PWRUP_CNT</name>
          <description>pmu center power up count register</description>
          <addressOffset>0xb8</addressOffset>
          <size>32</size>
          <resetValue>0x5dc0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PMU_CENTER_PWRUP_CNT</name>
              <description>pmu center power up counter value</description>
              <bitRange>[19:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_TIMEOUT_CNT</name>
          <description>pmu timeout count register</description>
          <addressOffset>0xbc</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIMEOUT_COUNT</name>
              <description>timeout wakeup counter value</description>
              <bitRange>[19:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_CPU0APM_CON</name>
          <description>pmu cpu0 auto power down control register</description>
          <addressOffset>0xc0</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CPU_L0_SFT_WAKEUP</name>
              <description>cpu l0 software wakeup source.
1: wakeup ;
0: nothing ;</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPU_L0_INT_WAKEUP_EN</name>
              <description>cpu l0 interrupt wake enable.
0: disable ;
1: enable    ;</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPU_L0_WFI_PWRDN_EN</name>
              <description>cpu_l0 wfi power down enable.
0: disable ;
1: enable    ;</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_CPU1APM_CON</name>
          <description>pmu cpu1 auto power down control register</description>
          <addressOffset>0xc4</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CPU_L1_SFT_WAKEUP</name>
              <description>cpu l1 software wakeup source.
1: wakeup ;
0: nothing ;</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPU_L1_INT_WAKEUP_EN</name>
              <description>cpu l1 interrupt wake enable.
0: disable ;
1: enable    ;</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPU_L1_WFI_PWRDN_EN</name>
              <description>cpu_l1 wfi power down enable.
0: disable ;
1: enable    ;</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_CPU2APM_CON</name>
          <description>pmu cpu2 auto power down control register</description>
          <addressOffset>0xc8</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CPU_L2_SFT_WAKEUP</name>
              <description>cpu l2 software wakeup source.
1: wakeup ;
0: nothing ;</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPU_L2_INT_WAKEUP_EN</name>
              <description>cpu l2 interrupt wake enable.
0: disable ;
1: enable    ;</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPU_L2_WFI_PWRDN_EN</name>
              <description>cpu_l2 wfi power down enable.
0: disable ;
1: enable    ;</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_CPU3APM_CON</name>
          <description>pmu cpu3 auto power down control register</description>
          <addressOffset>0xcc</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CPU_L3_SFT_WAKEUP</name>
              <description>cpu l3 software wakeup source.
1: wakeup ;
0: nothing ;</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPU_L3_INT_WAKEUP_EN</name>
              <description>cpu l3 interrupt wake enable.
0: disable ;
1: enable    ;</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPU_L3_WFI_PWRDN_EN</name>
              <description>cpu_l3 wfi power down enable.
0: disable ;
1: enable    ;</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_CPU0BPM_CON</name>
          <description>pmu cluster_b cpu0 auto power down control register</description>
          <addressOffset>0xd0</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CPU_B0_SFT_WAKEUP</name>
              <description>cpu b0 software wakeup source.
1: wakeup ;
0: nothing ;</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPU_B0_INT_WAKEUP_EN</name>
              <description>cpu b0 interrupt wake enable.
0: disable ;
1: enable    ;</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPU_B0_WFI_PWRDN_EN</name>
              <description>cpu_b0 wfi power down enable.
0: disable ;
1: enable    ;</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_CPU1BPM_CON</name>
          <description>pmu cluster_b cpu0 auto power down control register</description>
          <addressOffset>0xd4</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CPU_B0_SFT_WAKEUP</name>
              <description>cpu b0 software wakeup source.
1: wakeup ;
0: nothing ;</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPU_B0_INT_WAKEUP_EN</name>
              <description>cpu b0 interrupt wake enable.
0: disable ;
1: enable    ;</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPU_B0_WFI_PWRDN_EN</name>
              <description>cpu_b0 wfi power down enable.
0: disable ;
1: enable    ;</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_NOC_AUTO_ENA</name>
          <description>NOC auto domain clock gating disable enable register</description>
          <addressOffset>0xd8</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SDIOAUDIO_GATING_DISABLE</name>
              <description>0: nothing
1: clock gating disable.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SD_GATING_DISABLE</name>
              <description>0: nothing
1: clock gating disable.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GIC_GATING_DISABLE</name>
              <description>0: nothing ;
1: clock gating disable.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPU_GATING_DISABLE</name>
              <description>0: nothing ;
1: clock gating disable.</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PERILP_GATING_DISABLE</name>
              <description>0: nothing ;
1: clock gating disable.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PERIHP_GATING_DISABLE</name>
              <description>0: nothing ;
1: clock gating disable.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VCODEC_GATING_DISABLE</name>
              <description>0: nothing
1: clock gating disable.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VDU_GATING_DISABLE</name>
              <description>0: nothing ;
1: clock gating disable.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RGA_GATING_DISABLE</name>
              <description>0: nothing ;
1: clock gating disable.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IEP_GATING_DISABLE</name>
              <description>0: nothing ;
1: clock gating disable.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VOPB_GATING_DISABLE</name>
              <description>0: nothing ;
1: clock gating disable.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VOPL_GATING_DISABLE</name>
              <description>0: nothing ;
1: clock gating disable.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ISP0_GATING_DISABLE</name>
              <description>0: nothing ;
1: clock gating disable.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ISP1_GATING_DISABLE</name>
              <description>0: nothing ;
1: clock gating disable.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HDCP_GATING_DISABLE</name>
              <description>0: nothing ;
1: clock gating disable.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>USB3_GATING_DISABLE</name>
              <description>0: nothing
1: clock gating disable.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PERILPM0_GATING_DISABLE</name>
              <description>0: nothing ;
1: clock gating disable.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CENTER_GATING_DISABLE</name>
              <description>0: noting
1: clock gating disable.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CCIM0_GATING_DISABLE</name>
              <description>0: nothing ;
1: clock gating disable.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CCIM1_GATING_DISABLE</name>
              <description>0: nothing ;
1: clock gating disable.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VIO_GATING_DISABLE</name>
              <description>0: nothing ;
1: clock gating disable.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MSCH0_GATING_DISABLE</name>
              <description>0: nothing ;
1: clock gating disable.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MSCH1_GATING_DISABLE</name>
              <description>0: nothing ;
1: clock gating disable.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALIVE_GATING_DISABLE</name>
              <description>0: nothing ;
1: clock gating disable.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMU_GATING_DISABLE</name>
              <description>0: nothing ;
1: clock gating disable.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EDP_GATING_DISABLE</name>
              <description>0: nothing ;
1: clock gating disable.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GMAC_GATING_DISABLE</name>
              <description>0: nothing ;
1: gmac clock gating disable.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMMC_GATING_DISABLE</name>
              <description>0: nothing ;
1: clock gating disable.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CENTER1_GATING_DISABLE</name>
              <description>0: nothing
1: clock gating disable.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMUM0_GATING_DISABLE</name>
              <description>0: noting ;
1: clock gating disable.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_PWRDN_CON1</name>
          <description>pmu power down configure register1</description>
          <addressOffset>0xdc</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VD_CENTER_PWRDWN</name>
              <description>vd_center power down enable
0: disable
1: enable</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VD_SCU_B_PWRDWN</name>
              <description>vd_scu_b power down enable
0: disable
1: enable</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VD_SCU_L_ENABLE</name>
              <description>vd_scu_l power down enable
0: disable
1: enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_SYS_REG0</name>
          <description>pmu system register 0</description>
          <addressOffset>0xf0</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PMU_SYS_REG0</name>
              <description>system register 0</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_SYS_REG1</name>
          <description>pmu system register 1</description>
          <addressOffset>0xf4</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PMU_SYS_REG1</name>
              <description>system register 1</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_SYS_REG2</name>
          <description>pmu system register 2</description>
          <addressOffset>0xf8</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PMU_SYS_REG2</name>
              <description>system register 2</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_SYS_REG3</name>
          <description>pmu system register 3</description>
          <addressOffset>0xfc</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PMU_SYS_REG3</name>
              <description>system register 3</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>UART0</name>
      <version>1.0</version>
      <groupname>UART</groupname>
      <baseAddress>0xff180000</baseAddress>
      <registers>
        <register>
          <name>UART_RBR</name>
          <description>Receive Buffer Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA_INPUT</name>
              <description>Data byte received on the serial input port (sin) in UART mode, or
the serial infrared input (sir_in) in infrared mode. The data in this
register is valid only if the Data Ready (DR) bit in the Line Status
Register (LCR) is set.
If in non-FIFO mode (FIFO_MODE == NONE) or FIFOs are
disabled (FCR[0] set to zero), the data in the RBR must be read
before the next data arrives, otherwise it is overwritten, resulting
in an over-run error.
If in FIFO mode (FIFO_MODE != NONE) and FIFOs are enabled
(FCR[0] set to one), this register accesses the head of the receive
FIFO.
If the receive FIFO is full and this register is not read before the
next data character arrives, then the data already in the FIFO is
preserved, but any incoming data are lost and an
over-run error occurs.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_THR</name>
          <description>Transmit Holding Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA_OUTPUT</name>
              <description>Data to be transmitted on the serial output port (sout) in UART
mode or the serial infrared output (sir_out_n) in infrared mode.
Data should only be written to the THR when the THR Empty
(THRE) bit (LSR[5]) is set.
If in non-FIFO mode or FIFOs are disabled (FCR[0] = 0) and
THRE is set, writing a single character to the THR clears the
THRE. Any additional writes to the THR before the THRE is set
again causes the THR data to be overwritten.
If in FIFO mode and FIFOs are enabled (FCR[0] = 1) and THRE is
set, x number of characters of data may be written to the THR
before the FIFO is full. The number x (default=16) is determined
by the value of FIFO Depth that you set during configuration. Any
attempt to write data when the FIFO is full results in the write
data being lost.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_DLL</name>
          <description>Divisor Latch (Low)</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BAUD_RATE_DIVISOR_L</name>
              <description>Lower 8-bits of a 16-bit, read/write, Divisor Latch register that
contains the baud rate divisor for the UART. This register may
only be accessed when the DLAB bit (LCR[7]) is set and the UART
is not busy (USR[0] is zero). The output baud rate is equal to the
serial clock (sclk) frequency divided by sixteen times the value of
the baud rate divisor, as follows: baud rate = (serial clock freq) /
(16 * divisor).
Note that with the Divisor Latch Registers (DLL and DLH) set to
zero, the baud clock is disabled and no serial communications
occur. Also, once the DLH is set, at least 8 clock cycles of the
slowest UART clock should be allowed to pass before transmitting
or receiving data.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_DLH</name>
          <description>Divisor Latch (High)</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BAUD_RATE_DIVISOR_H</name>
              <description>Upper 8 bits of a 16-bit, read/write, Divisor Latch register that
contains the baud rate divisor for the UART.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_IER</name>
          <description>Interrupt Enable Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PROG_THRE_INT_EN</name>
              <description>Programmable THRE Interrupt Mode Enable
This is used to enable/disable the generation of THRE Interrupt.
0 = disabled
1 = enabled</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODEM_STATUS_INT_EN</name>
              <description>Enable Modem Status Interrupt.
This is used to enable/disable the generation of Modem Status
Interrupt. This is the fourth highest priority interrupt.
0 = disabled
1 = enabled</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RECEIVE_LINE_STATUS_INT_EN</name>
              <description>Enable Receiver Line Status Interrupt.
This is used to enable/disable the generation of Receiver Line
Status Interrupt. This is the highest priority interrupt.
0 = disabled
1 = enabled</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TRANS_HOLD_EMPTY_INT_EN</name>
              <description>Enable Transmit Holding Register Empty Interrupt.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RECEIVE_DATA_AVAILABLE_INT_EN</name>
              <description>Enable Received Data Available Interrupt.
This is used to enable/disable the generation of Received Data
Available Interrupt and the Character Timeout Interrupt (if in
FIFO mode and FIFOs enabled). These are the second highest
priority interrupts.
0 = disabled
1 = enabled</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_IIR</name>
          <description>Interrupt Identification Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FIFOS_EN</name>
              <description>FIFOs Enabled.
This is used to indicate whether the FIFOs are enabled or
disabled.
00 = disabled
11 = enabled</description>
              <bitRange>[7:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INT_ID</name>
              <description>Interrupt ID
This indicates the highest priority pending interrupt which can be
one of the following types:
0000 = modem status
0001 = no interrupt pending
0010 = THR empty
0100 = received data available
0110 = receiver line status
0111 = busy detect
1100 = character timeout</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_FCR</name>
          <description>FIFO Control Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RCVR_TRIGGER</name>
              <description>RCVR Trigger.
This is used to select the trigger level in the receiver FIFO at
which the Received Data Available Interrupt is generated. In auto
flow control mode it is used to determine when the rts_n signal is
de-asserted. It also determines when the dma_rx_req_n signal is
asserted in certain modes of operation. The following trigger
levels are supported:
00 = 1 character in the FIFO
01 = FIFO 1/4 full
10 = FIFO 1/2 full
11 = FIFO 2 less than ful</description>
              <bitRange>[7:6]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>TX_EMPTY_TRIGGER</name>
              <description>TX Empty Trigger.
This is used to select the empty threshold level at which the THRE
Interrupts are generated when the mode is active. It also
determines when the dma_tx_req_n signal is asserted when in
certain modes of operation. The following trigger levels are
supported:
00 = FIFO empty
01 = 2 characters in the FIFO
10 = FIFO 1/4 full
11 = FIFO 1/2 full</description>
              <bitRange>[5:4]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DMA_MODE</name>
              <description>DMA Mode
This determines the DMA signalling mode used for the
dma_tx_req_n and dma_rx_req_n output signals when additional
DMA handshaking signals are not selected .
0 = mode 0
1 = mode 11100 = character timeout.</description>
              <bitRange>[3:3]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>XMIT_FIFO_RESET</name>
              <description>XMIT FIFO Reset.
This resets the control portion of the transmit FIFO and treats the
FIFO as empty. This also de-asserts the DMA TX request and
single signals when additional DMA handshaking signals are
selected . Note that this bit is 'self-clearing'. It is not necessary to
clear this bit.</description>
              <bitRange>[2:2]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>RCVR_FIFO_RESET</name>
              <description>RCVR FIFO Reset.
This resets the control portion of the receive FIFO and treats the
FIFO as empty. This also de-asserts the DMA RX request and
single signals when additional DMA handshaking signals are
selected. Note that this bit is 'self-clearing'. It is not necessary to
clear this bit.</description>
              <bitRange>[1:1]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>FIFO_EN</name>
              <description>FIFO Enable.
FIFO Enable. This enables/disables the transmit (XMIT) and
receive (RCVR) FIFOs. Whenever the value of this bit is changed
both the XMIT and RCVR controller portion of FIFOs is reset.</description>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_LCR</name>
          <description>Line Control Register</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DIV_LAT_ACCESS</name>
              <description>Divisor Latch Access Bit.
Writeable only when UART is not busy (USR[0] is zero), always
readable. This bit is used to enable reading and writing of the
Divisor Latch register (DLL and DLH) to set the baud rate of the
UART. This bit must be cleared after initial baud rate setup in
order to access other registers.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BREAK_CTRL</name>
              <description>Break Control Bit.
This is used to cause a break condition to be transmitted to the
receiving device. If set to one the serial output is forced to the
spacing (logic 0) state. When not in Loopback Mode, as
determined by MCR[4], the sout line is forced low until the Break
bit is cleared. If MCR[6] set to one, the sir_out_n line is
continuously pulsed. When in Loopback Mode, the break condition
is internally looped back to the
receiver and the sir_out_n line is forced low.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EVEN_PARITY_SEL</name>
              <description>Even Parity Select.
Writeable only when UART is not busy (USR[0] is zero), always
readable. This is used to select between even and odd parity,
when parity is enabled (PEN set to one). If set to one, an even
number of logic 1s is transmitted or checked. If set to zero, an
odd number of logic 1s is transmitted or checked.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_EN</name>
              <description>Parity Enable.
Writeable only when UART is not busy (USR[0] is zero), always
readable. This bit is used to enable and disable parity generation
and detection in transmitted and received serial character
respectively.
0 = parity disabled
1 = parity enabled</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STOP_BITS_NUM</name>
              <description>Number of stop bits.
Writeable only when UART is not busy (USR[0] is zero), always
readable. This is used to select the number of stop bits per
character that the peripheral transmits and receives. If set to
zero, one stop bit is transmitted in the serial data. If set to one
and the data bits are set to 5 (LCR[1:0] set to zero) one and a
half stop bits is transmitted. Otherwise, two stop bits are
transmitted. Note that regardless of the number of stop bits
selected, the receiver checks only the first stop bit.
0 = 1 stop bit
1 = 1.5 stop bits when DLS (LCR[1:0]) is zero, else 2 stop bit.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_LENGTH_SEL</name>
              <description>Data Length Select.
Writeable only when UART is not busy (USR[0] is zero), always
readable. This is used to select the number of data bits per
character that the peripheral transmits and receives. The number
of bit that may be selected areas follows:
00 = 5 bits
01 = 6 bits
10 = 7 bits
11 = 8 bits</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_MCR</name>
          <description>Modem Control Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SIR_MODE_EN</name>
              <description>SIR Mode Enable.
SIR Mode Enable.
This is used to enable/disable the IrDA SIR Mode .
0 = IrDA SIR Mode disabled
1 = IrDA SIR Mode enabled</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTO_FLOW_CTRL_EN</name>
              <description>Auto Flow Control Enable.
0 = Auto Flow Control Mode disabled
1 = Auto Flow Control Mode enabled</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOOPBACK</name>
              <description>LoopBack Bit.
This is used to put the UART into a diagnostic mode for test
purposes.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OUT2</name>
              <description>OUT2.
This is used to directly control the user-designated Output2
(out2_n) output. The value written to this location is inverted and
driven out on out2_n, that is:
0 = out2_n de-asserted (logic 1)
1 = out2_n asserted (logic 0)</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OUT1</name>
              <description>OUT1
This is used to directly control the user-designated Output2
(out2_n) output. The value written to this location is inverted and
driven out on out2_n, that is:
1&#8217;b0: out2_n de-asserted (logic 1)
1&#8217;b1: out2_n asserted (logic 0)
req_to_send
Request to Send.
This is used to directly control the Request to Send (rts_n)
output. The Request To Send (rts_n) output is used to inform the
modem or data set that the UART is ready to exchange data.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REQ_TO_SEND</name>
              <description>Request to Send.
This is used to directly control the Request to Send (rts_n)
output. The Request To Send (rts_n) output is used to inform the
modem or data set that the UART is ready to exchange data.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_TERMINAL_READY</name>
              <description>Data Terminal Ready.
This is used to directly control the Data Terminal Ready (dtr_n)
output. The value written to this location is inverted and driven
out on dtr_n, that is:
0 = dtr_n de-asserted (logic 1)
1 = dtr_n asserted (logic 0)</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_LSR</name>
          <description>Line Status Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RECEIVER_FIFO_ERROR</name>
              <description>Receiver FIFO Error bit.
This bit is relevant FIFOs are enabled (FCR[0] set to one). This is
used to indicate if there is at least one parity error, framing error,
or break indication in the FIFO.
0 = no error in RX FIFO
1 = error in RX FIFO</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TRANS_EMPTY</name>
              <description>Transmitter Empty bit.
Transmitter Empty bit. If FIFOs enabled (FCR[0] set to one), this
bit is set whenever the Transmitter Shift Register and the FIFO
are both empty. If FIFOs are disabled, this bit is set whenever the
Transmitter Holding Register and the Transmitter Shift Register
are both empty.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TRANS_HOLD_REG_EMPTY</name>
              <description>Transmit Holding Register Empty bit.
If THRE mode is disabled (IER[7] set to zero) and regardless of
FIFO's being implemented/enabled or not, this bit indicates that
the THR or TX FIFO is empty.
This bit is set whenever data is transferred from the THR or TX
FIFO to the transmitter shift register and no new data has been
written to the THR or TX FIFO. This also causes a THRE Interrupt
to occur, if the THRE Interrupt is enabled. If IER[7] set to one
and FCR[0] set to one respectively, the functionality is switched
to indicate the transmitter FIFO is full, and no longer controls
THRE interrupts, which are then controlled by the FCR[5:4]
threshold setting.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BREAK_INT</name>
              <description>Break Interrupt bit.
This is used to indicate the detection of a break sequence on the
serial input data.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FRAMING_ERROR</name>
              <description>Framing Error bit.
This is used to indicate the occurrence of a framing error in the
receiver. A framing error occurs when the receiver does not
detect a valid STOP bit in the received data.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PARITY_EROR</name>
              <description>Parity Error bit.
This is used to indicate the occurrence of a parity error in the
receiver if the Parity Enable (PEN) bit (LCR[3]) is set.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVERRUN_ERROR</name>
              <description>Overrun error bit.
This is used to indicate the occurrence of an overrun error. This
occurs if a new data character was received before the previous
data was read.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DATA_READY</name>
              <description>Data Ready bit.
This is used to indicate that the receiver contains at least one
character in the RBR or the receiver FIFO.
0 = no data ready
1 = data ready</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_MSR</name>
          <description>Modem Status Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA_CARRIOR_DETECT</name>
              <description>Data Carrier Detect.
This is used to indicate the current state of the modem control
line dcd_n.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RING_INDICATOR</name>
              <description>Ring Indicator.
This is used to indicate the current state of the modem control
line ri_n.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DATA_SET_READY</name>
              <description>Data Set Ready.
This is used to indicate the current state of the modem control
line dsr_n.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CLEAR_TO_SEND</name>
              <description>Clear to Send.
This is used to indicate the current state of the modem control
line cts_n.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DELTA_DATA_CARRIER_DETECT</name>
              <description>Delta Data Carrier Detect.
This is used to indicate that the modem control line dcd_n has
changed since the last time the MSR was read.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TRAILING_EDGE_RING_INDICATOR</name>
              <description>Trailing Edge of Ring Indicator.
Trailing Edge of Ring Indicator. This is used to indicate that a
change on the input ri_n (from an active-low to an inactive-high
state) has occurred since the last time the MSR was read.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DELTA_DATA_SET_READY</name>
              <description>Delta Data Set Ready.
This is used to indicate that the modem control line dsr_n has
changed since the last time the MSR was read.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DELTA_CLEAR_TO_SEND</name>
              <description>Delta Clear to Send.
This is used to indicate that the modem control line cts_n has
changed since the last time the MSR was read.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_SCR</name>
          <description>Scratchpad Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TEMP_STORE_SPACE</name>
              <description>This register is for programmers to use as a temporary storage
space.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_SRBR</name>
          <description>Shadow Receive Buffer Register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SHADOW_RBR</name>
              <description>This is a shadow register for the RBR and has been allocated
sixteen 32-bit locations so as to accommodate burst accesses
from the master. This register contains the data byte received on
the serial input port (sin) in UART mode or the serial infrared
input (sir_in) in infrared mode. The data in this register is valid
only if the Data Ready (DR) bit in the Line status Register (LSR)
is set.
If FIFOs are disabled (FCR[0] set to zero), the data in the RBR
must be read before the next data arrives, otherwise it is
overwritten, resulting in an overrun error.
If FIFOs are enabled (FCR[0] set to one), this register accesses
the head of the receive FIFO. If the receive FIFO is full and this
register is not read before the next data character arrives, then
the data already in the FIFO are preserved, but any incoming
data is lost. An overrun error also occurs.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_STHR</name>
          <description>Shadow Transmit Holding Register</description>
          <addressOffset>0x6c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SHADOW_THR</name>
              <description>This is a shadow register for the THR.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_FAR</name>
          <description>FIFO Access Register</description>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FIFO_ACCESS_TEST_EN</name>
              <description>This register is use to enable a FIFO access mode for testing, so
that the receive FIFO can be written by the master and the
transmit FIFO can be read by the master when FIFOs are
implemented and enabled. When FIFOs are not enabled it allows
the RBR to be written by the master and the THR to be read by
the master.
0 = FIFO access mode disabled
1 = FIFO access mode enabled</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_TFR</name>
          <description>Transmit FIFO Read</description>
          <addressOffset>0x74</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TRANS_FIFO_READ</name>
              <description>Transmit FIFO Read.
These bits are only valid when FIFO access mode is enabled
(FAR[0] is set to one).When FIFOs are implemented and enabled,
reading this register gives the data at the top of the transmit
FIFO. Each consecutive read pops the transmit FIFO and gives
the next data value that is currently at the top of the FIFO.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_RFW</name>
          <description>Receive FIFO Write</description>
          <addressOffset>0x78</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RECEIVE_FIFO_FRAMING_ERROR</name>
              <description>Receive FIFO Framing Error.
These bits are only valid when FIFO access mode is enabled
(FAR[0] is set to one).</description>
              <bitRange>[9:9]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>RECEIVE_FIFO_PARITY_ERROR</name>
              <description>Receive FIFO Parity Error.
These bits are only valid when FIFO access mode is enabled
(FAR[0] is set to one).</description>
              <bitRange>[8:8]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>RECEIVE_FIFO_WRITE</name>
              <description>Receive FIFO Write Data.
These bits are only valid when FIFO access mode is enabled
(FAR[0] is set to one).
When FIFOs are enabled, the data that is written to the RFWD is
pushed into the receive FIFO. Each consecutive write pushes the
new data to the next write location in the receive FIFO.
When FIFOs not enabled, the data that is written to the RFWD is
pushed into the RBR.</description>
              <bitRange>[7:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_USR</name>
          <description>UART Status Register</description>
          <addressOffset>0x7c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RECEIVE_FIFO_FULL</name>
              <description>Receive FIFO Full.
This is used to indicate that the receive FIFO is completely full.
0 = Receive FIFO not full
1 = Receive FIFO Full
This bit is cleared when the RX FIFO is no longer full.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RECEIVE_FIFO_NOT_EMPTY</name>
              <description>Receive FIFO Not Empty.
This is used to indicate that the receive FIFO contains one or
more entries.
0 = Receive FIFO is empty
1 = Receive FIFO is not empty
This bit is cleared when the RX FIFO is empty.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TRASN_FIFO_EMPTY</name>
              <description>Transmit FIFO Empty.
This is used to indicate that the transmit FIFO is completely
empty.
0 = Transmit FIFO is not empty
1 = Transmit FIFO is empty
This bit is cleared when the TX FIFO is no longer empty</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TRANS_FIFO_NOT_FULL</name>
              <description>Transmit FIFO Not Full.
This is used to indicate that the transmit FIFO in not full.
0 = Transmit FIFO is full
1 = Transmit FIFO is not full
This bit is cleared when the TX FIFO is full.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UART_BUSY</name>
              <description>UART Busy.
UART Busy. This is indicates that a serial transfer is in progress,
when cleared indicates that the UART is idle or inactive.
0 = UART is idle or inactive
1 = UART is busy (actively transferring data)</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_TFL</name>
          <description>Transmit FIFO Level</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TRANS_FIFO_LEVEL</name>
              <description>Transmit FIFO Level.
This is indicates the number
of data entries in the transmit FIFO.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_RFL</name>
          <description>Receive FIFO Level</description>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RECEIVE_FIFO_LEVEL</name>
              <description>Receive FIFO Level.
This is indicates the number of data entries in the receive FIFO.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_SRR</name>
          <description>Software Reset Register</description>
          <addressOffset>0x88</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>XMIT_FIFO_RESET</name>
              <description>XMIT FIFO Reset.
This is a shadow register for the XMIT FIFO Reset bit (FCR[2]).</description>
              <bitRange>[2:2]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>RCVR_FIFO_RESET</name>
              <description>RCVR FIFO Reset.
This is a shadow register for the RCVR FIFO Reset bit (FCR[1]).</description>
              <bitRange>[1:1]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>UART_RESET</name>
              <description>UART Reset.
This asynchronously resets the UART and synchronously removes
the reset assertion. For a two clock implementation both pclk and
sclk domains are reset.</description>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_SRTS</name>
          <description>Shadow Request to Send</description>
          <addressOffset>0x8c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SHADOW_REQ_TO_SEND</name>
              <description>Shadow Request to Send.
This is a shadow register for the RTS bit (MCR[1]), this can be
used to remove the burden of having to performing a read-
modify-write on the MCR.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_SBCR</name>
          <description>Shadow Break Control Register</description>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SHADOW_BREAK_CTRL</name>
              <description>Shadow Break Control Bit.
This is a shadow register for the Break bit (LCR[6]), this can be
used to remove the burden of having to performing a read modify
write on the LCR.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_SDMAM</name>
          <description>Shadow DMA Mode</description>
          <addressOffset>0x94</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SHADOW_DMA_MODE</name>
              <description>Shadow DMA Mode.
This is a shadow register for the DMA mode bit (FCR[3]).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_SFE</name>
          <description>Shadow FIFO Enable</description>
          <addressOffset>0x98</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SHADOW_FIFO_EN</name>
              <description>Shadow FIFO Enable.
Shadow FIFO Enable. This is a shadow register for the FIFO
enable bit (FCR[0]).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_SRT</name>
          <description>Shadow RCVR Trigger</description>
          <addressOffset>0x9c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SHADOW_RCVR_TRIGGER</name>
              <description>Shadow RCVR Trigger.
This is a shadow register for the RCVR trigger bits (FCR[7:6]).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_STET</name>
          <description>Shadow TX Empty Trigger</description>
          <addressOffset>0xa0</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SHADOW_TX_EMPTY_TRIGGER</name>
              <description>Shadow TX Empty Trigger.
This is a shadow register for the TX empty trigger bits
(FCR[5:4]).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_HTX</name>
          <description>Halt TX</description>
          <addressOffset>0xa4</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HALT_TX_EN</name>
              <description>This register is use to halt transmissions for testing, so that the
transmit FIFO can be filled by the master when FIFOs are
implemented and enabled.
0 = Halt TX disabled
1 = Halt TX enabled</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_DMASA</name>
          <description>DMA Software Acknowledge</description>
          <addressOffset>0xa8</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMA_SOFTWARE_ACK</name>
              <description>This register is use to perform a DMA software acknowledge if a
transfer needs to be terminated due to an error condition.</description>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_CPR</name>
          <description>Component Parameter Register

Component Parameter Register
UART_CPR is UART0&#8217;s own unique register </description>
          <addressOffset>0xf4</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FIFO_MODE</name>
              <description>0x00 = 0
0x01 = 16
0x02 = 32
to
0x80 = 2048
0x81- 0xff = reserved</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DMA_EXTRA</name>
              <description>0 = FALSE
1 = TRUE</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UART_ADD_ENCODED_PARAMS</name>
              <description>0 = FALSE
1 = TRUE</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SHADOW</name>
              <description>0 = FALSE
1 = TRUE</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FIFO_STAT</name>
              <description>0 = FALSE
1 = TRUE</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FIFO_ACCESS</name>
              <description>0 = FALSE
1 = TRUE</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NEW_FEAT</name>
              <description>0 = FALSE
1 = TRUE</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SIR_LP_MODE</name>
              <description>0 = FALSE
1 = TRUE</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SIR_MODE</name>
              <description>0 = FALSE
1 = TRUE</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>THRE_MODE</name>
              <description>0 = FALSE
1 = TRUE</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>AFCE_MODE</name>
              <description>0 = FALSE
1 = TRUE</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>APB_DATA_WIDTH</name>
              <description>00 = 8 bits
01 = 16 bits
10 = 32 bits
11 = reserved</description>
              <bitRange>[1:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_UCV</name>
          <description>UART Component Version</description>
          <addressOffset>0xf8</addressOffset>
          <size>32</size>
          <resetValue>0x330372a</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VER</name>
              <description>ASCII value for each number in the version</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_CTR</name>
          <description>Component Type Register</description>
          <addressOffset>0xfc</addressOffset>
          <size>32</size>
          <resetValue>0x44570110</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PERIPHERAL_ID</name>
              <description>This register contains the peripherals identification code.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="UART0">
      <name>UART1</name>
      <version>1.0</version>
      <groupname>UART</groupname>
      <baseAddress>0xff190000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="UART0">
      <name>UART2</name>
      <version>1.0</version>
      <groupname>UART</groupname>
      <baseAddress>0xff1a0000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="UART0">
      <name>UART3</name>
      <version>1.0</version>
      <groupname>UART</groupname>
      <baseAddress>0xff1b0000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="UART0">
      <name>UART4</name>
      <version>1.0</version>
      <groupname>UART</groupname>
      <baseAddress>0xff370000</baseAddress>
    </peripheral>
    <peripheral>
      <name>EFUSE0</name>
      <version>1.0</version>
      <groupname>EFUSE</groupname>
      <baseAddress>0xff690000</baseAddress>
      <registers>
        <register>
          <name>EFUSE_CTRL</name>
          <description>efuse control register/eFuse control register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EFUSE_ADDR</name>
              <description>efuse address pins :A[9:0]</description>
              <bitRange>[25:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EFUSE_STROBE_SFT_SEL</name>
              <description>efuse strobe control software mode select, active high</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EFUSE_RWL</name>
              <description>efuse redundancy information row select (active high) : RWL</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EFUSE_RSB</name>
              <description>efuse redundancy enable(active low) : RSB</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EFUSE_MR</name>
              <description>efuse read trip point setting, MR = L for normal read mode; MR =
H for margin read1
mode : MR</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EFUSE_PD</name>
              <description>efuse power down enable (active high) : PD</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EFUSE_PS</name>
              <description>efuse pass 1.8V program voltage to internal for program(active
high) : PS</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EFUSE_PGENB</name>
              <description>efuse program enable (active low) : PGENB</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EFUSE_LOAD</name>
              <description>efuse turn on sense amplifier and load data into latch (active
high) : LOAD</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EFUSE_STROBE</name>
              <description>efuse turn on the array for read or program access (active high) :
STROBE</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EFUSE_CSB</name>
              <description>efuse chip select enable signal, active low : CSB</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EFUSE_DOUT</name>
          <description>efuse data out register/eFuse data out register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EFUSE_DOUT</name>
              <description>eFuse data output</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EFUSE_RF</name>
          <description>efuse redundancy bit used indicator register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EFUSE_RF_R</name>
              <description>efuse redundancy bit used indicator register for RF3~RF0, Output
high once the redundancy bit has been used.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EFUSE_JTAG_PASSWD</name>
          <description>Jtag password/eFuse jtag passwd register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0xcf7680a</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>JTAG_PASSWD</name>
              <description>Jtag password for jtag monitor</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EFUSE_STROBE_FINISH_CTRL</name>
          <description>efuse strobe finish control register/eFuse jtag passwd register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x9003</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EFUSE_STROBE_FINISH_PRG</name>
              <description>efuse read strobe finish control in hardware mode.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EFUSE_STROBE_FINISH_READ</name>
              <description>efuse program strobe finish control in hardware mode.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="EFUSE0">
      <name>EFUSE1</name>
      <version>1.0</version>
      <groupname>EFUSE</groupname>
      <baseAddress>0xfffa0000</baseAddress>
    </peripheral>
    <peripheral>
      <name>MAILBOX1</name>
      <version>1.0</version>
      <groupname>MAILBOX</groupname>
      <baseAddress>0xff390000</baseAddress>
      <registers>
        <register>
          <name>MAILBOX_A2B_INTEN</name>
          <description>Cortex-A53/Cortex-A72 to Cortex-M0 interrupt enable register/Cortex-A53/Cortex-A72 to MCU interrupt enable register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INT3</name>
              <description>interrupt enable for int3</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT2</name>
              <description>interrupt enable for int2</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT1</name>
              <description>interrupt enable for int1</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT0</name>
              <description>interrupt enable for int0</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MAILBOX_A2B_STATUS</name>
          <description>Cortex-A53/Cortex-A72 to Cortex-M0 interrupt status register/Cortex-A53/Cortex-A72 to MCU interrupt status register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INT3</name>
              <description>interrupt status for int3.
when writte 1, int is cleared.
</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT2</name>
              <description>interrupt status for int2.
when writte 1, int is cleared.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT1</name>
              <description>interrupt status for int1.
when writte 1, int is cleared.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT0</name>
              <description>interrupt status for int0.
when writte 1, int is cleared.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MAILBOX_A2B_CMD_0</name>
          <description>Cortex-A53/Cortex-A72 to Cortex-M0 command 0/Cortex-A53/Cortex-A72 to MCU command 0</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COMMAND</name>
              <description>command of Cortex-A53/Cortex-A72 to
Cortex-M0</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MAILBOX_A2B_DAT_0</name>
          <description>Cortex-A53/Cortex-A72 to Cortex-M0 data 0/Cortex-A53/Cortex-A72 to MCU data 0</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>data of Cortex-A53/Cortex-A72 to Cortex-M0</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MAILBOX_A2B_CMD_1</name>
          <description>Cortex-A53/Cortex-A72 to Cortex-M0 command 1/Cortex-A53/Cortex-A72 to MCU command 1</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COMMAND</name>
              <description>command of Cortex-A53/Cortex-A72 to
Cortex-M0</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MAILBOX_A2B_DAT_1</name>
          <description>Cortex-A53/Cortex-A72 to Cortex-M0 data 1/Cortex-A53/Cortex-A72 to MCU data 1</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>data of Cortex-A53/Cortex-A72 to Cortex-M0</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MAILBOX_A2B_CMD_2</name>
          <description>Cortex-A53/Cortex-A72 to Cortex-M0 command 2/Cortex-A53/Cortex-A72 to MCU command 2</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COMMAND</name>
              <description>command of Cortex-A53/Cortex-A72 to
Cortex-M0</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MAILBOX_A2B_DAT_2</name>
          <description>Cortex-A53/Cortex-A72 to Cortex-M0 data 2/Cortex-A53/Cortex-A72 to MCU data 2</description>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>data of Cortex-A53/Cortex-A72 to Cortex-M0</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MAILBOX_A2B_CMD_3</name>
          <description>Cortex-A53/Cortex-A72 to Cortex-M0 command 3/Cortex-A53/Cortex-A72 to MCU command 3</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COMMAND</name>
              <description>command of Cortex-A53/Cortex-A72 to
Cortex-M0</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MAILBOX_A2B_DAT_3</name>
          <description>Cortex-A53/Cortex-A72 to Cortex-M0 data 3/Cortex-A53/Cortex-A72 to MCU data 3</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>data of Cortex-A53/Cortex-A72 to Cortex-M0</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MAILBOX_B2A_INTEN</name>
          <description>Cortex-A53/Cortex-A72 to Cortex-M0 interrupt enable register/Cortex-A53/Cortex-A72 to MCU interrupt enable register</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INT3</name>
              <description>interrupt enable for int3</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT2</name>
              <description>interrupt enable for int2</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT1</name>
              <description>interrupt enable for int1</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT0</name>
              <description>interrupt enable for int0</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MAILBOX_B2A_STATUS</name>
          <description>Cortex-M0 to Cortex-A53/Cortex-A72 interrupt status register/MCU to Cortex-A53/Cortex-A72 interrupt status register</description>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INT3</name>
              <description>interrupt status for int3.
when writte 1, int is cleared.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT2</name>
              <description>interrupt status for int2.
when writte 1, int is cleared.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT1</name>
              <description>interrupt status for int1.
when writte 1, int is cleared.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT0</name>
              <description>interrupt status for int0.
when writte 1, int is cleared.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MAILBOX_B2A_CMD_0</name>
          <description>Cortex-M0 to Cortex-A53/Cortex-A72 command 0/MCU to Cortex-A53/Cortex-A72 command 0</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COMMAND</name>
              <description>command of MCU to Cortex-A53/Cortex-A72</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MAILBOX_B2A_DAT_0</name>
          <description>Cortex-M0 to Cortex-A53/Cortex-A72 data 0/MCU to Cortex-A53/Cortex-A72 data 0</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>data of MCU to Cortex-A53/Cortex-A72</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MAILBOX_B2A_CMD_1</name>
          <description>Cortex-M0 to Cortex-A53/Cortex-A72 command 1/MCU to Cortex-A53/Cortex-A72 command 1</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COMMAND</name>
              <description>command of MCU to Cortex-A53/Cortex-A72</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MAILBOX_B2A_DAT_1</name>
          <description>Cortex-M0 to Cortex-A53/Cortex-A72 data 1/MCU to Cortex-A53/Cortex-A72 data 1</description>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>data of MCU to Cortex-A53/Cortex-A72</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MAILBOX_B2A_CMD_2</name>
          <description>Cortex-M0 to Cortex-A53/Cortex-A72 command 2/MCU to Cortex-A53/Cortex-A72 command 2</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COMMAND</name>
              <description>command of Cortex-M0 to
Cortex-A53/Cortex-A72</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MAILBOX_B2A_DAT_2</name>
          <description>Cortex-M0 to Cortex-A53/Cortex-A72 data 2/MCU to Cortex-A53/Cortex-A72 data 2</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>data of Cortex-M0 to Cortex-A53/Cortex-A72</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MAILBOX_B2A_CMD_3</name>
          <description>Cortex-M0 to Cortex-A53/Cortex-A72 command 3/MCU to Cortex-A53/Cortex-A72 command 3</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COMMAND</name>
              <description>command of Cortex-M0 to
Cortex-A53/Cortex-A72</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MAILBOX_B2A_DAT_3</name>
          <description>Cortex-M0 to Cortex-A53/Cortex-A72 data 3/MCU to Cortex-A53/Cortex-A72 data 3</description>
          <addressOffset>0x4c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>data of Cortex-M0 to Cortex-A53/Cortex-A72</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MAILBOX_ATOMIC_LOCK_00</name>
          <description>Lock flag register 00</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ATOMIC_LOCK_00</name>
              <description>lock flag bit 00</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MAILBOX_ATOMIC_LOCK_01</name>
          <description>Lock flag register 01</description>
          <addressOffset>0x104</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ATOMIC_LOCK_01</name>
              <description>lock flag bit 01</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MAILBOX_ATOMIC_LOCK_02</name>
          <description>Lock flag register 02</description>
          <addressOffset>0x108</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ATOMIC_LOCK_02</name>
              <description>lock flag bit 02</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MAILBOX_ATOMIC_LOCK_03</name>
          <description>Lock flag register 03</description>
          <addressOffset>0x10c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ATOMIC_LOCK_03</name>
              <description>lock flag bit 03</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MAILBOX_ATOMIC_LOCK_04</name>
          <description>Lock flag register 04</description>
          <addressOffset>0x110</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ATOMIC_LOCK_04</name>
              <description>lock flag bit 04</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MAILBOX_ATOMIC_LOCK_05</name>
          <description>Lock flag register 05</description>
          <addressOffset>0x114</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ATOMIC_LOCK_05</name>
              <description>lock flag bit 05</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MAILBOX_ATOMIC_LOCK_06</name>
          <description>Lock flag register 06</description>
          <addressOffset>0x118</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ATOMIC_LOCK_06</name>
              <description>lock flag bit 06</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MAILBOX_ATOMIC_LOCK_07</name>
          <description>Lock flag register 07</description>
          <addressOffset>0x11c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ATOMIC_LOCK_07</name>
              <description>lock flag bit 07</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MAILBOX_ATOMIC_LOCK_08</name>
          <description>Lock flag register 08</description>
          <addressOffset>0x120</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ATOMIC_LOCK_08</name>
              <description>lock flag bit 08</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MAILBOX_ATOMIC_LOCK_09</name>
          <description>Lock flag register 09</description>
          <addressOffset>0x124</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ATOMIC_LOCK_09</name>
              <description>lock flag bit 09</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MAILBOX_ATOMIC_LOCK_10</name>
          <description>Lock flag register 10</description>
          <addressOffset>0x128</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ATOMIC_LOCK_10</name>
              <description>lock flag bit 10</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MAILBOX_ATOMIC_LOCK_11</name>
          <description>Lock flag register 11</description>
          <addressOffset>0x12c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ATOMIC_LOCK_11</name>
              <description>lock flag bit 11</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MAILBOX_ATOMIC_LOCK_12</name>
          <description>Lock flag register 12</description>
          <addressOffset>0x130</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ATOMIC_LOCK_12</name>
              <description>lock flag bit 12</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MAILBOX_ATOMIC_LOCK_13</name>
          <description>Lock flag register 13</description>
          <addressOffset>0x134</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ATOMIC_LOCK_13</name>
              <description>lock flag bit 13</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MAILBOX_ATOMIC_LOCK_14</name>
          <description>Lock flag register 14</description>
          <addressOffset>0x138</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ATOMIC_LOCK_14</name>
              <description>lock flag bit 14</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MAILBOX_ATOMIC_LOCK_15</name>
          <description>Lock flag register 15</description>
          <addressOffset>0x13c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ATOMIC_LOCK_15</name>
              <description>lock flag bit 15</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MAILBOX_ATOMIC_LOCK_16</name>
          <description>Lock flag register 16</description>
          <addressOffset>0x140</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ATOMIC_LOCK_16</name>
              <description>lock flag bit 16</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MAILBOX_ATOMIC_LOCK_17</name>
          <description>Lock flag register 17</description>
          <addressOffset>0x144</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ATOMIC_LOCK_17</name>
              <description>lock flag bit 17</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MAILBOX_ATOMIC_LOCK_18</name>
          <description>Lock flag register 18</description>
          <addressOffset>0x148</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ATOMIC_LOCK_18</name>
              <description>lock flag bit 18</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MAILBOX_ATOMIC_LOCK_19</name>
          <description>Lock flag register 19</description>
          <addressOffset>0x14c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ATOMIC_LOCK_19</name>
              <description>lock flag bit 19</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MAILBOX_ATOMIC_LOCK_20</name>
          <description>Lock flag register 20</description>
          <addressOffset>0x150</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ATOMIC_LOCK_20</name>
              <description>lock flag bit 20</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MAILBOX_ATOMIC_LOCK_21</name>
          <description>Lock flag register 21</description>
          <addressOffset>0x154</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ATOMIC_LOCK_21</name>
              <description>lock flag bit 21</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MAILBOX_ATOMIC_LOCK_22</name>
          <description>Lock flag register 22</description>
          <addressOffset>0x158</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ATOMIC_LOCK_22</name>
              <description>lock flag bit 22</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MAILBOX_ATOMIC_LOCK_23</name>
          <description>Lock flag register 23</description>
          <addressOffset>0x15c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ATOMIC_LOCK_23</name>
              <description>lock flag bit 23</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MAILBOX_ATOMIC_LOCK_24</name>
          <description>Lock flag register 24</description>
          <addressOffset>0x160</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ATOMIC_LOCK_24</name>
              <description>lock flag bit 24</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MAILBOX_ATOMIC_LOCK_25</name>
          <description>Lock flag register 25</description>
          <addressOffset>0x164</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ATOMIC_LOCK_25</name>
              <description>lock flag bit 25</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MAILBOX_ATOMIC_LOCK_26</name>
          <description>Lock flag register 26</description>
          <addressOffset>0x168</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ATOMIC_LOCK_26</name>
              <description>lock flag bit 26</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MAILBOX_ATOMIC_LOCK_27</name>
          <description>Lock flag register 27</description>
          <addressOffset>0x16c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ATOMIC_LOCK_27</name>
              <description>lock flag bit 27</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MAILBOX_ATOMIC_LOCK_28</name>
          <description>Lock flag register 28</description>
          <addressOffset>0x170</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ATOMIC_LOCK_28</name>
              <description>lock flag bit 28</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MAILBOX_ATOMIC_LOCK_29</name>
          <description>Lock flag register 29</description>
          <addressOffset>0x174</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ATOMIC_LOCK_29</name>
              <description>lock flag bit 29</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MAILBOX_ATOMIC_LOCK_30</name>
          <description>Lock flag register 30</description>
          <addressOffset>0x178</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ATOMIC_LOCK_30</name>
              <description>lock flag bit 30</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MAILBOX_ATOMIC_LOCK_31</name>
          <description>Lock flag register 31</description>
          <addressOffset>0x17c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ATOMIC_LOCK_31</name>
              <description>lock flag bit 31</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="MAILBOX1">
      <name>MAILBOX0</name>
      <version>1.0</version>
      <groupname>MAILBOX</groupname>
      <baseAddress>0xff6b0000</baseAddress>
    </peripheral>
    <peripheral>
      <name>SPI0</name>
      <version>1.0</version>
      <groupname>SPI</groupname>
      <baseAddress>0xff1c0000</baseAddress>
      <registers>
        <register>
          <name>SPI_CTRLR0</name>
          <description>Control Register 0</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x2</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MTM</name>
              <description>Microwire Transfer Mode
Valid when frame format is set to National Semiconductors
Microwire.
1'b0: non-sequential transfer
1'b1: sequential transfer</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OPM</name>
              <description>Operation Mode
1'b0: Master Mode
1'b1: Slave Mode</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>XFM</name>
              <description>Transfer Mode
2'b00 :Transmit &amp; Receive
2'b01 : Transmit Only
2'b10 : Receive Only
2'b11 :reserved</description>
              <bitRange>[19:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FRF</name>
              <description>Frame Format
2'b00: Motorola SPI
2'b01: Texas Instruments SSP
2'b10: National Semiconductors Microwire
2'b11 : Reserved</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSD</name>
              <description>Rxd Sample Delay
When SPI is configured as a master, if the rxd data cannot be
sampled by the sclk_out edge at the right time, this register
should be configured to define the number of the spi_clk cycles
after the active sclk_out edge to sample rxd data later when SPI
works at high frequency.
2'b00:do not delay
2'b01:1 cycle delay
2'b10:2 cycles delay
2'b11:3 cycles delay</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BHT</name>
              <description>Byte and Halfword Transform
Valid when data frame size is 8bit.
1'b0:apb 16bit write/read, spi 8bit write/read
1'b1: apb 8bit write/read, spi 8bit write/read</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FBM</name>
              <description>First Bit Mode
1'b0:first bit is MSB
1'b1:first bit is LSB</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EM</name>
              <description>Endian Mode
Serial endian mode can be configured by this bit. Apb endian
mode is always little endian.
1'b0:little endian
1'b1:big endian</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSD</name>
              <description>ss_n to sclk_out delay
Valid when the frame format is set to Motorola SPI and SPI used
as a master.
1'b0: the period between ss_n active and sclk_out active is half
sclk_out cycles.
1'b1: the period between ss_n active and sclk_out active is one
sclk_out cycle.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CSM</name>
              <description>Chip Select Mode
Valid when the frame format is set to Motorola SPI and SPI used
as a master.
2'b00: ss_n keep low after every frame data is transferred.
2'b01:ss_n be high for half sclk_out cycles after every frame data
is transferred.
2'b10: ss_n be high for one sclk_out cycle after every frame data
is transferred.
2'b11:reserved</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCPOL</name>
              <description>Serial Clock Polarity
Valid when the frame format is set to Motorola SPI.
1'b0: Inactive state of serial clock is low
1'b1: Inactive state of serial clock is high</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCPH</name>
              <description>Serial Clock Phase
Valid when the frame format is set to Motorola SPI.
1'b0: Serial clock toggles in middle of first data bit
1'b1: Serial clock toggles at start of first data bit</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CFS</name>
              <description>Control Frame Size
Selects the length of the control word for the Microwire frame
format.
4'b0000~0010:reserved
4'b0011:4-bit serial data transfer
4'b0100:5-bit serial data transfer
4'b0101:6-bit serial data transfer
4'b0110:7-bit serial data transfer
4'b0111:8-bit serial data transfer
4'b1000:9-bit serial data transfer
4'b1001:10-bit serial data transfer
4'b1010:11-bit serial data transfer
4'b1011:12-bit serial data transfer
4'b1100:13-bit serial data transfer
4'b1101:14-bit serial data transfer
4'b1110:15-bit serial data transfer
4'b1111:16-bit serial data transfer</description>
              <bitRange>[5:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DFS</name>
              <description>Data Frame Size
Selects the data frame length.
2'b00:4bit data
2'b01:8bit data
2'b10:16bit data
2'b11:reserved</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_CTRLR1</name>
          <description>Control Register 1</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NDM</name>
              <description>Number of Data Frames
When Transfer Mode is receive only, this register field sets the
number of data frames to be continuously received by the SPI.
The SPI continues to receive serial data until the number of data
frames received is equal to this register value plus 1, which
enables you to receive up to 64 KB of data in a continuous
transfer.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_ENR</name>
          <description>SPI Enable</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ENR</name>
              <description>SPI Enable
1&#8217;b1: Enable all SPI operations.
1&#8217;b0: Disable all SPI operations
Transmit and receive FIFO buffers are cleared when the device is
disabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_SER</name>
          <description>Slave Enable Register</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SER1</name>
              <description>Slave 1 Select Enable
1&#8217;b1: Enable chip select 1
1&#8217;b0: Disable chip select 1
This register is valid only when SPI is configured as a master
device.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SER0</name>
              <description>Slave Select Enable
1&#8217;b1: Enable chip select 0
1&#8217;b0: Disable chip select 0
This register is valid only when SPI is configured as a master
device.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_BAUDR</name>
          <description>Baud Rate Select</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BAUDR</name>
              <description>Baud Rate Select
SPI Clock Divider.
This register is valid only when the SPI is configured as a master
device.
The LSB for this field is always set to 0 and is unaffected by a
write operation, which ensures an even value is held in this
register.
If the value is 0, the serial output clock (sclk_out) is disabled.
The frequency of the sclk_out is derived from the following
equation:
Fsclk_out = Fspi_clk/ SCKDV
Where SCKDV is any even value between 2 and 65534.
For example:
for Fspi_clk = 3.6864MHz and SCKDV =2
Fsclk_out = 3.6864/2= 1.8432MHz</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_TXFTLR</name>
          <description>Transmit FIFO Threshold Level</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXFTLR</name>
              <description>Transmit FIFO Threshold Level
When the number of transmit FIFO entries is less than or equal to
this value, the transmit FIFO empty interrupt is triggered.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_RXFTLR</name>
          <description>Receive FIFO Threshold Level</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXFTLR</name>
              <description>Receive FIFO Threshold Level
When the number of receive FIFO entries is greater than or equal
to this value + 1, the receive FIFO full interrupt is triggered.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_TXFLR</name>
          <description>Transmit FIFO Level</description>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXFLR</name>
              <description>Transmit FIFO Level
Contains the number of valid data entries in the transmit FIFO.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_RXFLR</name>
          <description>Receive FIFO Level</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXFLR</name>
              <description>Receive FIFO Level
Contains the number of valid data entries in the receive FIFO.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_SR</name>
          <description>SPI Status</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0xc</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RFF</name>
              <description>Receive FIFO Full
1'b0: Receive FIFO is not full
1'b1: Receive FIFO is full</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RFE</name>
              <description>Receive FIFO Empty
1'b0: Receive FIFO is not empty
1'b1: Receive FIFO is empty</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TFE</name>
              <description>Transmit FIFO Empty
1'b0: Transmit FIFO is not empty
1'b1: Transmit FIFO is empty</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TFF</name>
              <description>Transmit FIFO Full
1'b0: Transmit FIFO is not full
1'b1: Transmit FIFO is full</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BSF</name>
              <description>SPI Busy Flag
When set, indicates that a serial transfer is in progress; when
cleared indicates that the SPI is idle or disabled.
1'b0: SPI is idle or disabled
1'b1: SPI is actively transferring data</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_IPR</name>
          <description>Interrupt Polarity</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IPR</name>
              <description>Interrupt Polarity
Interrupt Polarity Register
1'b0:Active Interrupt Polarity Level is HIGH
1'b1: Active Interrupt Polarity Level is LOW</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_IMR</name>
          <description>Interrupt Mask</description>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RFFIM</name>
              <description>Receive FIFO Full Interrupt Mask
1'b0: spi_rxf_intr interrupt is masked
1'b1: spi_rxf_intr interrupt is not masked</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RFOIM</name>
              <description>Receive FIFO Overflow Interrupt Mask
1'b0: spi_rxo_intr interrupt is masked
1'b1: spi_rxo_intr interrupt is not masked</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RFUIM</name>
              <description>Receive FIFO Underflow Interrupt Mask
1'b0: spi_rxu_intr interrupt is masked
1'b1: spi_rxu_intr interrupt is not masked</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TFOIM</name>
              <description>Transmit FIFO Overflow Interrupt Mask
1'b0: spi_txo_intr interrupt is masked
1'b1: spi_txo_intr interrupt is not masked</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TFEIM</name>
              <description>Transmit FIFO Empty Interrupt Mask
1'b0: spi_txe_intr interrupt is masked
1'b1: spi_txe_intr interrupt is not masked</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_ISR</name>
          <description>Interrupt Status</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RFFIS</name>
              <description>Receive FIFO Full Interrupt Status
1'b0: spi_rxf_intr interrupt is not active after masking
1'b1: spi_rxf_intr interrupt is full after masking</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RFOIS</name>
              <description>Receive FIFO Overflow Interrupt Status
1'b0: spi_rxo_intr interrupt is not active after masking
1'b1: spi_rxo_intr interrupt is active after masking</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RFUIS</name>
              <description>Receive FIFO Underflow Interrupt Status
1'b0: spi_rxu_intr interrupt is not active after masking
1'b1: spi_rxu_intr interrupt is active after masking</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TFOIS</name>
              <description>Transmit FIFO Overflow Interrupt Status
1'b0: spi_txo_intr interrupt is not active after masking
1'b1: spi_txo_intr interrupt is active after masking</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TFEIS</name>
              <description>Transmit FIFO Empty Interrupt Status
1'b0: spi_txe_intr interrupt is not active after masking
1'b1: spi_txe_intr interrupt is active after masking</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_RISR</name>
          <description>Raw Interrupt Status</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <resetValue>0x1</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RFFRIS</name>
              <description>Receive FIFO Full Raw Interrupt Status
1'b0: spi_rxf_intr interrupt is not active prior to masking
1'b1: spi_rxf_intr interrupt is full prior to masking</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RFORIS</name>
              <description>Receive FIFO Overflow Raw Interrupt Status
1'b0 = spi_rxo_intr interrupt is not active prior to masking
1'b1 = spi_rxo_intr interrupt is active prior to masking</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RFURIS</name>
              <description>Receive FIFO Underflow Raw Interrupt Status
1'b0: spi_rxu_intr interrupt is not active prior to masking
1'b1: spi_rxu_intr interrupt is active prior to masking</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TFORIS</name>
              <description>Transmit FIFO Overflow Raw Interrupt Status
1'b0: spi_txo_intr interrupt is not active prior to masking
1'b1: spi_txo_intr interrupt is active prior to masking</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TFERIS</name>
              <description>Transmit FIFO Empty Raw Interrupt Status
1'b0: spi_txe_intr interrupt is not active prior to masking
1'b1: spi_txe_intr interrupt is active prior to masking</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_ICR</name>
          <description>Interrupt Clear</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CTFOI</name>
              <description>Clear Transmit FIFO Overflow Interrupt
Write 1 to Clear Transmit FIFO Overflow Interrupt</description>
              <bitRange>[3:3]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CRFOI</name>
              <description>Clear Receive FIFO Overflow Interrupt
Write 1 to Clear Receive FIFO Overflow Interrupt</description>
              <bitRange>[2:2]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CRFUI</name>
              <description>Clear Receive FIFO Underflow Interrupt
Write 1 to Clear Receive FIFO Underflow Interrupt</description>
              <bitRange>[1:1]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CCI</name>
              <description>Clear Combined Interrupt
Write 1 to Clear Combined Interrupt</description>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_DMACR</name>
          <description>DMA Control</description>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TDE</name>
              <description>Transmit DMA Enable
1'b0: Transmit DMA disabled
1'b1: Transmit DMA enabled</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RDE</name>
              <description>Receive DMA Enable
1'b0: Receive DMA disabled
1'b1: Receive DMA enabled</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_DMATDLR</name>
          <description>DMA Transmit Data Level</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TDL</name>
              <description>Transmit Data Level
This bit field controls the level at which a DMA request is made by
the transmit logic. It is equal to the watermark level; that is, the
dma_tx_req signal is generated when the number of valid data
entries in the transmit FIFO is equal to or below this field value,
and Transmit DMA Enable (DMACR[1]) = 1.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_DMARDLR</name>
          <description>DMA Receive Data Level</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDL</name>
              <description>Receive Data Level
This bit field controls the level at which a DMA request is made by
the receive logic. The watermark level = DMARDL+1; that is,
dma_rx_req is generated when the number of valid data entries
in the receive FIFO is equal to or above this field value + 1, and
Receive DMA Enable(DMACR[0])=1.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_TXDR</name>
          <description>Transmit FIFO Data</description>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXDR</name>
              <description>Transimt FIFO Data Register.
When it is written to, data are moved into the transmit FIFO.</description>
              <bitRange>[15:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_RXDR</name>
          <description>Receive FIFO Data</description>
          <addressOffset>0x800</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXDR</name>
              <description>Receive FIFO Data Register.
When the register is read, data in the receive FIFO is accessed.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="SPI0">
      <name>SPI1</name>
      <version>1.0</version>
      <groupname>SPI</groupname>
      <baseAddress>0xff1d0000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="SPI0">
      <name>SPI3</name>
      <version>1.0</version>
      <groupname>SPI</groupname>
      <baseAddress>0xff350000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="SPI0">
      <name>SPI2</name>
      <version>1.0</version>
      <groupname>SPI</groupname>
      <baseAddress>0xff1e0000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="SPI0">
      <name>SPI4</name>
      <version>1.0</version>
      <groupname>SPI</groupname>
      <baseAddress>0xff1f0000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="SPI0">
      <name>SPI5</name>
      <version>1.0</version>
      <groupname>SPI</groupname>
      <baseAddress>0xff200000</baseAddress>
    </peripheral>
    <peripheral>
      <name>SARADC</name>
      <version>1.0</version>
      <groupname>SARADC</groupname>
      <baseAddress>0xff100000</baseAddress>
      <registers>
        <register>
          <name>SARADC_DATA</name>
          <description>This register contains the data after A/D Conversion.</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADC_DATA</name>
              <description>A/D value of the last conversion (DOUT[9:0]).</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SARADC_STAS</name>
          <description>The status register of A/D Converter.</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADC_STATUS</name>
              <description>ADC status (EOC)
0: ADC stop
1: Conversion in progress</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SARADC_CTRL</name>
          <description>The control register of A/D Converter.</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INT_STATUS</name>
              <description>Interrupt status.
This bit will be set to 1 when end-of-conversion.
Set 0 to clear the interrupt.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT_EN</name>
              <description>Interrupt enable.
0: Disable
1: Enable</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_POWER_CTRL</name>
              <description>ADC power down control bit
0: ADC power down;
1: ADC power up and reset.
start signal will be asserted (DLY_PU_SOC + 2) sclk clock period
later after power up</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_INPUT_SRC_SEL</name>
              <description>ADC input source selection(CH_SEL[2:0]).
000 : Input source 0 (SARADC_AIN[0])
001 : Input source 1 (SARADC_AIN[1])
010 : Input source 2 (SARADC_AIN[2])
011 : Input source 3 (SARADC_AIN[3])
100 : Input source 4 (SARADC_AIN[4])
101 : Input source 5 (SARADC_AIN[5])
Others : Reserved</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SARADC_DLY_PU_SOC</name>
          <description>delay between power up and start command</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DLY_PU_SOC</name>
              <description>delay between power up and start command
The start signal will be asserted (DLY_PU_SOC + 2) sclk clock
period later after power up</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SARADC_DLY_PU_SOC0</name>
          <description>FIFO Register</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>POL</name>
              <description>Polarity
This bit indicates the polarity of the lower 31-bit counter.
0: Low
1: High</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CYCLE_CNT</name>
              <description>High/Low Cycle Counter
This 31-bit counter indicates the effective cycles of high/low
waveform.</description>
              <bitRange>[30:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SARADC_DLY_PU_SOC1</name>
          <description>FIFO Register</description>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>POL</name>
              <description>Polarity
This bit indicates the polarity of the lower 31-bit counter.
0: Low
1: High</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CYCLE_CNT</name>
              <description>High/Low Cycle Counter
This 31-bit counter indicates the effective cycles of high/low
waveform.</description>
              <bitRange>[30:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SARADC_DLY_PU_SOC2</name>
          <description>FIFO Register</description>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>POL</name>
              <description>Polarity
This bit indicates the polarity of the lower 31-bit counter.
0: Low
1: High</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CYCLE_CNT</name>
              <description>High/Low Cycle Counter
This 31-bit counter indicates the effective cycles of high/low
waveform.</description>
              <bitRange>[30:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SARADC_DLY_PU_SOC3</name>
          <description>FIFO Register</description>
          <addressOffset>0x6c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>POL</name>
              <description>Polarity
This bit indicates the polarity of the lower 31-bit counter.
0: Low
1: High</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CYCLE_CNT</name>
              <description>High/Low Cycle Counter
This 31-bit counter indicates the effective cycles of high/low
waveform.</description>
              <bitRange>[30:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SARADC_DLY_PU_SOC4</name>
          <description>FIFO Register</description>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>POL</name>
              <description>Polarity
This bit indicates the polarity of the lower 31-bit counter.
0: Low
1: High</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CYCLE_CNT</name>
              <description>High/Low Cycle Counter
This 31-bit counter indicates the effective cycles of high/low
waveform.</description>
              <bitRange>[30:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SARADC_DLY_PU_SOC5</name>
          <description>FIFO Register</description>
          <addressOffset>0x74</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>POL</name>
              <description>Polarity
This bit indicates the polarity of the lower 31-bit counter.
0: Low
1: High</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CYCLE_CNT</name>
              <description>High/Low Cycle Counter
This 31-bit counter indicates the effective cycles of high/low
waveform.</description>
              <bitRange>[30:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SARADC_DLY_PU_SOC6</name>
          <description>FIFO Register</description>
          <addressOffset>0x78</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>POL</name>
              <description>Polarity
This bit indicates the polarity of the lower 31-bit counter.
0: Low
1: High</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CYCLE_CNT</name>
              <description>High/Low Cycle Counter
This 31-bit counter indicates the effective cycles of high/low
waveform.</description>
              <bitRange>[30:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SARADC_DLY_PU_SOC7</name>
          <description>FIFO Register</description>
          <addressOffset>0x7c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>POL</name>
              <description>Polarity
This bit indicates the polarity of the lower 31-bit counter.
0: Low
1: High</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CYCLE_CNT</name>
              <description>High/Low Cycle Counter
This 31-bit counter indicates the effective cycles of high/low
waveform.</description>
              <bitRange>[30:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PI0</name>
      <version>1.0</version>
      <groupname>PI</groupname>
      <baseAddress>0xffa80800</baseAddress>
      <registers>
        <register>
          <name>PI_REG_0</name>
          <description>DDR PHY Independent Register 0</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>PI_REG_1</name>
          <description>DDR PHY Independent Register 1</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TCMP_GAP</name>
              <description>Indicates DRAM timing in DFI clock cycles. Specifies the minimum
gap between two commands. Used for guarding the timing from the
last command of DDR controller and the first command of PI when
DDR controller passes the control of the DFI bus to the PI.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_INIT_LVL_EN</name>
              <description>Enables the initial leveling sequence after PI initialization
procedure. Set to 1 to enable.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_NORMAL_LVL_SEQ</name>
              <description>Enables the PI strategy that PI must finish all the pending leveling
before it releases the DFI bus.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_2</name>
          <description>DDR PHY Independent Register 2</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TDFI_PHYMSTR_MAX_F0</name>
              <description>Defines the DFI tPHYMSTR_MAX timing parameter (in DFI clocks),
the maximum cycles that dfi_phymstr_req following the assertion
of dfi_phymstr_ack can be asserted. If programmed to a non-zero,
a timing violation causes an interrupt and bit0 set in the
PI_REG_22.pi_control_error_status parameter. The suffix f0 of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_3</name>
          <description>DDR PHY Independent Register 3</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TDFI_PHYMSTR_RESP_F0</name>
              <description>Defines the DFI tPHYMSTR_RESP timing parameter (in DFI clocks),
the maximum cycles between a dfi_phymstr_req assertion and a
dfi_phymstr_ack assertion. If programmed to a non-zero, a timing
violation causes an interrupt and bit1 set in the
PI_REG_22.pi_control_error_status parameter. The suffix f0 of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_4</name>
          <description>DDR PHY Independent Register 4</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TDFI_PHYMSTR_MAX_F1</name>
              <description>Defines the DFI tPHYMSTR_MAX timing parameter (in DFI clocks),
the maximum cycles that dfi_phymstr_req following the assertion
of dfi_phymstr_ack can be asserted. If programmed to a non-zero,
a timing violation causes an interrupt and bit0 set in the
PI_REG_22.pi_control_error_status parameter. The suffix f1 of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_5</name>
          <description>DDR PHY Independent Register 5</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TDFI_PHYMSTR_RESP_F1</name>
              <description>Defines the DFI tPHYMSTR_RESP timing parameter (in DFI clocks),
the maximum cycles between a dfi_phymstr_req assertion and a
dfi_phymstr_ack assertion. If programmed to a non-zero, a timing
violation causes an interrupt and bit1 set in the
PI_REG_22.pi_control_error_status parameter. The suffix f1 of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_6</name>
          <description>DDR PHY Independent Register 6</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TDFI_PHYMSTR_MAX_F2</name>
              <description>Defines the DFI tPHYMSTR_MAX timing parameter (in DFI clocks),
the maximum cycles that dfi_phymstr_req following the assertion
of dfi_phymstr_ack can be asserted. If programmed to a non-zero,
a timing violation causes an interrupt and bit0 set in the
PI_REG_22.pi_control_error_status parameter. The suffix f2 of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_7</name>
          <description>DDR PHY Independent Register 7</description>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TDFI_PHYUPD_RESP_F0</name>
              <description>Defines the DFI tPHYUPD_RESP timing parameter (in DFI clocks),
the maximum cycles between a dfi_phyupd_req assertion and a
dfi_phyupd_ack assertion. If programmed to a non-zero, a timing
violation causes an interrupt and bit8 set in the
PI_REG_193.pi_update_error_status parameter and bit8 set in the
PI_REG_22.pi_control_error_status parameter. The suffix f0 of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TDFI_PHYMSTR_RESP_F2</name>
              <description>Defines the DFI tPHYMSTR_RESP timing parameter (in DFI clocks),
the maximum cycles between a dfi_phymstr_req assertion and a
dfi_phymstr_ack assertion. If programmed to a non-zero, a timing
violation causes an interrupt and bit1 set in the
PI_REG_22.pi_control_error_status parameter. The suffix f2 of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_8</name>
          <description>DDR PHY Independent Register 8</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TDFI_PHYUPD_TYPE0_F0</name>
              <description>Defines the DFI tPHYUPD_TYPE0 timing parameter (in DFI clocks),
the maximum cycles that dfi_phyupd_req can assert after
dfi_phyupd_ack for dfi_phyupd_type 0. If programmed to a
non-zero, a timing violation causes an interrupt and bit4 set in the
PI_REG_193.pi_update_error_status parameter and bit4 set in the
PI_REG_22.pi_control_error_status parameter. The suffix f0 of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_9</name>
          <description>DDR PHY Independent Register 9</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TDFI_PHYUPD_TYPE1_F0</name>
              <description>Defines the DFI tPHYUPD_TYPE1 timing parameter (in DFI clocks),
the maximum cycles that dfi_phyupd_req can assert after
dfi_phyupd_ack for dfi_phyupd_type 1. If programmed to a
non-zero, a timing violation causes an interrupt and bit5 set in the
PI_REG_193.pi_update_error_status parameter and bit5 set in the
PI_REG_22.pi_control_error_status parameter. The suffix f0 of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_10</name>
          <description>DDR PHY Independent Register 10</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TDFI_PHYUPD_TYPE2_F0</name>
              <description>Defines the DFI tPHYUPD_TYPE2 timing parameter (in DFI clocks),
the maximum cycles that dfi_phyupd_req can assert after
dfi_phyupd_ack for dfi_phyupd_type 2. If programmed to a
non-zero, a timing violation causes an interrupt and bit6 set in the
PI_REG_193.pi_update_error_status parameter and bit6 set in the
PI_REG_22.pi_control_error_status parameter. The suffix f0 of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_11</name>
          <description>DDR PHY Independent Register 11</description>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TDFI_PHYUPD_TYPE3_F0</name>
              <description>Defines the DFI tPHYUPD_TYPE3 timing parameter (in DFI clocks),
the maximum cycles that dfi_phyupd_req can assert after
dfi_phyupd_ack for dfi_phyupd_type 3. If programmed to a
non-zero, a timing violation causes an interrupt and bit7 set in the
PI_REG_193.pi_update_error_status parameter and bit7 set in the
PI_REG_22.pi_control_error_status parameter. The suffix f0 of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_12</name>
          <description>DDR PHY Independent Register 12</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TDFI_PHYUPD_RESP_F1</name>
              <description>Defines the DFI tPHYUPD_RESP timing parameter (in DFI clocks),
the maximum cycles between a dfi_phyupd_req assertion and a
dfi_phyupd_ack assertion. If programmed to a non-zero, a timing
violation causes an interrupt and bit8 set in the
PI_REG_193.pi_update_error_status parameter and bit8 set in the
PI_REG_22.pi_control_error_status parameter. The suffix f1 of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_13</name>
          <description>DDR PHY Independent Register 13</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TDFI_PHYUPD_TYPE0_F1</name>
              <description>Defines the DFI tPHYUPD_TYPE0 timing parameter (in DFI clocks),
the maximum cycles that dfi_phyupd_req can assert after
dfi_phyupd_ack for dfi_phyupd_type 0. If programmed to a
non-zero, a timing violation causes an interrupt and bit4 set in the
PI_REG_193.pi_update_error_status parameter and bit4 set in the
PI_REG_22.pi_control_error_status parameter. The suffix f1 of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_14</name>
          <description>DDR PHY Independent Register 14</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TDFI_PHYUPD_TYPE1_F1</name>
              <description>Defines the DFI tPHYUPD_TYPE1 timing parameter (in DFI clocks),
the maximum cycles that dfi_phyupd_req can assert after
dfi_phyupd_ack for dfi_phyupd_type 1. If programmed to a
non-zero, a timing violation causes an interrupt and bit5 set in the
PI_REG_193.pi_update_error_status parameter and bit5 set in the
PI_REG_22.pi_control_error_status parameter. The suffix f1 of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_15</name>
          <description>DDR PHY Independent Register 15</description>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TDFI_PHYUPD_TYPE2_F1</name>
              <description>Defines the DFI tPHYUPD_TYPE2 timing parameter (in DFI clocks),
the maximum cycles that dfi_phyupd_req can assert after
dfi_phyupd_ack for dfi_phyupd_type 2. If programmed to a
non-zero, a timing violation causes an interrupt and bit6 set in the
PI_REG_193.pi_update_error_status parameter and bit6 set in the
PI_REG_22.pi_control_error_status parameter. The suffix f1 of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_16</name>
          <description>DDR PHY Independent Register 16</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TDFI_PHYUPD_TYPE3_F1</name>
              <description>Defines the DFI tPHYUPD_TYPE3 timing parameter (in DFI clocks),
the maximum cycles that dfi_phyupd_req can assert after
dfi_phyupd_ack for dfi_phyupd_type 3. If programmed to a
non-zero, a timing violation causes an interrupt and bit7 set in the
PI_REG_193.pi_update_error_status parameter and bit7 set in the
PI_REG_22.pi_control_error_status parameter. The suffix f1 of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_17</name>
          <description>DDR PHY Independent Register 17</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TDFI_PHYUPD_RESP_F2</name>
              <description>Defines the DFI tPHYUPD_RESP timing parameter (in DFI clocks),
the maximum cycles between a dfi_phyupd_req assertion and a
dfi_phyupd_ack assertion. If programmed to a non-zero, a timing
violation causes an interrupt and bit8 set in the
PI_REG_193.pi_update_error_status parameter and bit8 set in the
PI_REG_22.pi_control_error_status parameter. The suffix f2 of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_18</name>
          <description>DDR PHY Independent Register 18</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TDFI_PHYUPD_TYPE0_F2</name>
              <description>Defines the DFI tPHYUPD_TYPE0 timing parameter (in DFI clocks),
the maximum cycles that dfi_phyupd_req can assert after
dfi_phyupd_ack for dfi_phyupd_type 0. If programmed to a
non-zero, a timing violation causes an interrupt and bit4 set in the
PI_REG_193.pi_update_error_status parameter and bit4 set in the
PI_REG_22.pi_control_error_status parameter. The suffix f2 of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_19</name>
          <description>DDR PHY Independent Register 19</description>
          <addressOffset>0x4c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TDFI_PHYUPD_TYPE1_F2</name>
              <description>Defines the DFI tPHYUPD_TYPE1 timing parameter (in DFI clocks),
the maximum cycles that dfi_phyupd_req can assert after
dfi_phyupd_ack for dfi_phyupd_type 1. If programmed to a
non-zero, a timing violation causes an interrupt and bit5 set in the
PI_REG_193.pi_update_error_status parameter and bit5 set in the
PI_REG_22.pi_control_error_status parameter. The suffix f2 of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_20</name>
          <description>DDR PHY Independent Register 20</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TDFI_PHYUPD_TYPE2_F2</name>
              <description>Defines the DFI tPHYUPD_TYPE2 timing parameter (in DFI clocks),
the maximum cycles that dfi_phyupd_req can assert after
dfi_phyupd_ack for dfi_phyupd_type 2. If programmed to a
non-zero, a timing violation causes an interrupt and bit6 set in the
PI_REG_193.pi_update_error_status parameter and bit6 set in the
PI_REG_22.pi_control_error_status parameter. The suffix f2 of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_21</name>
          <description>DDR PHY Independent Register 21</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TDFI_PHYUPD_TYPE3_F2</name>
              <description>Defines the DFI tPHYUPD_TYPE3 timing parameter (in DFI clocks),
the maximum cycles that dfi_phyupd_req can assert after
dfi_phyupd_ack for dfi_phyupd_type 3. If programmed to a
non-zero, a timing violation causes an interrupt and bit7 set in the
PI_REG_193.pi_update_error_status parameter and bit7 set in the
PI_REG_22.pi_control_error_status parameter. The suffix f2 of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_22</name>
          <description>DDR PHY Independent Register 22</description>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <resetValue>0x10000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_EXIT_AFTER_INIT_CALVL</name>
              <description>Releases the DFI bus after complete initialization CA training and
requests DFI bus again for the remaining initialization training. The
DFI bus release is for the controller to issue MRW/ZQ after the PI
completes initialization CA leveling, based on the JEDEC protocol
requirement.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_CONTROL_ERROR_STATUS</name>
              <description>Identifies the source of any pi_control phyupd_req/
phylvl_req_cs_n errors. Value of 1 indicates a timing violation of
the associated timing parameter
Bit 8: pi_control triggered phyupd_resp_error.
Bit 7: pi_control triggered phyupd_type3_error.
Bit 6: pi_control triggered phyupd_type2_error.
Bit 5: pi_control triggered phyupd_type1_error.
Bit 4: pi_control triggered phyupd_type0_error.
Bit 3: phylvl_resp_error.
Bit 2: phylvl_max_error.
Bit 1: phymstr_resp_error.
Bit 0: phymstr_max_error.</description>
              <bitRange>[8:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_23</name>
          <description>DDR PHY Independent Register 23</description>
          <addressOffset>0x5c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_FREQ_MAP</name>
              <description>User indicates all the supported working frequencies. Each bit
represents one supported frequency.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_24</name>
          <description>DDR PHY Independent Register 24</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <resetValue>0x100</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_POWER_ON_SEQ_END_ARRAY</name>
              <description>Indicates the step that is the last step of the power-on sequence.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_POWER_ON_SEQ_BYPASS_ARRAY</name>
              <description>Indicates the bypassed steps of power on sequence.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_INIT_DFS_CALVL_ONLY</name>
              <description>Enables the initial leveling sequence loop that only CA training
executes DFS.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_INIT_WORK_FREQ</name>
              <description>Indicates the initial work frequency after initialization and initial
leveling sequence.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_25</name>
          <description>DDR PHY Independent Register 25</description>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_SEQ1_PAT</name>
              <description>Indicates user-defined power-on sequence 1.</description>
              <bitRange>[29:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_26</name>
          <description>DDR PHY Independent Register 26</description>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_SEQ1_PAT_MASK</name>
              <description>Indicates user-defined command mask for power-on sequence 1.</description>
              <bitRange>[29:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_27</name>
          <description>DDR PHY Independent Register 27</description>
          <addressOffset>0x6c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_SEQ2_PAT</name>
              <description>Indicates user-defined power-on sequence 2.</description>
              <bitRange>[29:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_28</name>
          <description>DDR PHY Independent Register 28</description>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_SEQ2_PAT_MASK</name>
              <description>Indicates user-defined command mask for power-on sequence 2.</description>
              <bitRange>[29:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_29</name>
          <description>DDR PHY Independent Register 29</description>
          <addressOffset>0x74</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_SEQ3_PAT</name>
              <description>Indicates user-defined power-on sequence 3.</description>
              <bitRange>[29:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_30</name>
          <description>DDR PHY Independent Register 30</description>
          <addressOffset>0x78</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_SEQ3_PAT_MASK</name>
              <description>Indicates user-defined command mask for power-on sequence 3.</description>
              <bitRange>[29:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_31</name>
          <description>DDR PHY Independent Register 31</description>
          <addressOffset>0x7c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_SEQ4_PAT</name>
              <description>Indicates user-defined power-on sequence 4.</description>
              <bitRange>[29:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_32</name>
          <description>DDR PHY Independent Register 32</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_SEQ4_PAT_MASK</name>
              <description>Indicates user-defined command mask for power-on sequence 4.</description>
              <bitRange>[29:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_33</name>
          <description>DDR PHY Independent Register 33</description>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_SEQ5_PAT</name>
              <description>Indicates user-defined power-on sequence 5.</description>
              <bitRange>[29:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_34</name>
          <description>DDR PHY Independent Register 34</description>
          <addressOffset>0x88</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_SEQ5_PAT_MASK</name>
              <description>Indicates user-defined command mask for power-on sequence 5.</description>
              <bitRange>[29:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_35</name>
          <description>DDR PHY Independent Register 35</description>
          <addressOffset>0x8c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_SEQ6_PAT</name>
              <description>Indicates user-defined power-on sequence 6.</description>
              <bitRange>[29:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_36</name>
          <description>DDR PHY Independent Register 36</description>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_SEQ6_PAT_MASK</name>
              <description>Indicates user-defined command mask for power-on sequence 6.</description>
              <bitRange>[29:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_37</name>
          <description>DDR PHY Independent Register 37</description>
          <addressOffset>0x94</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_SEQ7_PAT</name>
              <description>Indicates user-defined power-on sequence 7.</description>
              <bitRange>[29:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_38</name>
          <description>DDR PHY Independent Register 38</description>
          <addressOffset>0x98</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_SEQ7_PAT_MASK</name>
              <description>Indicates user-defined command mask for power-on sequence 7.</description>
              <bitRange>[29:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_39</name>
          <description>DDR PHY Independent Register 39</description>
          <addressOffset>0x9c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_SEQ8_PAT</name>
              <description>Indicates user-defined power-on sequence 8.</description>
              <bitRange>[29:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_40</name>
          <description>DDR PHY Independent Register 40</description>
          <addressOffset>0xa0</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_SEQ8_PAT_MASK</name>
              <description>Indicates user-defined command mask for power-on sequence 8.</description>
              <bitRange>[29:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_41</name>
          <description>DDR PHY Independent Register 41</description>
          <addressOffset>0xa4</addressOffset>
          <size>32</size>
          <resetValue>0x101</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_CS_MAP</name>
              <description>Defines the chip selects that are active.</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_SW_RST_N</name>
              <description>Indicates user request to reset the whole system except parameter
DFFs. Set 0 to reset, set to 1 to release.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_WDT_DISABLE</name>
              <description>Disables the watchdog caused by phymstr_req/phylvl_req_cs_n
response error. Set 1 to disable.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_42</name>
          <description>DDR PHY Independent Register 42</description>
          <addressOffset>0xa8</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TMRR</name>
              <description>Indicates DRAM TMRR value in cycles.</description>
              <bitRange>[27:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TDELAY_RDWR_2_BUS_IDLE_F2</name>
              <description>Indicates the delay from read or write to bus idle. Recommended
setting is delay time from read command that issued to the last
read data received. The suffix "_f2" of the parameter name is
omitted when in non-DFS mode.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TDELAY_RDWR_2_BUS_IDLE_F1</name>
              <description>Indicates the delay from read or write to bus idle. Recommended
setting is delay time from read command that issued to the last
read data received. The suffix "_f1" of the parameter name is
omitted when in non-DFS mode.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TDELAY_RDWR_2_BUS_IDLE_F0</name>
              <description>Indicates the delay from read or write to bus idle. Recommended
setting is delay time from read command that issued to the last
read data received. The suffix "_f0" of the parameter name is
omitted when in non-DFS mode.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_43</name>
          <description>DDR PHY Independent Register 43</description>
          <addressOffset>0xac</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_WRLAT_F1</name>
              <description>Indicates DRAM WRLAT value in cycles. The suffix "_f1" of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[28:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_CASLAT_LIN_F0</name>
              <description>Sets latency from read command send to data receive from/to
controller. Bit0 is half-cycle increment and the upper bits define
memory CAS latency for the controller. The suffix "_f0" of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[22:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_ADDITIVE_LAT_F0</name>
              <description>Indicates DRAM additive latency value in cycles. The suffix "_f0" of
the parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[13:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_WRLAT_F0</name>
              <description>Indicates DRAM WRLAT value in cycles. The suffix "_f0" of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_44</name>
          <description>DDR PHY Independent Register 44</description>
          <addressOffset>0xb0</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_ADDITIVE_LAT_F2</name>
              <description>Indicates DRAM additive latency value in cycles. The suffix "_f2" of
the parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[29:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_WRLAT_F2</name>
              <description>Indicates DRAM WRLAT value in cycles. The suffix "_f2" of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[20:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_CASLAT_LIN_F1</name>
              <description>Sets latency from read command send to data receive from/to
controller. Bit0 is half-cycle increment and the upper bits define
memory CAS latency for the controller. The suffix "_f1" of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[14:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_ADDITIVE_LAT_F1</name>
              <description>Indicates DRAM additive latency value in cycles. The suffix "_f1" of
the parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_45</name>
          <description>DDR PHY Independent Register 45</description>
          <addressOffset>0xb4</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_MCAREF_FORWARD_ONLY</name>
              <description>Pass mc auto refresh command to DRAM device, not generate
auto-refresh by PI. It is recommended to set to 1.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_AREFRESH</name>
              <description>Initiates auto-refresh at the end of the current burst boundary. Set
to 1 to trigger.</description>
              <bitRange>[16:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PI_PREAMBLE_SUPPORT</name>
              <description>Indicates selection of one or two-cycle preamble for read and write
burst transfers.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_CASLAT_LIN_F2</name>
              <description>Sets latency from read command send to data receive from/to
controller. Bit0 is half-cycle increment and the upper bits define
memory CAS latency for the controller. The suffix "_f2" of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_46</name>
          <description>DDR PHY Independent Register 46</description>
          <addressOffset>0xb8</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TREF_F0</name>
              <description>Indicates DRAM TREF value in cycles. The suffix "_f0" of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TRFC_F0</name>
              <description>Indicates DRAM TRFC value in cycles. The suffix "_f0" of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_47</name>
          <description>DDR PHY Independent Register 47</description>
          <addressOffset>0xbc</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TREF_F1</name>
              <description>Indicates DRAM TREF value in cycles. The suffix "_f1" of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TRFC_F1</name>
              <description>Indicates DRAM TRFC value in cycles. The suffix "_f1" of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_48</name>
          <description>DDR PHY Independent Register 48</description>
          <addressOffset>0xc0</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TREF_F2</name>
              <description>Indicates DRAM TREF value in cycles. The suffix "_f2" of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TRFC_F2</name>
              <description>Indicates DRAM TRFC value in cycles. The suffix "_f2" of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_49</name>
          <description>DDR PHY Independent Register 49</description>
          <addressOffset>0xc4</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_SWLVL_LOAD</name>
              <description>Indicates user request to load delays and execute software
leveling. Set to 1 to trigger.</description>
              <bitRange>[24:24]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PI_TREF_INTERVAL</name>
              <description>Defines the cycles between refreshes to different chip selects.</description>
              <bitRange>[23:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_50</name>
          <description>DDR PHY Independent Register 50</description>
          <addressOffset>0xc8</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_SW_WRLVL_RESP_2</name>
              <description>Indicates write leveling response for data slice 2.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PI_SW_WRLVL_RESP_1</name>
              <description>Indicates write leveling response for data slice 1.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PI_SW_WRLVL_RESP_0</name>
              <description>Indicates write leveling response for data slice 0.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PI_SWLVL_OP_DONE</name>
              <description>Indicates signals that software leveling is currently in progress.
Value of 1 indicates operation complete.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_51</name>
          <description>DDR PHY Independent Register 51</description>
          <addressOffset>0xcc</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_SW_RDLVL_RESP_2</name>
              <description>Indicates read leveling response for data slice 2.</description>
              <bitRange>[25:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PI_SW_RDLVL_RESP_1</name>
              <description>Indicates read leveling response for data slice 1.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PI_SW_RDLVL_RESP_0</name>
              <description>Indicates read leveling response for data slice 0.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PI_SW_WRLVL_RESP_3</name>
              <description>Indicates write leveling response for data slice 3.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_52</name>
          <description>DDR PHY Independent Register 52</description>
          <addressOffset>0xd0</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_SWLVL_START</name>
              <description>Indicates user request to initiate software leveling of type in the
PI_REG_52.pi_sw_leveling_mode parameter. Set to 1 to trigger.</description>
              <bitRange>[24:24]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PI_SW_LEVELING_MODE</name>
              <description>Defines the leveling operation for software leveling. Set to 3'b001
for write leveling, set to 3'b010 for read data eye training, set to
3'b011 for read gate training, set to 3'b100 for ca training, set to
3'b101 for WDQ training.</description>
              <bitRange>[18:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_SW_CALVL_RESP_0</name>
              <description>Indicates CA leveling response for data slice 0.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PI_SW_RDLVL_RESP_3</name>
              <description>Indicates read leveling response for data slice 3.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_53</name>
          <description>DDR PHY Independent Register 53</description>
          <addressOffset>0xd4</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_SW_WDQLVL_RESP_0</name>
              <description>Indicates WDQ leveling response for data slice 0.</description>
              <bitRange>[25:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PI_SWLVL_RD_SLICE_0</name>
              <description>Indicates software leveling read command in WDQ training for data
slice 0.</description>
              <bitRange>[16:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PI_SWLVL_WR_SLICE_0</name>
              <description>Indicates software leveling write command in WDQ training for data
slice 0.</description>
              <bitRange>[8:8]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PI_SWLVL_EXIT</name>
              <description>Indicates user request to exit software leveling. Set to 1 to exit.</description>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_54</name>
          <description>DDR PHY Independent Register 54</description>
          <addressOffset>0xd8</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_SWLVL_WR_SLICE_2</name>
              <description>Indicates software leveling write command in WDQ training for data
slice 2.</description>
              <bitRange>[24:24]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PI_SW_WDQLVL_RESP_1</name>
              <description>Indicates WDQ leveling response for data slice 1.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PI_SWLVL_RD_SLICE_1</name>
              <description>Indicates software leveling read command in WDQ training for data
slice 1.</description>
              <bitRange>[8:8]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PI_SWLVL_WR_SLICE_1</name>
              <description>Indicates software leveling write command in WDQ training for data
slice 1.</description>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_55</name>
          <description>DDR PHY Independent Register 55</description>
          <addressOffset>0xdc</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_SWLVL_RD_SLICE_3</name>
              <description>Indicates software leveling read command in WDQ training for data
slice 3.</description>
              <bitRange>[24:24]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PI_SWLVL_WR_SLICE_3</name>
              <description>Indicates software leveling write command in WDQ training for data
slice 3.</description>
              <bitRange>[16:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PI_SW_WDQLVL_RESP_2</name>
              <description>Indicates WDQ leveling response for data slice 2.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PI_SWLVL_RD_SLICE_2</name>
              <description>Indicates software leveling read command in WDQ training for data
slice 2.</description>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_56</name>
          <description>DDR PHY Independent Register 56</description>
          <addressOffset>0xe0</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_SWLVL_SM2_WR</name>
              <description>Indicates software leveling write command for stage 2.</description>
              <bitRange>[24:24]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PI_SWLVL_SM2_START</name>
              <description>Indicates software leveling start command for stage 2.</description>
              <bitRange>[16:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PI_SW_WDQLVL_VREF</name>
              <description>Indicates user-defined WDQ vref value in software leveling debug
mode.</description>
              <bitRange>[14:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_SW_WDQLVL_RESP_3</name>
              <description>Indicates WDQ leveling response for data slice 3.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_57</name>
          <description>DDR PHY Independent Register 57</description>
          <addressOffset>0xe4</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_SRE_PERIOD_EN</name>
              <description>Enables the selfrefresh exit-triggered periodic leveling.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_DFS_PERIOD_EN</name>
              <description>Enables the DFS-triggered periodic leveling.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_SEQUENTIAL_LVL_REQ</name>
              <description>Indicates user request to initiate the leveling sequence. Set to 1 to
trigger.</description>
              <bitRange>[8:8]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PI_SWLVL_SM2_RD</name>
              <description>Indicates software leveling read command for stage 2.</description>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_58</name>
          <description>DDR PHY Independent Register 58</description>
          <addressOffset>0xe8</addressOffset>
          <size>32</size>
          <resetValue>0x100</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TDFI_CTRL_DELAY_F1</name>
              <description>Defines the DFI tCTRL_DELAY timing parameter (in DFI clocks), the
delay between a DFI command change and a memory command.
The suffix "_f1" of the parameter name is omitted when in non-DFS
mode.</description>
              <bitRange>[27:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TDFI_CTRL_DELAY_F0</name>
              <description>Defines the DFI tCTRL_DELAY timing parameter (in DFI clocks), the
delay between a DFI command change and a memory command.
The suffix "_f0" of the parameter name is omitted when in non-DFS
mode.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_16BIT_DRAM_CONNECT</name>
              <description>Enables 16/32bit DRAM configuration.
1'b1: 16-bit DRAM
1'b0: 32-bit DRAM</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_DFI40_POLARITY</name>
              <description>Control polarity of dfi_wrdata_cs_n/dfi_rddata_cs_n generated by
PI. It need match with that of controller's polarity. If controller's
dfi_wrdata_cs_n/ dfi_rddata_cs_n is high active, pi_dfi40_polarity
should be 1, otherwise, it should be 0. If LPDDR4 connected, it is
recommended to set to 1 to match with latest DFI 4.0 protocol.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_59</name>
          <description>DDR PHY Independent Register 59</description>
          <addressOffset>0xec</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_WLDQSEN</name>
              <description>Indicates delay from the issuing MRS to the first DQS strobe for
write leveling.</description>
              <bitRange>[29:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_WRLVL_CS</name>
              <description>Specifies the target chip select for the write leveling operation that
is initiated through the PI_REG_59.pi_wrlvl_req parameter.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_WRLVL_REQ</name>
              <description>Indicates user request to initiate write leveling. Set to 1 to trigger.</description>
              <bitRange>[8:8]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PI_TDFI_CTRL_DELAY_F2</name>
              <description>Defines the DFI tCTRL_DELAY timing parameter (in DFI clocks), the
delay between a DFI command change and a memory command.
The suffix "_f2" of the parameter name is omitted when in non-DFS
mode.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_60</name>
          <description>DDR PHY Independent Register 60</description>
          <addressOffset>0xf0</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_WRLVL_INTERVAL</name>
              <description>Indicates the number of long count sequences that are counted
between automatic write leveling commands.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_WRLVL_EN</name>
              <description>Enables the PI write leveling module.
Bit1 represents the support when non-initialization.
Bit0 represents the support when initialization.
Set to 1 to enable.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_WLMRD</name>
              <description>Indicates delay from the issuing MRS to the first write leveling
strobe.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_61</name>
          <description>DDR PHY Independent Register 61</description>
          <addressOffset>0xf4</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_WRLVL_ROTATE</name>
              <description>Enables rotational chip select for interval write leveling. Set to 1 for
rotating chip select.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_WRLVL_RESP_MASK</name>
              <description>Indicates mask for the dfi_wrlvl_resp signal during write leveling.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_WRLVL_ON_SREF_EXIT</name>
              <description>Enables automatic write leveling on a self-refresh exit. Set to 1 to
enable.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_WRLVL_PERIODIC</name>
              <description>Enables the use of the dfi_lvl_periodic signal during write leveling.
Set to 1 to enable.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_62</name>
          <description>DDR PHY Independent Register 62</description>
          <addressOffset>0xf8</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TDFI_WRLVL_EN</name>
              <description>Defines the DFI tWRLVL_EN timing parameter (in DFI clocks), the
minimum cycles from a dfi_wrlvl_en assertion to the first
dfi_wrlvl_strobe assertion.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_WRLVL_ERROR_STATUS</name>
              <description>Holds the error that is associated with the write level error
interrupt. Bit0 set indicates a PI_REG_65.pi_tdfi_wrlvl_max
parameter violation and bit1 set indicates a
PI_REG_64.pi_tdfi_wrlvl_resp parameter violation.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PI_WRLVL_CS_MAP</name>
              <description>Defines the chip select map for write leveling operations.
Bit0 controls cs0, bit1 controls cs1. Set each bit to 1 to enable chip
for write leveling.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_63</name>
          <description>DDR PHY Independent Register 63</description>
          <addressOffset>0xfc</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TDFI_WRLVL_WW</name>
              <description>Defines the DFI tWRLVL_WW timing parameter (in DFI clocks), the
minimum cycles between dfi_wrlvl_strobe assertions.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_64</name>
          <description>DDR PHY Independent Register 64</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TDFI_WRLVL_RESP</name>
              <description>Defines the DFI tWRLVL_RESP timing parameter (in DFI clocks),
the maximum cycles between a dfi_wrlvl_req assertion and a
dfi_wrlvl_en assertion.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_65</name>
          <description>DDR PHY Independent Register 65</description>
          <addressOffset>0x104</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TDFI_WRLVL_MAX</name>
              <description>Defines the DFI tWRLVL_MAX timing parameter (in DFI clocks), the
maximum cycles between a dfi_wrlvl_en assertion and a valid
dfi_wrlvl_resp.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_66</name>
          <description>DDR PHY Independent Register 66</description>
          <addressOffset>0x108</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TODTL_2CMD_F0</name>
              <description>Defines the DRAM delay from an ODT de-assertion to the next
non-write, non-read command. The suffix "_f0" of the parameter
name is omitted when in non-DFS mode.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_WRLVL_STROBE_NUM</name>
              <description>Defines the write leveling strobe number in LPDDR4.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_67</name>
          <description>DDR PHY Independent Register 67</description>
          <addressOffset>0x10c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TODTL_2CMD_F2</name>
              <description>Defines the DRAM delay from an ODT de-assertion to the next
non-write, non-read command. The suffix "_f2" of the parameter
name is omitted when in non-DFS mode.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_ODT_EN_F1</name>
              <description>Enables support of DRAM ODT. When enabled, PI asserts and
de-asserts ODT output to DRAM as needed. The suffix "_f1" of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TODTL_2CMD_F1</name>
              <description>Defines the DRAM delay from an ODT de-assertion to the next
non-write, non-read command. The suffix "_f1" of the parameter
name is omitted when in non-DFS mode.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_ODT_EN_F0</name>
              <description>Enables support of DRAM ODT. When enabled, PI asserts and
de-asserts ODT output to DRAM as needed. The suffix "_f0" of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_68</name>
          <description>DDR PHY Independent Register 68</description>
          <addressOffset>0x110</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_ODT_RD_MAP_CS0</name>
              <description>Determines the chip(s) that have termination when a read occurs
on chip select 0. Set bit X to enable termination on csX when cs0 is
performing a read.</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TODTH_RD</name>
              <description>Defines the DRAM minimum ODT high time after an ODT assertion
for a read command.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TODTH_WR</name>
              <description>Defines the DRAM minimum ODT high time after an ODT assertion
for a write command.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_ODT_EN_F2</name>
              <description>Enables support of DRAM ODT. When enabled, PI asserts and
de-asserts ODT output to DRAM as needed. The suffix "_f2" of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_69</name>
          <description>DDR PHY Independent Register 69</description>
          <addressOffset>0x114</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_ODT_WR_MAP_CS1</name>
              <description>Determines the chip(s) that have termination when a write occurs
on chip select 1. Set bit X to enable termination on csX when cs1 is
performing a write.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_ODT_RD_MAP_CS1</name>
              <description>Determines the chip(s) that have termination when a read occurs
on chip select 1. Set bit X to enable termination on csX when cs1 is
performing a read.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_ODT_WR_MAP_CS0</name>
              <description>Determines the chip(s) that have termination when a write occurs
on chip select 0. Set bit X to enable termination on csX when cs0 is
performing a write.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_70</name>
          <description>DDR PHY Independent Register 70</description>
          <addressOffset>0x118</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_EN_ODT_ASSERT_EXCEPT_RD</name>
              <description>Enables controller to assert ODT at all times except during reads.
Assumes a single ODT pin is connected. Set to 1 to enable.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_71</name>
          <description>DDR PHY Independent Register 71</description>
          <addressOffset>0x11c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TODTON_MIN_F1</name>
              <description>Defines the point in time when the device termination circuit leaves
High-Z and ODT resistance begins to turn on. The suffix "_f1" of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[27:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_ODTLON_F1</name>
              <description>Defines the latency from a CAS-2 command to the tODTon
reference. The suffix "_f1" of the parameter name is omitted when
in non-DFS mode.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TODTON_MIN_F0</name>
              <description>Defines the point in time when the device termination circuit leaves
High-Z and ODT resistance begins to turn on. The suffix "_f0" of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_ODTLON_F0</name>
              <description>Defines the latency from a CAS-2 command to the tODTon
reference. The suffix "_f0" of the parameter name is omitted when
in non-DFS mode.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_72</name>
          <description>DDR PHY Independent Register 72</description>
          <addressOffset>0x120</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_WR_TO_ODTH_F1</name>
              <description>Defines the DRAM Write command to ODT set in cycles. The suffix
"_f1" of the parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[29:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_WR_TO_ODTH_F0</name>
              <description>Defines the DRAM Write command to ODT set in cycles. The suffix
"_f0" of the parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[21:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TODTON_MIN_F2</name>
              <description>Defines the point in time when the device termination circuit leaves
High-Z and ODT resistance begins to turn on. The suffix "_f2" of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_ODTLON_F2</name>
              <description>Defines the latency from a CAS-2 command to the tODTon
reference. The suffix "_f2" of the parameter name is omitted when
in non-DFS mode.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_73</name>
          <description>DDR PHY Independent Register 73</description>
          <addressOffset>0x124</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_RD_TO_ODTH_F2</name>
              <description>Defines the DRAM Read command to ODT set in cycles. The suffix
"_f2" of the parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[29:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_RD_TO_ODTH_F1</name>
              <description>Defines the DRAM Read command to ODT set in cycles. The suffix
"_f1" of the parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[21:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_RD_TO_ODTH_F0</name>
              <description>Defines the DRAM Read command to ODT set in cycles. The suffix
"_f0" of the parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[13:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_WR_TO_ODTH_F2</name>
              <description>Defines the DRAM Write command to ODT set in cycles. The suffix
"_f2" of the parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_74</name>
          <description>DDR PHY Independent Register 74</description>
          <addressOffset>0x128</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_RDLVL_CS</name>
              <description>Specifies the target chip select for the data eye training operation
that is initiated through the PI_REG_74.pi_rdlvl_req parameter or
the gate training operation that is initiated through the
PI_REG_74.pi_rdlvl_gate_req parameter.</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_RDLVL_GATE_REQ</name>
              <description>Indicates user request to initiate gate training. Set to 1 to trigger.</description>
              <bitRange>[16:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PI_RDLVL_REQ</name>
              <description>Indicates user request to initiate data eye training. Set to 1 to
trigger.</description>
              <bitRange>[8:8]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PI_ADDRESS_MIRRORING</name>
              <description>Indicates the chip selects that support address mirroring. Bit0
controls cs0, bit1 controls cs1. Set each bit to 1 to enable.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_75</name>
          <description>DDR PHY Independent Register 75</description>
          <addressOffset>0x12c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_RDLVL_ON_SREF_EXIT</name>
              <description>Enables automatic data eye training on a self-refresh exit. Set to 1
to enable.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_RDLVL_PERIODIC</name>
              <description>Enables the use of the dfi_lvl_periodic signal during data eye
training. Set to 1 to enable.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_RDLVL_GATE_SEQ_EN</name>
              <description>Specifies the pattern, format and MPR for gate training.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_RDLVL_SEQ_EN</name>
              <description>Specifies the pattern, format, and MPR for data eye training.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_76</name>
          <description>DDR PHY Independent Register 76</description>
          <addressOffset>0x130</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_RDLVL_ROTATE</name>
              <description>Enables rotational chip select for interval data eye training. Set to 1
for rotating CS.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_RDLVL_GATE_ON_SREF_EXIT</name>
              <description>Enables automatic gate training on a self-refresh exit. Set to 1 to
enable.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_RDLVL_GATE_PERIODIC</name>
              <description>Enables the use of the dfi_lvl_periodic signal during gate training.
Set to 1 to enable.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_77</name>
          <description>DDR PHY Independent Register 77</description>
          <addressOffset>0x134</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_RDLVL_GATE_CS_MAP</name>
              <description>Defines the chip select map for gate training operations. Bit0
controls cs0, bit1 controls cs1. Set each bit to 1 to enable chip for
gate training.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_RDLVL_CS_MAP</name>
              <description>Defines the chip select map for data eye training operations. Bit0
controls cs0, bit1 controls cs1. Set each bit to 1 to enable chip for
data eye training.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_RDLVL_GATE_ROTATE</name>
              <description>Enables rotational chip select for interval gate training. Set to 1 for
rotating CS.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_78</name>
          <description>DDR PHY Independent Register 78</description>
          <addressOffset>0x138</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TDFI_RDLVL_RR</name>
              <description>Defines the DFI tRDLVL_RR timing parameter (in DFI clocks), the
minimum cycles between read commands.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_79</name>
          <description>DDR PHY Independent Register 79</description>
          <addressOffset>0x13c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TDFI_RDLVL_RESP</name>
              <description>Defines the DFI tRDLVL_RESP timing parameter (in DFI clocks), the
maximum cycles between a dfi_rdlvl_req or dfi_rdlvl_gate_req
assertion and a dfi_rdlvl_en or dfi_rdlvl_gate_en assertion.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_80</name>
          <description>DDR PHY Independent Register 80</description>
          <addressOffset>0x140</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_RDLVL_GATE_EN</name>
              <description>Enables the PI gate training module. Bit1 represents the support
when non-initialization. Bit0 represents the support when
initialization. Set to 1 to enable.</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_RDLVL_EN</name>
              <description>Enables the PI data eye training module. Bit1 represents the
support when non-initialization. Bit0 represents the support when
initialization. Set to 1 to enable.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TDFI_RDLVL_EN</name>
              <description>Defines the DFI tRDLVL_EN timing parameter (in DFI clocks), the
minimum cycles from a dfi_rdlvl_en or dfi_rdlvl_gate_en assertion
to the first read or MRR.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_RDLVL_RESP_MASK</name>
              <description>Indicates mask for the dfi_rdlvl_resp signal during data eye
training.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_81</name>
          <description>DDR PHY Independent Register 81</description>
          <addressOffset>0x144</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TDFI_RDLVL_MAX</name>
              <description>Defines the DFI tRDLVL_MAX timing parameter (in DFI clocks), the
maximum cycles between a dfi_rdlvl_en or dfi_rdlvl_gate_en
assertion and a valid dfi_rdlvl_resp.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_82</name>
          <description>DDR PHY Independent Register 82</description>
          <addressOffset>0x148</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_RDLVL_INTERVAL</name>
              <description>Indicates the number of long count sequences that are counted
between automatic data eye training commands.</description>
              <bitRange>[23:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_RDLVL_ERROR_STATUS</name>
              <description>Holds the error that is associated with the data eye training error or
gate training error interrupt. The uppermost bit set indicates a
PI_REG_79.pi_tdfi_rdlvl_resp parameter violation. The next
uppermost bit set indicates a PI_REG_81.pi_tdfi_rdlvl_max
parameter violation. Lower bits are reserved.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_83</name>
          <description>DDR PHY Independent Register 83</description>
          <addressOffset>0x14c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_RDLVL_PATTERN_NUM</name>
              <description>Defines the number of patterns that are supported in read leveling.</description>
              <bitRange>[27:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_RDLVL_PATTERN_START</name>
              <description>Defines the start pattern in read leveling.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_RDLVL_GATE_INTERVAL</name>
              <description>The number of long count sequences that are counted between
automatic gate training commands.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_84</name>
          <description>DDR PHY Independent Register 84</description>
          <addressOffset>0x150</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_RDLVL_GATE_STROBE_NUM</name>
              <description>Defines the number of back-to-back MPC command in one read
process in read gate training.</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_RDLVL_STROBE_NUM</name>
              <description>Defines the number of back to back MPC command in one read
process in read eye training.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_85</name>
          <description>DDR PHY Independent Register 85</description>
          <addressOffset>0x154</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_LPDDR4_RDLVL_PATTERN_8</name>
              <description>Indicates user-defined LPDDR4 read data pattern 8.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_86</name>
          <description>DDR PHY Independent Register 86</description>
          <addressOffset>0x158</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_LPDDR4_RDLVL_PATTERN_9</name>
              <description>Indicates user-defined LPDDR4 read data pattern 9.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_87</name>
          <description>DDR PHY Independent Register 87</description>
          <addressOffset>0x15c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_LPDDR4_RDLVL_PATTERN_10</name>
              <description>Indicates user-defined LPDDR4 read data pattern 10.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_88</name>
          <description>DDR PHY Independent Register 88</description>
          <addressOffset>0x160</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_LPDDR4_RDLVL_PATTERN_11</name>
              <description>Indicates user-defined LPDDR4 read data pattern 11.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_89</name>
          <description>DDR PHY Independent Register 89</description>
          <addressOffset>0x164</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_RDLVL_ADJ_F1</name>
              <description>Indicates the adjustment value for PHY read timing. The suffix "_f1"
of the parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_RDLVL_ADJ_F0</name>
              <description>Indicates the adjustment value for PHY read timing. The suffix "_f0"
of the parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_REG_DIMM_ENABLE</name>
              <description>Enables registered DIMM operation. Set to 1 to enable.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_RD_PREAMBLE_TRAINING_EN</name>
              <description>Enables read preamble training during data eye training. Set to 1 to
enable.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_90</name>
          <description>DDR PHY Independent Register 90</description>
          <addressOffset>0x168</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_WRLAT_ADJ_F1</name>
              <description>Indicates the adjustment value for PHY write timing. The suffix
"_f1" of the parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_WRLAT_ADJ_F0</name>
              <description>Indicates the adjustment value for PHY write timing. The suffix
"_f0" of the parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TDFI_RDDATA_EN</name>
              <description>Holds the calculated DFI tRDDATA_EN timing parameter (in DFI
PHY clocks), the maximum cycles between a read command and a
dfi_rddata_en assertion.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PI_RDLVL_ADJ_F2</name>
              <description>Indicates the adjustment value for PHY read timing. The suffix "_f2"
of the parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_91</name>
          <description>DDR PHY Independent Register 91</description>
          <addressOffset>0x16c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TDFI_WRCSLAT_F1</name>
              <description>Defines the DFI tPHY_WRCSLAT timing parameter (in DFI PHY
clocks), the maximum cycles between a write command and a
dfi_wrdata_cs_n assertion. The suffix "_f1" of the parameter name
is omitted when in non-DFS mode.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TDFI_WRCSLAT_F0</name>
              <description>Defines the DFI tPHY_WRCSLAT timing parameter (in DFI PHY
clocks), the maximum cycles between a write command and a
dfi_wrdata_cs_n assertion. The suffix "_f0" of the parameter name
is omitted when in non-DFS mode.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TDFI_PHY_WRLAT</name>
              <description>Holds the calculated DFI tPHY_WRLAT timing parameter (in DFI
PHY clocks), the maximum cycles between a write command and a
dfi_wrdata_en assertion.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PI_WRLAT_ADJ_F2</name>
              <description>Indicates the adjustment value for PHY write timing. The suffix
"_f2" of the parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_92</name>
          <description>DDR PHY Independent Register 92</description>
          <addressOffset>0x170</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_CALVL_CS</name>
              <description>Specifies the target chip select for the CA training operation that is
initiated through the PI_REG_92.pi_calvl_req parameter.</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_CALVL_REQ</name>
              <description>Indicates user request to initiate CA training. Set to 1 to trigger.</description>
              <bitRange>[16:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PI_TDFI_PHY_WRDATA</name>
              <description>Defines the DFI tPHY_WRDATA timing parameter (in DFI PHY
clocks), the maximum cycles between a dfi_wrdata_en assertion
and a dfi_wrdata signal.</description>
              <bitRange>[10:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TDFI_WRCSLAT_F2</name>
              <description>Defines the DFI tPHY_WRCSLAT timing parameter (in DFI PHY
clocks), the maximum cycles between a write command and a
dfi_wrdata_cs_n assertion. The suffix "_f2" of the parameter name
is omitted when in non-DFS mode.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_93</name>
          <description>DDR PHY Independent Register 93</description>
          <addressOffset>0x174</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_CALVL_PERIODIC</name>
              <description>Enables the use of the dfi_lvl_periodic signal during CA training. Set
to 1 to enable.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_CALVL_SEQ_EN</name>
              <description>Specifies the CA training patterns that are to be used. Set to 0 for
pattern 0 only, set to 1 for patterns 0 and 1, set to 2 for patterns 0,
1, and 2, or set to 3 for all patterns.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_94</name>
          <description>DDR PHY Independent Register 94</description>
          <addressOffset>0x178</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TDFI_CALVL_EN</name>
              <description>Defines the DFI tCALVL_EN timing parameter (in DFI clocks), the
minimum cycles between a dfi_calvl_en assertion and a dfi_cke
de-assertion.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_CALVL_CS_MAP</name>
              <description>Defines the chip select map for CA training operations. Bit0 controls
cs0, bit1 controls cs1. Set each bit to 1 to enable chip for CA
training.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_CALVL_ROTATE</name>
              <description>Enables rotational chip select for interval CA training. Set to 1 for
rotating CS.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_CALVL_ON_SREF_EXIT</name>
              <description>Enables automatic CA training on a self-refresh exit. Set to 1 to
enable.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_95</name>
          <description>DDR PHY Independent Register 95</description>
          <addressOffset>0x17c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TDFI_CALVL_CAPTURE_F0</name>
              <description>Defines the DFI tCALVL_CAPTURE timing parameter (in DFI
clocks), the minimum cycles between a calibration command and a
dfi_calvl_capture pulse. The suffix "_f0" of the parameter name is
omitted when in non-DFS mode.</description>
              <bitRange>[25:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TDFI_CALVL_CC_F0</name>
              <description>Defines the DFI tCALVL_CC timing parameter (in DFI clocks), the
minimum cycles between calibration commands. The suffix "_f0" of
the parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_96</name>
          <description>DDR PHY Independent Register 96</description>
          <addressOffset>0x180</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TDFI_CALVL_CAPTURE_F1</name>
              <description>Defines the DFI tCALVL_CAPTURE timing parameter (in DFI
clocks), the minimum cycles between a calibration command and a
dfi_calvl_capture pulse. The suffix "_f1" of the parameter name is
omitted when in non-DFS mode.</description>
              <bitRange>[25:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TDFI_CALVL_CC_F1</name>
              <description>Defines the DFI tCALVL_CC timing parameter (in DFI clocks), the
minimum cycles between calibration commands. The suffix "_f1" of
the parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_97</name>
          <description>DDR PHY Independent Register 97</description>
          <addressOffset>0x184</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TDFI_CALVL_CAPTURE_F2</name>
              <description>Defines the DFI tCALVL_CAPTURE timing parameter (in DFI
clocks), the minimum cycles between a calibration command and a
dfi_calvl_capture pulse. The suffix "_f2" of the parameter name is
omitted when in non-DFS mode.</description>
              <bitRange>[25:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TDFI_CALVL_CC_F2</name>
              <description>Defines the DFI tCALVL_CC timing parameter (in DFI clocks), the
minimum cycles between calibration commands. The suffix "_f2" of
the parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_98</name>
          <description>DDR PHY Independent Register 98</description>
          <addressOffset>0x188</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TDFI_CALVL_RESP</name>
              <description>Defines the DFI tCALVL_RESP timing parameter (in DFI clocks), the
maximum cycles between a dfi_calvl_req assertion and a
dfi_calvl_en assertion.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_99</name>
          <description>DDR PHY Independent Register 99</description>
          <addressOffset>0x18c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TDFI_CALVL_MAX</name>
              <description>Defines the DFI tCALVL_MAX timing parameter (in DFI clocks), the
maximum cycles between a dfi_calvl_en assertion and a valid
dfi_calvl_resp.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_100</name>
          <description>DDR PHY Independent Register 100</description>
          <addressOffset>0x190</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_CALVL_ERROR_STATUS</name>
              <description>Holds the error that is associated with the CA training error
interrupt. Bit0 set indicates a PI_REG_98.pi_tdfi_calvl_resp
parameter violation and bit1 set indicates a
PI_REG_99.pi_tdfi_calvl_max parameter violation.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PI_CALVL_EN</name>
              <description>Enables the PI CA training module. Bit1 represents the support
when non-initialization. Bit0 represents the support when
initialization. Set to 1 to enable.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_CALVL_RESP_MASK</name>
              <description>Indicates mask for the dfi_calvl_resp signal during CA training.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_101</name>
          <description>DDR PHY Independent Register 101</description>
          <addressOffset>0x194</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TCAMRD</name>
              <description>Indicates DRAM TCAMRD value in cycles.</description>
              <bitRange>[29:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TCACKEL</name>
              <description>Indicates DRAM TCACKEL value in cycles.</description>
              <bitRange>[20:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_CALVL_INTERVAL</name>
              <description>Indicates the number of long count sequences that is counted
between automatic CA training commands.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_102</name>
          <description>DDR PHY Independent Register 102</description>
          <addressOffset>0x198</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TCAENT_F0</name>
              <description>Indicates DRAM TCAENT value in cycles. The suffix "_f0" of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[29:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TMRZ_F0</name>
              <description>Indicates DRAM TMRZ value in cycles. The suffix "_f0" of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TCACKEH</name>
              <description>Indicates DRAM TCACKEH value in cycles.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_103</name>
          <description>DDR PHY Independent Register 103</description>
          <addressOffset>0x19c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TMRZ_F2</name>
              <description>Indicates DRAM TMRZ value in cycles. The suffix "_f2" of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[28:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TCAENT_F1</name>
              <description>Indicates DRAM TCAENT value in cycles. The suffix "_f1" of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[21:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TMRZ_F1</name>
              <description>Indicates DRAM TMRZ value in cycles. The suffix "_f1" of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_104</name>
          <description>DDR PHY Independent Register 104</description>
          <addressOffset>0x1a0</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_CA_TRAIN_VREF_EN</name>
              <description>Indicates whether to do VREF training during non-power-on-initial
CA training or not. Set to 1 to go through the VREF from start-point
for non-power-on-initial CA training. Set to 0 to not update VREF
for non-power-on-initial CA training.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TCAEXT</name>
              <description>Indicates DRAM TCAEXT value in cycles.</description>
              <bitRange>[20:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TCAENT_F2</name>
              <description>Indicates DRAM TCAENT value in cycles. The suffix "_f2" of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[13:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_105</name>
          <description>DDR PHY Independent Register 105</description>
          <addressOffset>0x1a4</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TVREF_SHORT_F0</name>
              <description>Indicates delay from dfi_calvl_strobe to next CMD (only
param_calvl_vref_stepsize change of the VREF). The suffix "_f0" of
the parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[25:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TDFI_CASEL_F0</name>
              <description>Indicates DFI tcalvl_ca_sel timing parameter. The suffix "_f0" of
the parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TDFI_CACSCA_F0</name>
              <description>Indicates DFI tcalvl_cs_ca timing parameter. The suffix "_f0" of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_106</name>
          <description>DDR PHY Independent Register 106</description>
          <addressOffset>0x1a8</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TDFI_CASEL_F1</name>
              <description>Indicates DFI tcalvl_ca_sel timing parameter. The suffix "_f1" of
the parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[28:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TDFI_CACSCA_F1</name>
              <description>Indicates DFI tcalvl_cs_ca timing parameter. The suffix "_f1" of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[20:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TVREF_LONG_F0</name>
              <description>Indicates delay from dfi_calvl_strobe to next CMD (more than one
param_calvl_vref_stepsize Vref change). The suffix "_f0" of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_107</name>
          <description>DDR PHY Independent Register 107</description>
          <addressOffset>0x1ac</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TVREF_LONG_F1</name>
              <description>Indicates delay from dfi_calvl_strobe to next CMD (more than one
param_calvl_vref_stepsize Vref change). The suffix "_f1" of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[25:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TVREF_SHORT_F1</name>
              <description>Indicates delay from dfi_calvl_strobe to next CMD (only
param_calvl_vref_stepsize change of the VREF). The suffix "_f1" of
the parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_108</name>
          <description>DDR PHY Independent Register 108</description>
          <addressOffset>0x1b0</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TVREF_SHORT_F2</name>
              <description>Indicates delay from dfi_calvl_strobe to next CMD (only
param_calvl_vref_stepsize change of the VREF). The suffix "_f2" of
the parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[25:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TDFI_CASEL_F2</name>
              <description>Indicates DFI tcalvl_ca_sel timing parameter. The suffix "_f2" of
the parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TDFI_CACSCA_F2</name>
              <description>Indicates DFI tcalvl_cs_ca timing parameter. The suffix "_f2" of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_109</name>
          <description>DDR PHY Independent Register 109</description>
          <addressOffset>0x1b4</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_CALVL_VREF_INITIAL_STOP_POINT</name>
              <description>Indicates the end point of VREF for the Vref(ca) training
vrefca_range, vref_ca_setting[5:0]</description>
              <bitRange>[30:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_CALVL_VREF_INITIAL_START_POINT</name>
              <description>Indicates the start point of VREF for the Vref (ca) training
vrefca_range, vref_ca_setting[5:0].</description>
              <bitRange>[22:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TVREF_LONG_F2</name>
              <description>Indicates delay from dfi_calvl_strobe to next CMD (more than one
param_calvl_vref_stepsize Vref change). The suffix "_f2" of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_110</name>
          <description>DDR PHY Independent Register 110</description>
          <addressOffset>0x1b8</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TDFI_INIT_START_MIN</name>
              <description>Indicates the minimum number of DFI clocks before dfi_init_start
can be driven after a previous command or training event.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_CALVL_VREF_DELTA</name>
              <description>Indicates the CA VREF adjustment for non-initial CA training.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_CALVL_VREF_NORMAL_STEPSIZE</name>
              <description>Indicates the adjust step for the Vref(ca) training.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_CALVL_VREF_INITIAL_STEPSIZE</name>
              <description>Indicates the adjust step for the Vref(ca) training.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_111</name>
          <description>DDR PHY Independent Register 111</description>
          <addressOffset>0x1bc</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TDFI_CALVL_STROBE_F2</name>
              <description>Indicates data setup for VREF training mode. The suffix "_f2" of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[27:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TDFI_CALVL_STROBE_F1</name>
              <description>Indicates data setup for VREF training mode. The suffix "_f1" of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TDFI_CALVL_STROBE_F0</name>
              <description>Indicates data setup for VREF training mode. The suffix "_f0" of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TDFI_INIT_COMPLETE_MIN</name>
              <description>Indicates the minimum number of DFI clocks from
dfi_init_complete to a command or training event.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_112</name>
          <description>DDR PHY Independent Register 112</description>
          <addressOffset>0x1c0</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TDFI_INIT_START_F0</name>
              <description>Defines the DFI tINIT_START timing parameter (in DFI clocks), the
maximum number or cycles between a dfi_init_start assertion and
a dfi_init_complete de-assertion from the PHY. The suffix "_f0" of
the parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_SW_CA_TRAIN_VREF</name>
              <description>Indicates the VREF value, which is set for software step-by-step CA
training.</description>
              <bitRange>[22:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_CALVL_STROBE_NUM</name>
              <description>Indicates the consecutive dfi_calvl_strobe number when updating
the CA VREF data.</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TCKCKEH</name>
              <description>Indicates clock and command are valid before CKE HIGH.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_113</name>
          <description>DDR PHY Independent Register 113</description>
          <addressOffset>0x1c4</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TDFI_INIT_START_F1</name>
              <description>Defines the DFI tINIT_START timing parameter (in DFI clocks), the
maximum number or cycles between a dfi_init_start assertion and
a dfi_init_complete de-assertion from the PHY. The suffix "_f1" of
the parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TDFI_INIT_COMPLETE_F0</name>
              <description>Defines the DFI tINIT_COMPLETE timing parameter (in DFI clocks),
the maximum cycles between a dfi_init_start de-assertion and a
dfi_init_complete assertion from the PHY. The suffix "_f0" of the
parameter name is omitted when in non-DFS mode</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_114</name>
          <description>DDR PHY Independent Register 114</description>
          <addressOffset>0x1c8</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TDFI_INIT_START_F2</name>
              <description>Defines the DFI tINIT_START timing parameter (in DFI clocks), the
maximum number or cycles between a dfi_init_start assertion and
a dfi_init_complete de-assertion from the PHY. The suffix "_f2" of
the parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TDFI_INIT_COMPLETE_F1</name>
              <description>Defines the DFI tINIT_COMPLETE timing parameter (in DFI clocks),
the maximum cycles between a dfi_init_start de-assertion and a
dfi_init_complete assertion from the PHY. The suffix "_f1" of the
parameter name is omitted when in non-DFS mode</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_115</name>
          <description>DDR PHY Independent Register 115</description>
          <addressOffset>0x1cc</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_INIT_STARTORCOMPLETE_2_CLKDISABLE</name>
              <description>Defines the delay from deasserting of dfi_init_start or asserting of
dfi_init_complete to deasserting of dfi_dram_clk_disable in DFI
clock.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_CLKDISABLE_2_INIT_START</name>
              <description>Defines the delay from the asserting of dfi_dram_clk_disable to the
asserting of dfi_init_start in DFI clock.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TDFI_INIT_COMPLETE_F2</name>
              <description>Defines the DFI tINIT_COMPLETE timing parameter (in DFI clocks),
the maximum cycles between a dfi_init_start de-assertion and a
dfi_init_complete assertion from the PHY. The suffix "_f2" of the
parameter name is omitted when in non-DFS mode</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_116</name>
          <description>DDR PHY Independent Register 116</description>
          <addressOffset>0x1d0</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TCKEHDQS_F1</name>
              <description>Indicates the DRAM timing TCKEHDQS, minimum delay from CKE
high to strobe high impedance. The suffix "_f1" of the parameter
name is omitted when in non-DFS mode.</description>
              <bitRange>[29:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TCKEHDQS_F0</name>
              <description>Indicates the DRAM timing TCKEHDQS, minimum delay from CKE
high to strobe high impedance. The suffix "_f0" of the parameter
name is omitted when in non-DFS mode.</description>
              <bitRange>[21:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_REFRESH_BETWEEN_SEGMENT_DISABLE</name>
              <description>Disables the refresh between CA first and second segment training.
Defaut is set to 1.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_DRAM_CLK_DISABLE_DEASSERT_SEL</name>
              <description>Indicates dfi_dram_clk_disable deassert following dfi_init_start
deassert or dfi_init_complete assert.
1'b0: dfi_dram_clk_disable deassert following dfi_init_start
deassert.
1'b1: dfi_dram_clk_disable deassert following dfi_init_complete
assert.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_117</name>
          <description>DDR PHY Independent Register 117</description>
          <addressOffset>0x1d4</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_WDQLVL_BST_NUM</name>
              <description>Indicates burst number for MPC, the maximum FIFO for LPDDR4 is
5.</description>
              <bitRange>[18:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_WDQLVL_VREF_EN</name>
              <description>Indicates whether to do VREF training for non-initial WDQ leveling</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TCKEHDQS_F2</name>
              <description>Indicates the DRAM timing TCKEHDQS, minimum delay from CKE
high to strobe high impedance. The suffix "_f2" of the parameter
name is omitted when in non-DFS mode.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_118</name>
          <description>DDR PHY Independent Register 118</description>
          <addressOffset>0x1d8</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TDFI_WDQLVL_RW</name>
              <description>Switches time from read to write.</description>
              <bitRange>[25:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TDFI_WDQLVL_WR</name>
              <description>Switches time from write to read.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_119</name>
          <description>DDR PHY Independent Register 119</description>
          <addressOffset>0x1dc</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_WDQLVL_VREF_INITIAL_START_POINT</name>
              <description>Indicates write DQ training VREF start value.</description>
              <bitRange>[30:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_WDQLVL_CS_MAP</name>
              <description>Indicates map of chip selects that are included in write DQ training
sequence.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_WDQLVL_ROTATE</name>
              <description>Enables write DQ training rotate for periodic training.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_WDQLVL_RESP_MASK</name>
              <description>Indicates write DQ training response mask.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_120</name>
          <description>DDR PHY Independent Register 120</description>
          <addressOffset>0x1e0</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_WDQLVL_VREF_DELTA</name>
              <description>Indicates the WDQ VREF adjustment for non-initial WDQ training.</description>
              <bitRange>[27:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_WDQLVL_VERF_NORMAL_STEPSIZE</name>
              <description>Indicates write DQ training VREF step size.</description>
              <bitRange>[20:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_WDQLVL_VREF_INITIAL_STEPSIZE</name>
              <description>Indicates write DQ training VREF step size.</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_WDQLVL_VREF_INITIAL_STOP_POINT</name>
              <description>Indicates write DQ training VREF stop value.</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_121</name>
          <description>DDR PHY Independent Register 121</description>
          <addressOffset>0x1e4</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TDFI_WDQLVL_EN</name>
              <description>Indicates DFI timing param - enable to FIFO write.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_WDQLVL_CS</name>
              <description>Indicates write DQ training target chip select.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_WDQLVL_REQ</name>
              <description>Indicates software write DQ training request.</description>
              <bitRange>[8:8]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PI_WDQLVL_PERIODIC</name>
              <description>Enables write DQ training periodic.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_122</name>
          <description>DDR PHY Independent Register 122</description>
          <addressOffset>0x1e8</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TDFI_WDQLVL_RESP</name>
              <description>Indicates DFI timing param - req to enable.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_123</name>
          <description>DDR PHY Independent Register 123</description>
          <addressOffset>0x1ec</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TDFI_WDQLVL_MAX</name>
              <description>Indicates DFI timing param - max enable to resp (PHY eval).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_124</name>
          <description>DDR PHY Independent Register 124</description>
          <addressOffset>0x1f0</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_WDQLVL_ON_SREF_EXIT</name>
              <description>Issues a write DQ training command on self-refresh exit.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_WDQLVL_EN</name>
              <description>Indicates if write DQ leveling is enabled. Bit1 represents the
support when non-initialization. Bit0 represents the support when
initialization.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_WDQLVL_INTERVAL</name>
              <description>Indicates write DQ train interval counter program value.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_125</name>
          <description>DDR PHY Independent Register 125</description>
          <addressOffset>0x1f4</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_MR1_DATA_F0_0</name>
              <description>Indicates data to program into memory mode register 1 for chip
select 0. The suffix "_f0" of the parameter name is omitted when in
non-DFS mode.</description>
              <bitRange>[23:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_WDQLVL_ERROR_STATUS</name>
              <description>Holds the error associated with the write DQ level error interrupt.
Bit0 set indicates a PI_REG_123.pi_tdfi_wdqlvl_max parameter
violation and bit1 set indicates a PI_REG_122.pi_tdfi_wdqlvl_resp
parameter violation.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_126</name>
          <description>DDR PHY Independent Register 126</description>
          <addressOffset>0x1f8</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_MR3_DATA_F0_0</name>
              <description>Indicates data to program into memory mode register 3 for chip
select 0. The suffix "_f0" of the parameter name is omitted when in
non-DFS mode.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_MR2_DATA_F0_0</name>
              <description>Indicates data to program into memory mode register 2 for chip
select 0. The suffix "_f0" of the parameter name is omitted when in
non-DFS mode.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_127</name>
          <description>DDR PHY Independent Register 127</description>
          <addressOffset>0x1fc</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_MR14_DATA_F0_0</name>
              <description>Indicates data to program into memory mode register 14 for chip
select 0. The suffix "_f0" of the parameter name is omitted when in
non-DFS mode.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_MR12_DATA_F0_0</name>
              <description>Indicates data to program into memory mode register 12 for chip
select 0. The suffix "_f0" of the parameter name is omitted when in
non-DFS mode.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_MR11_DATA_F0_0</name>
              <description>Indicates data to program into memory mode register 11 for chip
select 0. The suffix "_f0" of the parameter name is omitted when in
non-DFS mode.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_128</name>
          <description>DDR PHY Independent Register 128</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_MR2_DATA_F1_0</name>
              <description>Indicates data to program into memory mode register 2 for chip
select 0. The suffix "_f1" of the parameter name is omitted when in
non-DFS mode.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_MR1_DATA_F1_0</name>
              <description>Indicates data to program into memory mode register 1 for chip
select 0. The suffix "_f1" of the parameter name is omitted when in
non-DFS mode.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_129</name>
          <description>DDR PHY Independent Register 129</description>
          <addressOffset>0x204</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_MR12_DATA_F1_0</name>
              <description>Indicates data to program into memory mode register 12 for chip
select 0. The suffix "_f1" of the parameter name is omitted when in
non-DFS mode.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_MR11_DATA_F1_0</name>
              <description>Indicates data to program into memory mode register 11 for chip
select 0. The suffix "_f1" of the parameter name is omitted when in
non-DFS mode.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_MR3_DATA_F1_0</name>
              <description>Indicates data to program into memory mode register 3 for chip
select 0. The suffix "_f1" of the parameter name is omitted when in
non-DFS mode.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_130</name>
          <description>DDR PHY Independent Register 130</description>
          <addressOffset>0x208</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_MR1_DATA_F2_0</name>
              <description>Indicates data to program into memory mode register 1 for chip
select 0. The suffix "_f2" of the parameter name is omitted when in
non-DFS mode.</description>
              <bitRange>[23:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_MR14_DATA_F1_0</name>
              <description>Indicates data to program into memory mode register 14 for chip
select 0. The suffix "_f1" of the parameter name is omitted when in
non-DFS mode.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_131</name>
          <description>DDR PHY Independent Register 131</description>
          <addressOffset>0x20c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_MR3_DATA_F2_0</name>
              <description>Indicates data to program into memory mode register 3 for chip
select 0. The suffix "_f2" of the parameter name is omitted when in
non-DFS mode.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_MR2_DATA_F2_0</name>
              <description>Indicates data to program into memory mode register 2 for chip
select 0. The suffix "_f2" of the parameter name is omitted when in
non-DFS mode.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_132</name>
          <description>DDR PHY Independent Register 132</description>
          <addressOffset>0x210</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_MR13_DATA_0</name>
              <description>Indicates data to program into memory mode register 13 for chip
select 0.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_MR14_DATA_F2_0</name>
              <description>Indicates data to program into memory mode register 14 for chip
select 0. The suffix "_f2" of the parameter name is omitted when in
non-DFS mode.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_MR12_DATA_F2_0</name>
              <description>Indicates data to program into memory mode register 12 for chip
select 0. The suffix "_f2" of the parameter name is omitted when in
non-DFS mode.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_MR11_DATA_F2_0</name>
              <description>Indicates data to program into memory mode register 11 for chip
select 0. The suffix "_f2" of the parameter name is omitted when in
non-DFS mode.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_133</name>
          <description>DDR PHY Independent Register 133</description>
          <addressOffset>0x214</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_MR2_DATA_F0_1</name>
              <description>Indicates data to program into memory mode register 2 for chip
select 1. The suffix "_f0" of the parameter name is omitted when in
non-DFS mode.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_MR1_DATA_F0_1</name>
              <description>Indicates data to program into memory mode register 1 for chip
select 1. The suffix "_f0" of the parameter name is omitted when in
non-DFS mode.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_134</name>
          <description>DDR PHY Independent Register 134</description>
          <addressOffset>0x218</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_MR12_DATA_F0_1</name>
              <description>Indicates data to program into memory mode register 12 for chip
select 1. The suffix "_f0" of the parameter name is omitted when in
non-DFS mode.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_MR11_DATA_F0_1</name>
              <description>Indicates data to program into memory mode register 11 for chip
select 1. The suffix "_f0" of the parameter name is omitted when in
non-DFS mode.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_MR3_DATA_F0_1</name>
              <description>Indicates data to program into memory mode register 3 for chip
select 1. The suffix "_f0" of the parameter name is omitted when in
non-DFS mode.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_135</name>
          <description>DDR PHY Independent Register 135</description>
          <addressOffset>0x21c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_MR1_DATA_F1_1</name>
              <description>Indicates data to program into memory mode register 1 for chip
select 1. The suffix "_f1" of the parameter name is omitted when in
non-DFS mode.</description>
              <bitRange>[23:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_MR14_DATA_F0_1</name>
              <description>Indicates data to program into memory mode register 14 for chip
select 1. The suffix "_f0" of the parameter name is omitted when in
non-DFS mode.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_136</name>
          <description>DDR PHY Independent Register 136</description>
          <addressOffset>0x220</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_MR3_DATA_F1_1</name>
              <description>Indicates data to program into memory mode register 3 for chip
select 1. The suffix "_f1" of the parameter name is omitted when in
non-DFS mode.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_MR2_DATA_F1_1</name>
              <description>Indicates data to program into memory mode register 2 for chip
select 1. The suffix "_f1" of the parameter name is omitted when in
non-DFS mode.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_137</name>
          <description>DDR PHY Independent Register 137</description>
          <addressOffset>0x224</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_MR14_DATA_F1_1</name>
              <description>Indicates data to program into memory mode register 14 for chip
select 1. The suffix "_f1" of the parameter name is omitted when in
non-DFS mode.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_MR12_DATA_F1_1</name>
              <description>Indicates data to program into memory mode register 12 for chip
select 1. The suffix "_f1" of the parameter name is omitted when in
non-DFS mode.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_MR11_DATA_F1_1</name>
              <description>Indicates data to program into memory mode register 11 for chip
select 1. The suffix "_f1" of the parameter name is omitted when in
non-DFS mode.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_138</name>
          <description>DDR PHY Independent Register 138</description>
          <addressOffset>0x228</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_MR2_DATA_F2_1</name>
              <description>Indicates data to program into memory mode register 2 for chip
select 1. The suffix "_f2" of the parameter name is omitted when in
non-DFS mode.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_MR1_DATA_F2_1</name>
              <description>Indicates data to program into memory mode register 1 for chip
select 1. The suffix "_f2" of the parameter name is omitted when in
non-DFS mode.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_139</name>
          <description>DDR PHY Independent Register 139</description>
          <addressOffset>0x22c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_MR12_DATA_F2_1</name>
              <description>Indicates data to program into memory mode register 12 for chip
select 1. The suffix "_f2" of the parameter name is omitted when in
non-DFS mode.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_MR11_DATA_F2_1</name>
              <description>Indicates data to program into memory mode register 11 for chip
select 1. The suffix "_f2" of the parameter name is omitted when in
non-DFS mode.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_MR3_DATA_F2_1</name>
              <description>Indicates data to program into memory mode register 3 for chip
select 1. The suffix "_f2" of the parameter name is omitted when in
non-DFS mode.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_140</name>
          <description>DDR PHY Independent Register 140</description>
          <addressOffset>0x230</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_MR13_DATA_1</name>
              <description>Indicates data to program into memory mode register 13 for chip
select 0.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_MR14_DATA_F2_1</name>
              <description>Indicates data to program into memory mode register 14 for chip
select 1. The suffix "_f2" of the parameter name is omitted when in
non-DFS mode.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_155</name>
          <description>DDR PHY Independent Register 155</description>
          <addressOffset>0x26c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_ROW_DIFF</name>
              <description>Indicates the difference between the number of address pins
available and the number being used.</description>
              <bitRange>[26:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_BANK_DIFF</name>
              <description>Indicates encoded number of banks on the DRAM(s).</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_156</name>
          <description>DDR PHY Independent Register 156</description>
          <addressOffset>0x270</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TFC_F1</name>
              <description>Indicates the delay in PHY clock cycles from setting MR13.OP7 to
any valid command. The suffix "_f1" of the parameter name is
omitted when in non-DFS mode.</description>
              <bitRange>[25:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TFC_F0</name>
              <description>Indicates the delay in PHY clock cycles from setting MR13.OP7 to
any valid command. The suffix "_f0" of the parameter name is
omitted when in non-DFS mode.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_157</name>
          <description>DDR PHY Independent Register 157</description>
          <addressOffset>0x274</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TRTP_F0</name>
              <description>Indicates DRAM TRTP value in cycles. The suffix "_f0" of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TCCD</name>
              <description>Indicates DRAM CAS-to-CAS value in cycles.</description>
              <bitRange>[20:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TFC_F2</name>
              <description>Indicates the delay in PHY clock cycles from setting MR13.OP7 to
any valid command. The suffix "_f2" of the parameter name is
omitted when in non-DFS mode.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_158</name>
          <description>DDR PHY Independent Register 158</description>
          <addressOffset>0x278</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TWR_F0</name>
              <description>Indicates DRAM TWR value in cycles. The suffix "_f0" of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[29:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TWTR_F0</name>
              <description>Indicates DRAM TWTR value in cycles. The suffix "_f0" of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[21:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TRCD_F0</name>
              <description>Indicates DRAM TRCD value in cycles. The suffix "_f0" of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TRP_F0</name>
              <description>Indicates DRAM TRP value in cycles. The suffix "_f0" of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_159</name>
          <description>DDR PHY Independent Register 159</description>
          <addressOffset>0x27c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TRAS_MIN_F0</name>
              <description>Indicates DRAM TRAS_MIN value in cycles. The suffix "_f0" of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TRAS_MAX_F0</name>
              <description>Indicates DRAM TRAS_MAX value in cycles. The suffix "_f0" of
parameter name will be omitted when non DFS mode.</description>
              <bitRange>[16:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_160</name>
          <description>DDR PHY Independent Register 160</description>
          <addressOffset>0x280</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TMRW_F0</name>
              <description>Indicates DRAM TMRW value in cycles. The suffix "_f0" of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TMRD_F0</name>
              <description>Indicates DRAM TMRD value in cycles. The suffix "_f0" of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[21:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TCCDMW_F0</name>
              <description>Indicates LPDDR4 DRAM TCCDMW in cycles. The suffix "_f0" of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[13:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TDQSCK_MAX_F0</name>
              <description>Indicates additional delay that is needed for tDQSCK. The suffix
"_f0" of the parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_161</name>
          <description>DDR PHY Independent Register 161</description>
          <addressOffset>0x284</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TRCD_F1</name>
              <description>Indicates DRAM TRCD value in cycles. The suffix "_f1" of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TRP_F1</name>
              <description>Indicates DRAM TRP value in cycles. The suffix "_f1" of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TRTP_F1</name>
              <description>Indicates DRAM TRTP value in cycles. The suffix "_f1" of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TMOD_F0</name>
              <description>Indicates TMOD value in cycles. The suffix "_f0" of the parameter
name is omitted when in non-DFS mode.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_162</name>
          <description>DDR PHY Independent Register 162</description>
          <addressOffset>0x288</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TWR_F1</name>
              <description>Indicates DRAM TWR value in cycles. The suffix "_f1" of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[13:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TWTR_F1</name>
              <description>Indicates DRAM TWTR value in cycles. The suffix "_f1" of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_163</name>
          <description>DDR PHY Independent Register 163</description>
          <addressOffset>0x28c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TRAS_MIN_F1</name>
              <description>Indicates DRAM TRAS_MIN value in cycles. The suffix "_f1" of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TRAS_MAX_F1</name>
              <description>Indicates DRAM TRAS_MAX value in cycles. The suffix "_f1" of
parameter name will be omitted when non DFS mode.</description>
              <bitRange>[16:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_164</name>
          <description>DDR PHY Independent Register 164</description>
          <addressOffset>0x290</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TMRW_F1</name>
              <description>Indicates DRAM TMRW value in cycles. The suffix "_f1" of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TMRD_F1</name>
              <description>Indicates DRAM TMRD value in cycles. The suffix "_f1" of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[21:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TCCDMW_F1</name>
              <description>Indicates LPDDR4 DRAM TCCDMW in cycles. The suffix "_f1" of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[13:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TDQSCK_MAX_F1</name>
              <description>Indicates additional delay that is needed for tDQSCK. The suffix
"_f1" of the parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_165</name>
          <description>DDR PHY Independent Register 165</description>
          <addressOffset>0x294</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TRCD_F2</name>
              <description>Indicates DRAM TRCD value in cycles. The suffix "_f2" of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TRP_F2</name>
              <description>Indicates DRAM TRP value in cycles. The suffix "_f2" of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TRTP_F2</name>
              <description>Indicates DRAM TRTP value in cycles. The suffix "_f2" of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TMOD_F1</name>
              <description>Indicates TMOD value in cycles. The suffix "_f1" of the parameter
name is omitted when in non-DFS mode.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_166</name>
          <description>DDR PHY Independent Register 166</description>
          <addressOffset>0x298</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TWR_F2</name>
              <description>Indicates DRAM TWR value in cycles. The suffix "_f2" of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[13:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TWTR_F2</name>
              <description>Indicates DRAM TWTR value in cycles. The suffix "_f2" of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_167</name>
          <description>DDR PHY Independent Register 167</description>
          <addressOffset>0x29c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TRAS_MIN_F2</name>
              <description>Indicates DRAM TRAS_MIN value in cycles. The suffix "_f2" of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TRAS_MAX_F2</name>
              <description>Indicates DRAM TRAS_MAX value in cycles. The suffix "_f2" of
parameter name will be omitted when non DFS mode.</description>
              <bitRange>[16:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_168</name>
          <description>DDR PHY Independent Register 168</description>
          <addressOffset>0x2a0</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TMRW_F2</name>
              <description>Indicates DRAM TMRW value in cycles. The suffix "_f2" of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TMRD_F2</name>
              <description>Indicates DRAM TMRD value in cycles. The suffix "_f2" of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[21:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TCCDMW_F2</name>
              <description>Indicates LPDDR4 DRAM TCCDMW in cycles. The suffix "_f2" of the
parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[13:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TDQSCK_MAX_F2</name>
              <description>Indicates additional delay that is needed for tDQSCK. The suffix
"_f2" of the parameter name is omitted when in non-DFS mode.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_169</name>
          <description>DDR PHY Independent Register 169</description>
          <addressOffset>0x2a4</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TMOD_F2</name>
              <description>Indicates TMOD value in cycles. The suffix "_f2" of the parameter
name is omitted when in non-DFS mode.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_174</name>
          <description>DDR PHY Independent Register 174</description>
          <addressOffset>0x2b8</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_INT_STATUS</name>
              <description>Indicates status of interrupt features in the PI.</description>
              <bitRange>[25:8]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_175</name>
          <description>DDR PHY Independent Register 175</description>
          <addressOffset>0x2bc</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_INT_ACK</name>
              <description>Clears the corresponding interrupt bit of the
PI_REG_174.pi_int_status parameter.</description>
              <bitRange>[17:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_176</name>
          <description>DDR PHY Independent Register 176</description>
          <addressOffset>0x2c0</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_INT_MASK</name>
              <description>Indicates mask for PI interrupt signals from the
PI_REG_174.pi_int_status parameter.</description>
              <bitRange>[17:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_186</name>
          <description>DDR PHY Independent Register 186</description>
          <addressOffset>0x2e8</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_CTRLUPD_REQ_PER_AREF_EN</name>
              <description>Enables an automatic PI-initiated update (dfi_ctrlupd_req) after
every refresh. Set to 1 to enable.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_LONG_COUNT_MASK</name>
              <description>Reduces the length of the long counter from 1024 cycles. The only
supported values are 0x00 (1024 cycles), 0x10 (512 clocks), 0x18
(256 clocks), 0x1C (128 clocks), 0x1E (64 clocks), and 0x1F (32
clocks).</description>
              <bitRange>[20:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_BSTLEN</name>
              <description>Indicates encoded burst length that is sent to DRAMs during
initialization. Set to 1 for BL2, set to 2 for BL4, or set to 3 for BL8.</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_187</name>
          <description>DDR PHY Independent Register 187</description>
          <addressOffset>0x2ec</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TDFI_CTRLUPD_MAX_F0</name>
              <description>Defines the DFI tCTRLUPD_MAX timing parameter (in DFI clocks),
the maximum cycles that dfi_ctrlupd_req can be asserted. If
programmed to a non-zero, a timing violation causes an interrupt
and bit (1) set in the PI_REG_193.pi_update_error_status
parameter. The suffix "_f0" of the parameter name is omitted when
in non-DFS mode.</description>
              <bitRange>[23:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PI_TDFI_CTRLUPD_MIN</name>
              <description>Reports the DFI tCTRLUPD_MIN timing parameter (in DFI clocks),
the minimum cycles that dfi_ctrlupd_req must be asserted.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_188</name>
          <description>DDR PHY Independent Register 188</description>
          <addressOffset>0x2f0</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TDFI_CTRLUPD_INTERVAL_F0</name>
              <description>Defines the DFI tCTRLUPD_INTERVAL timing parameter (in DFI
clocks), the maximum cycles between dfi_ctrlupd_req assertions.
If programmed to a non-zero, a timing violation causes an interrupt
and bit0 set in the PI_REG_193.pi_update_error_status
parameter. The suffix "_f0" of the parameter name is omitted when
in non-DFS mode.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_189</name>
          <description>DDR PHY Independent Register 189</description>
          <addressOffset>0x2f4</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TDFI_CTRLUPD_MAX_F1</name>
              <description>Defines the DFI tCTRLUPD_MAX timing parameter (in DFI clocks),
the maximum cycles that dfi_ctrlupd_req can be asserted. If
programmed to a non-zero, a timing violation causes an interrupt
and bit (1) set in the PI_REG_193.pi_update_error_status
parameter. The suffix "_f1" of the parameter name is omitted when
in non-DFS mode.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_190</name>
          <description>DDR PHY Independent Register 190</description>
          <addressOffset>0x2f8</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TDFI_CTRLUPD_INTERVAL_F1</name>
              <description>Defines the DFI tCTRLUPD_INTERVAL timing parameter (in DFI
clocks), the maximum cycles between dfi_ctrlupd_req assertions.
If programmed to a non-zero, a timing violation causes an interrupt
and bit0 set in the PI_REG_193.pi_update_error_status
parameter. The suffix "_f1" of the parameter name is omitted when
in non-DFS mode.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_191</name>
          <description>DDR PHY Independent Register 191</description>
          <addressOffset>0x2fc</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TDFI_CTRLUPD_MAX_F2</name>
              <description>Defines the DFI tCTRLUPD_MAX timing parameter (in DFI clocks),
the maximum cycles that dfi_ctrlupd_req can be asserted. If
programmed to a non-zero, a timing violation causes an interrupt
and bit (1) set in the PI_REG_193.pi_update_error_status
parameter. The suffix "_f2" of the parameter name is omitted when
in non-DFS mode.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_192</name>
          <description>DDR PHY Independent Register 192</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_TDFI_CTRLUPD_INTERVAL_F2</name>
              <description>Defines the DFI tCTRLUPD_INTERVAL timing parameter (in DFI
clocks), the maximum cycles between dfi_ctrlupd_req assertions.
If programmed to a non-zero, a timing violation causes an interrupt
and bit0 set in the PI_REG_193.pi_update_error_status
parameter. The suffix "_f2" of the parameter name is omitted when
in non-DFS mode.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_193</name>
          <description>DDR PHY Independent Register 193</description>
          <addressOffset>0x304</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_UPDATE_ERROR_STATUS</name>
              <description>Identifies the source of any DFI PI-initiated or PHY-initiated update
errors. A value of 1 indicates a timing violation of the associated
timing parameter.
Bit 5-0:
phyupd_resp_error,
phyupd_type3_error,
phyupd_type2_error,
phyupd_type1_error,
ctrlupd_max_error,
ctrlupd_interval_error.</description>
              <bitRange>[6:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PI_REG_199</name>
          <description>DDR PHY Independent Register 199</description>
          <addressOffset>0x31c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PI_COL_DIFF</name>
              <description>Indicates the difference between the number of column pins
available and the number being used.
write_enable
bit0~15 write enable
When bit 16=1, bit 0 can be written by software.
When bit 16=0, bit 0 cannot be written by software;
When bit 17=1, bit 1 can be written by software.
When bit 17=0, bit 1 cannot be written by software;
......
When bit 31=1, bit 15 can be written by software.
When bit 31=0, bit 15 cannot be written by software;
reserved
ddr0_cntrl_freq_change_ack
Channel 0 DDR controller frequency change acknowledge
ddr0_cntrl_freq_change_ack
Channel 0 DDR controller frequency change acknowledge
Ddr1_freq_change_ack
Channel 1 DDR PHY frequency change acknowledge
ddr0_freq_change_ack
Channel 0 DDR PHY frequency change acknowledge
reserved
chg_fc_reg_copy
Select the copy of timing parameters that will be used after
frequency change.
reserved
fail_cont_en
When frequency change fail, whether continue to enable change.
chg_freq_finish
Frequency change finish
1'b0: not finish
1'b1: finish
chg_req
Frequency change request
1'b0: not request
1'b1: request</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="PI0">
      <name>PI1</name>
      <version>1.0</version>
      <groupname>PI</groupname>
      <baseAddress>0xffa88800</baseAddress>
    </peripheral>
    <peripheral>
      <name>DMAC0</name>
      <version>1.0</version>
      <groupname>DMAC</groupname>
      <baseAddress>0xff6d0000</baseAddress>
      <registers>
        <register>
          <name>DMAC_DSR</name>
          <description>DMA Manager Status Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMA_MANAGER_SECURITY_STATE</name>
              <description>Provides the security status of the DMA manager thread:
0 = DMA manager operates in the Secure state
1 = DMA manager operates in the Non-secure state.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DMA_MANAGER_DMAWFE_WAIT</name>
              <description>When the DMA manager thread executes a DMAWFE instruction, it
waits for the following event to occur:
b00000 = event[0]
b00001 = event[1]
b00010 = event[2]
&#8230;
b11111 = event[31].</description>
              <bitRange>[8:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DMA_MANAGER_STATE</name>
              <description>The operating state of the DMA manager:
b0000 = Stopped
b0001 = Executing
b0010 = Cache miss
b0011 = Updating PC
b0100 = Waiting for event
b0101-b1110 = reserved
b1111 = Faulting.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DPC</name>
          <description>DMA Program Counter Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMAC_DPC</name>
              <description>Program counter for the DMA manager thread</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_INTEN</name>
          <description>Interrupt Enable Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMAC_INTEN</name>
              <description>Program the appropriate bit to control how the DMAC responds</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_EVENT_RIS</name>
          <description>Event-Interrupt Raw Status Register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMAC_EVENT_RIS</name>
              <description>Returns the status of the event-interrupt resources:</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_INTMIS</name>
          <description>Interrupt Status Register</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMAC_INTMIS</name>
              <description>Provides the status of the interrupts that are active in the DMAC:</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_INTCLR</name>
          <description>Interrupt Clear Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMAC_INTCLR</name>
              <description>Controls the clearing of the irq outputs:</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_FSRD</name>
          <description>Fault Status DMA Manager Register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMAC_FSRD</name>
              <description>Provides the fault status of the DMA manager. Read as:</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_FSRC</name>
          <description>Fault Status DMA Channel Register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMAC_FSRC</name>
              <description>Each bit provides the fault status of the corresponding channel.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_FTRD</name>
          <description>Fault Type DMA Manager Register</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMA_MANAGER_ABORT_SRC</name>
              <description>If the DMA manager aborts, this bit indicates if the erroneous
instruction was read from the system
memory or from the debug interface:
0 = instruction that generated an abort was read from system
memory
1 = instruction that generated an abort was read from the debug
interface.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DMAC_RRESP_STATUS</name>
              <description>Indicates the AXI response that the DMAC receives on the RRESP
bus, after the DMA manager
performs an instruction fetch:
0 = OKAY response
1 = EXOKAY, SLVERR, or DECERR response</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DMAC_SECURITY_EXCEPTION_FROM_DMAWFE_DMASEV</name>
              <description>Indicates if the DMA manager was attempting to execute DMAWFE
or DMASEV with inappropriate security permissions:
0 = DMA manager has appropriate security to execute DMAWFE or
DMASEV
1 = a DMA manager thread in the Non-secure state attempted to
execute either:
DMAWFE to wait for a secure event
DMASEV to create a secure event or secure interrupt</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DMA_MANAGER_SECURITY_STATUS_DMAGO</name>
              <description>Indicates if the DMA manager was attempting to execute DMAGO
with inappropriate security permissions:
0 = DMA manager has appropriate security to execute DMAGO
1 = DMA manager thread in the Non-secure state attempted to
execute DMAGO to create a DMA channel operating in the Secure
state.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DMA_MANAGER_OPERAND_VALIDITY</name>
              <description>Indicates if the DMA manager was attempting to execute an
instruction operand that was not valid for
the configuration of the DMAC:
0 = valid operand
1 = invalid operand.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DMA_MANAGER_INSTRUCTION_VALIDITY</name>
              <description>Indicates if the DMA manager was attempting to execute an
undefined instruction:
0 = defined instruction
1 = undefined instruction.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_FTR0</name>
          <description>Fault Type DMA Channel Register</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMA_CHANNEL_RESOURCE_STATUS</name>
              <description>Indicates if the DMA channel has locked-up because of resource
starvation:
0 = DMA channel has adequate resources
1 = DMA channel has locked-up because of insufficient resources.
This fault is an imprecise abort</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DMA_CHANNEL_ABORT_SRC</name>
              <description>If the DMA channel aborts, this bit indicates if the erroneous
instruction was read from the system
memory or from the debug interface:
0 = instruction that generated an abort was read from system
memory
1 = instruction that generated an abort was read from the debug
interface.
This fault is an imprecise abort but the bit is only valid when a
precise abort occurs.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DMA_CHANNEL_RRESP_STATUS</name>
              <description>Indicates the AXI response that the DMAC receives on the RRESP
bus, after the DMA channel
thread performs a data read:
0 = OKAY response
1 = EXOKAY, SLVERR, or DECERR response.
This fault is an imprecise abort</description>
              <bitRange>[18:18]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DMA_CHANNEL_RRESP_STATUS_WRITE</name>
              <description>Indicates the AXI response that the DMAC receives on the BRESP
bus, after the DMA channel
thread performs a data write:
0 = OKAY response
1 = EXOKAY, SLVERR, or DECERR response.
This fault is an imprecise abort.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DMA_CHANNEL_RRESP_STATUS_FETCH</name>
              <description>Indicates the AXI response that the DMAC receives on the RRESP
bus, after the DMA channel
thread performs an instruction fetch:
0 = OKAY response
1 = EXOKAY, SLVERR, or DECERR response.
This fault is a precise abort.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DMAC_MFIFO_ENOUGH_DATA</name>
              <description>Indicates if the MFIFO did not contain the data to enable the DMAC
to perform the DMAST:
0 = MFIFO contains all the data to enable the DMAST to complete
1 = previous DMALDs have not put enough data in the MFIFO to
enable the DMAST to complete.
This fault is a precise abort.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DMA_CHANNEL_MFIFO_ENOUGH_SPACE_DMALD</name>
              <description>Indicates if the MFIFO prevented the DMA channel thread from
executing DMALD or DMAST. Depending on the instruction:
DMALD    0 = MFIFO contains sufficient space
1 = MFIFO is too small to hold the data that DMALD requires.
DMAST    0 = MFIFO contains sufficient data
1 = MFIFO is too small to store the data to enable DMAST to
complete.
This fault is an imprecise abort</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DMA_THREAD_VIOLATING_SECURITY</name>
              <description>Indicates if a DMA channel thread, in the Non-secure state,
attempts to program the CCRn Register
to perform a secure read or secure write:
0 = a DMA channel thread in the Non-secure state is not violating
the security permissions
1 = a DMA channel thread in the Non-secure state attempted to
perform a secure read or secure write.
This fault is a precise abort</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DMA_THREAD_VIOLATING_SECURITY_INTERRUPT</name>
              <description>Indicates if a DMA channel thread, in the Non-secure state,
attempts to execute DMAWFP, DMALDP,
DMASTP, or DMAFLUSHP with inappropriate security permissions:
0 = a DMA channel thread in the Non-secure state is not violating
the security permissions
1 = a DMA channel thread in the Non-secure state attempted to
execute either:
o DMAWFP to wait for a secure peripheral
o DMALDP or DMASTP to notify a secure peripheral
o DMAFLUSHP to flush a secure peripheral.
This fault is a precise abort.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DMA_THREAD_VIOLATING_SECURITY_DMAWFE_DMASEV</name>
              <description>Indicates if the DMA channel thread attempts to execute DMAWFE
or DMASEV with inappropriate security permissions:
0 = a DMA channel thread in the Non-secure state is not violating
the security permissions
1 = a DMA channel thread in the Non-secure state attempted to
execute either:
DMAWFE to wait for a secure event
DMASEV to create a secure event or secure interrupt.
This fault is a precise abort.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DMA_THREAD_OPERAND_VALIDITY</name>
              <description>Indicates if the DMA channel thread was attempting to execute an
instruction operand that was not
valid for the configuration of the DMAC:
0 = valid operand
1 = invalid operand.
This fault is a precise abort.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DMA_THREAD_INSTRUCTION_VALID</name>
              <description>Indicates if the DMA channel thread was attempting to execute an
undefined instruction:
0 = defined instruction
1 = undefined instruction.
This fault is a precise abort</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_FTR1</name>
          <description>Fault Type DMA Channel Register</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>DMAC_FTR2</name>
          <description>Fault Type DMA Channel Register</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>DMAC_FTR3</name>
          <description>Fault Type DMA Channel Register</description>
          <addressOffset>0x4c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>DMAC_FTR4</name>
          <description>Fault Type DMA Channel Register</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>DMAC_FTR5</name>
          <description>Fault Type DMA Channel Register</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>DMAC_FTR6</name>
          <description>Fault Type DMA Channel Register</description>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>DMAC_FTR7</name>
          <description>Fault Type DMA Channel Register</description>
          <addressOffset>0x5c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>DMAC_CSR0</name>
          <description>Channel Status Registers</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMA_CHANNEL_IS_SECURE</name>
              <description>The channel non-secure bit provides the security of the DMA
channel:
0 = DMA channel operates in the Secure state
1 = DMA channel operates in the Non-secure state</description>
              <bitRange>[21:21]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DMAWFP_HAS_PERIPH</name>
              <description>When the DMA channel thread executes DMAWFP this bit indicates
if the periph operand was set:
0 = DMAWFP executed with the periph operand not set
1 = DMAWFP executed with the periph operand set</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DMAWFP_WAS_SINGLE_OR_BURST</name>
              <description>When the DMA channel thread executes DMAWFP this bit indicates
if the burst or single operand were set:
0 = DMAWFP executed with the single operand set
1 = DMAWFP executed with the burst operand set.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DMA_CHANNEL_WAITING_ON_EVENT</name>
              <description>If the DMA channel is in the Waiting for event state or the Waiting
for peripheral state then these bits
indicate the event or peripheral number that the channel is waiting
for:
b00000 = DMA channel is waiting for event, or peripheral, 0
b00001 = DMA channel is waiting for event, or peripheral, 1
b00010 = DMA channel is waiting for event, or peripheral, 2
&#8230;
b11111 = DMA channel is waiting for event, or peripheral, 31</description>
              <bitRange>[8:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DMA_CHANNEL_STATUS</name>
              <description>The channel status encoding is:
b0000 = Stopped
b0001 = Executing
b0010 = Cache miss
b0011 = Updating PC
b0100 = Waiting for event
b0101 = At barrier
b0110 = reserved
b0111 = Waiting for peripheral
b1000 = Killing
b1001 = Completing
b1010-b1101 = reserved
b1110 = Faulting completing
b1111 = Faulting</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CPC0</name>
          <description>Channel Program Counter Registers</description>
          <addressOffset>0x104</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMAC_CPC0</name>
              <description>Program counter for the DMA channel 0 thread</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CSR1</name>
          <description>Channel Status Registers</description>
          <addressOffset>0x108</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>DMAC_CPC1</name>
          <description>Channel Program Counter Registers</description>
          <addressOffset>0x10c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>DMAC_CSR2</name>
          <description>Channel Status Registers</description>
          <addressOffset>0x110</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>DMAC_CPC2</name>
          <description>Channel Program Counter Registers</description>
          <addressOffset>0x114</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>DMAC_CSR3</name>
          <description>Channel Status Registers</description>
          <addressOffset>0x118</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>DMAC_CPC3</name>
          <description>Channel Program Counter Registers</description>
          <addressOffset>0x11c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>DMAC_CSR4</name>
          <description>Channel Status Registers</description>
          <addressOffset>0x120</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>DMAC_CPC4</name>
          <description>Channel Program Counter Registers</description>
          <addressOffset>0x124</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>DMAC_CSR5</name>
          <description>Channel Status Registers</description>
          <addressOffset>0x128</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>DMAC_CPC5</name>
          <description>Channel Program Counter Registers</description>
          <addressOffset>0x12c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>DMAC_CSR6</name>
          <description>Channel Status Registers</description>
          <addressOffset>0x130</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>DMAC_CPC6</name>
          <description>Channel Program Counter Registers</description>
          <addressOffset>0x134</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>DMAC_CSR7</name>
          <description>Channel Status Registers</description>
          <addressOffset>0x138</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>DMAC_CPC7</name>
          <description>Channel Program Counter Registers</description>
          <addressOffset>0x13c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>DMAC_SAR0</name>
          <description>Source Address Registers</description>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMAC_SAR0</name>
              <description>Address of the source data for DMA channel 0</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DAR0</name>
          <description>Destination Address Registers/DestinationAddress Registers</description>
          <addressOffset>0x404</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMAC_DAR0</name>
              <description>Address of the Destination data for DMA channel 0</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CCR0</name>
          <description>Channel Control Registers</description>
          <addressOffset>0x408</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMAC_AWCACHE_WRITE</name>
              <description>Programs the state of AWCACHE[3,1:0]a when the DMAC writes
the destination data.
Bit [27]    0 = AWCACHE[3] is LOW
1 = AWCACHE[3] is HIGH.
Bit [26]    0 = AWCACHE[1] is LOW
1 = AWCACHE[1] is HIGH.
Bit [25]    0 = AWCACHE[0] is LOW
1 = AWCACHE[0] is HIGH</description>
              <bitRange>[27:25]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DMAC_AWPROTO_WRITE</name>
              <description>Programs the state of AWPROT[2:0]a when the DMAC writes the
destination data.
Bit [24]    0 = AWPROT[2] is LOW
1 = AWPROT[2] is HIGH.
Bit [23]    0 = AWPROT[1] is LOW
1 = AWPROT[1] is HIGH.
Bit [22]    0 = AWPROT[0] is LOW
1 = AWPROT[0] is HIGH</description>
              <bitRange>[24:22]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DMAC_MFIFO_WRITE_ON_DMAST</name>
              <description>For each burst, these bits program the number of data transfers
that the DMAC performs when it writes
the destination data:
b0000 = 1 data transfer
b0001 = 2 data transfers
b0010 = 3 data transfers
&#8230;
b1111 = 16 data transfers.
The total number of bytes that the DMAC writes out of the MFIFO
when it executes a DMAST instruction
is the product of dst_burst_len and dst_burst_size</description>
              <bitRange>[21:18]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DMAC_WRITE_PER_BEAT</name>
              <description>For each beat within a burst, it programs the number of bytes that
the DMAC writes to the destination:
b000 = writes 1 byte per beat
b001 = writes 2 bytes per beat
b010 = writes 4 bytes per beat
b011 = writes 8 bytes per beat
b100 = writes 16 bytes per beat
b101-b111 = reserved.
The total number of bytes that the DMAC writes out of the MFIFO
when it executes a DMAST instruction
is the product of dst_burst_len and dst_burst_size.</description>
              <bitRange>[17:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DMAC_BURST_ADDRESS_TYPE</name>
              <description>Programs the burst type that the DMAC performs when it writes the
destination data:
0 = Fixed-address burst. The DMAC signals AWBURST[0] LOW.
1 = Incrementing-address burst. The DMAC signals AWBURST[0]
HIGH.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DMAC_ARCACHE_READ</name>
              <description>Set the bits to control the state of ARCACHE[2:0]a when the DMAC
reads the source data.
Bit [13]    0 = ARCACHE[2] is LOW
1 = ARCACHE[2] is HIGH.
Bit [12]    0 = ARCACHE[1] is LOW
1 = ARCACHE[1] is HIGH.
Bit [11]    0 = ARCACHE[0] is LOW
1 = ARCACHE[0] is HIGH.</description>
              <bitRange>[13:11]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DMAC_ARPROTO_READ</name>
              <description>Programs the state of ARPROT[2:0]a when the DMAC reads the
source data.
Bit [10]    0 = ARPROT[2] is LOW
1 = ARPROT[2] is HIGH.
Bit [9]    0 = ARPROT[1] is LOW
1 = ARPROT[1] is HIGH.
Bit [8]    0 = ARPROT[0] is LOW
1 = ARPROT[0] is HIGH.</description>
              <bitRange>[10:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DMAC_MFIFO_READ_ON_DMALD_XFERS</name>
              <description>For each burst, these bits program the number of data transfers
that the DMAC performs when it reads the source data:
b0000 = 1 data transfer
b0001 = 2 data transfers
b0010 = 3 data transfers
&#8230;
b1111 = 16 data transfers.
The total number of bytes that the DMAC reads into the MFIFO
when it executes a DMALD instruction
is the product of src_burst_len and src_burst_size</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DMAC_MFIFO_READ_ON_DMALD_BYTES</name>
              <description>For each beat within a burst, it programs the number of bytes that
the DMAC reads from the source:
b000 = reads 1 byte per beat
b001 = reads 2 bytes per beat
b010 = reads 4 bytes per beat
b011 = reads 8 bytes per beat
b100 = reads 16 bytes per beat
b101-b111 = reserved.
The total number of bytes that the DMAC reads into the MFIFO
when it executes a DMALD instruction
is the product of src_burst_len and src_burst_size</description>
              <bitRange>[3:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DMAC_BURST_ADDRESS_TYPE_ARBURST</name>
              <description>Programs the burst type that the DMAC performs when it reads the
source data:
0 = Fixed-address burst. The DMAC signals ARBURST[0] LOW.
1 = Incrementing-address burst. The DMAC signals ARBURST[0]
HIGH</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_LC0_0</name>
          <description>Loop Counter 0 Registers</description>
          <addressOffset>0x40c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LOOP_COUNTER_0</name>
              <description>Loop counter 0 iterations</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_LC1_0</name>
          <description>Loop Counter 1 Registers</description>
          <addressOffset>0x410</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LOOP_COUNTER_1</name>
              <description>Loop counter 1 iterations</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_SAR1</name>
          <description>Source Address Registers</description>
          <addressOffset>0x420</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>DMAC_DAR1</name>
          <description>Destination Address Registers</description>
          <addressOffset>0x424</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>DMAC_CCR1</name>
          <description>Channel Control Registers</description>
          <addressOffset>0x428</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>DMAC_LC0_1</name>
          <description>Loop Counter 0 Registers</description>
          <addressOffset>0x42c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>DMAC_LC1_1</name>
          <description>Loop Counter 1 Registers</description>
          <addressOffset>0x430</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>DMAC_SAR2</name>
          <description>Source Address Registers</description>
          <addressOffset>0x440</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>DMAC_DAR2</name>
          <description>Destination Address Registers</description>
          <addressOffset>0x444</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>DMAC_CCR2</name>
          <description>Channel Control Registers</description>
          <addressOffset>0x448</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>DMAC_LC0_2</name>
          <description>Loop Counter 0 Registers</description>
          <addressOffset>0x44c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>DMAC_LC1_2</name>
          <description>Loop Counter 1 Registers</description>
          <addressOffset>0x450</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>DMAC_SAR3</name>
          <description>Source Address Registers</description>
          <addressOffset>0x460</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>DMAC_DAR3</name>
          <description>Destination Address Registers</description>
          <addressOffset>0x464</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>DMAC_CCR3</name>
          <description>Channel Control Registers</description>
          <addressOffset>0x468</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>DMAC_LC0_3</name>
          <description>Loop Counter 0 Registers</description>
          <addressOffset>0x46c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>DMAC_LC1_3</name>
          <description>Loop Counter 1 Registers</description>
          <addressOffset>0x470</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>DMAC_SAR4</name>
          <description>Source Address Registers</description>
          <addressOffset>0x480</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>DMAC_DAR4</name>
          <description>Destination Address Registers</description>
          <addressOffset>0x484</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>DMAC_CCR4</name>
          <description>Channel Control Registers</description>
          <addressOffset>0x488</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>DMAC_LC0_4</name>
          <description>Loop Counter 0 Registers</description>
          <addressOffset>0x48c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>DMAC_LC1_4</name>
          <description>Loop Counter 1 Registers</description>
          <addressOffset>0x490</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>DMAC_SAR5</name>
          <description>Source Address Registers</description>
          <addressOffset>0x4a0</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>DMAC_DAR5</name>
          <description>Destination Address Registers</description>
          <addressOffset>0x4a4</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>DMAC_CCR5</name>
          <description>Channel Control Registers</description>
          <addressOffset>0x4a8</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>DMAC_LC0_5</name>
          <description>Loop Counter 0 Registers</description>
          <addressOffset>0x4ac</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>DMAC_LC1_5</name>
          <description>Loop Counter 1 Registers</description>
          <addressOffset>0x4b0</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>DMAC_SAR6</name>
          <description>Source Address Registers</description>
          <addressOffset>0x4c0</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>DMAC_DAR6</name>
          <description>Destination Address Registers</description>
          <addressOffset>0x4c4</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>DMAC_CCR6</name>
          <description>Channel Control Registers</description>
          <addressOffset>0x4c8</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>DMAC_LC0_6</name>
          <description>Loop Counter 0 Registers</description>
          <addressOffset>0x4cc</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>DMAC_LC1_6</name>
          <description>Loop Counter 1 Registers</description>
          <addressOffset>0x4d0</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>DMAC_SAR7</name>
          <description>Source Address Registers</description>
          <addressOffset>0x4e0</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>DMAC_DAR7</name>
          <description>Destination Address Registers</description>
          <addressOffset>0x4e4</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>DMAC_CCR7</name>
          <description>Channel Control Registers</description>
          <addressOffset>0x4e8</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>DMAC_LC0_7</name>
          <description>Loop Counter 0 Registers</description>
          <addressOffset>0x4ec</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>DMAC_LC1_7</name>
          <description>Loop Counter 1 Registers</description>
          <addressOffset>0x4f0</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>DMAC_DBGSTATUS</name>
          <description>Debug Status Register</description>
          <addressOffset>0xd00</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EXECUTE_DBGINST</name>
              <description>The debug encoding is as follows:
b00 = execute the instruction that the DBGINST [1:0] Registers
contain
b01 = reserved
b10 = reserved
b11 = reserved.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DBGCMD</name>
          <description>Debug Command Register</description>
          <addressOffset>0xd04</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DEBUG_DBGINST2</name>
              <description>The debug encoding is as follows:
b00 = execute the instruction that the DBGINST [1:0] Registers
contain
b01 = reserved
b10 = reserved
b11 = reserved</description>
              <bitRange>[1:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DBGINST0</name>
          <description>Debug Instruction-0 Register</description>
          <addressOffset>0xd08</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INSTRUCTION_BYTE_1</name>
              <description>Instruction byte 1</description>
              <bitRange>[31:24]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>INSTRUCTION_BYTE_0</name>
              <description>Instruction byte 0</description>
              <bitRange>[23:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DMA_CHANNEL_NUM</name>
              <description>DMA channel number:
b000 = DMA channel 0
b001 = DMA channel 1
b010 = DMA channel 2
&#8230;
b111 = DMA channel 7</description>
              <bitRange>[10:8]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DMA_DEBUG_THREAD_TYPE</name>
              <description>The debug thread encoding is as follows:
0 = DMA manager thread
1 = DMA channel.</description>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DBGINST1</name>
          <description>Debug Instruction-1 Register</description>
          <addressOffset>0xd0c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INSTRUCTION_BYTE_5</name>
              <description>Instruction byte 5</description>
              <bitRange>[31:24]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>INSTRUCTION_BYTE_4</name>
              <description>Instruction byte 4</description>
              <bitRange>[23:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>INSTRUCTION_BYTE_3</name>
              <description>Instruction byte 3</description>
              <bitRange>[15:8]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>INSTRUCTION_BYTE_2</name>
              <description>Instruction byte 2</description>
              <bitRange>[7:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CR0</name>
          <description>Configuration Register 0</description>
          <addressOffset>0xe00</addressOffset>
          <size>32</size>
          <resetValue>0x47051</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMAC_NUM_INTERRUPT_OUPUTS</name>
              <description>Number of interrupt outputs that the DMAC provides:
b00000 = 1 interrupt output, irq[0]
b00001 = 2 interrupt outputs, irq[1:0]
b00010 = 3 interrupt outputs, irq[2:0]
&#8230;
b11111 = 32 interrupt outputs, irq[31:0].</description>
              <bitRange>[21:17]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DMAC_NUM_PERIPHERAL_REQ_INTERFACES</name>
              <description>Number of peripheral request interfaces that the DMAC provides:
b00000 = 1 peripheral request interface
b00001 = 2 peripheral request interfaces
b00010 = 3 peripheral request interfaces
&#8230;
b11111 = 32 peripheral request interfaces.</description>
              <bitRange>[16:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DMAC_NUM_CHANNELS</name>
              <description>Number of DMA channels that the DMAC supports:
b000 = 1 DMA channel
b001 = 2 DMA channels
b010 = 3 DMA channels
&#8230;
b111 = 8 DMA channels.</description>
              <bitRange>[6:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DMAC_BOOT_MANAGER_NS_STATUS</name>
              <description>Indicates the status of the boot_manager_ns signal when the
DMAC exited from reset:
0 = boot_manager_ns was LOW
1 = boot_manager_ns was HIGH.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DMAC_BOOT_FROM_PC_STATUS</name>
              <description>Indicates the status of the boot_from_pc signal when the DMAC
exited from reset:
0 = boot_from_pc was LOW
1 = boot_from_pc was HIGH</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DMAC_SUPPORTS_PERIPHERAL_REQ_INTERFACE</name>
              <description>Supports peripheral requests:
0 = the DMAC does not provide a peripheral request interface
1 = the DMAC provides the number of peripheral request interfaces
that the num_periph_req field specifies.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CR1</name>
          <description>Configuration Register 1</description>
          <addressOffset>0xe04</addressOffset>
          <size>32</size>
          <resetValue>0x57</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ICACHE_LINE_NUM</name>
              <description>[7:4] num_i-cache_lines Number of i-cache lines:
b0000 = 1 i-cache line
b0001 = 2 i-cache lines
b0010 = 3 i-cache lines
&#8230;
b1111 = 16 i-cache lines.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ICACHE_LINE_SIZE</name>
              <description>The length of an i-cache line:
b000-b001 = reserved
b010 = 4 bytes
b011 = 8 bytes
b100 = 16 bytes
b101 = 32 bytes
b110-b111 = reserved</description>
              <bitRange>[2:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CR2</name>
          <description>Configuration Register 2</description>
          <addressOffset>0xe08</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMAC_CR2</name>
              <description>Provides the value of boot_addr[31:0] when the DMAC exited from</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CR3</name>
          <description>Configuration Register 3</description>
          <addressOffset>0xe0c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMAC_CR3</name>
              <description>Provides the security state of an event-interrupt resource:</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CR4</name>
          <description>Configuration Register 4</description>
          <addressOffset>0xe10</addressOffset>
          <size>32</size>
          <resetValue>0x6</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMAC_CR4</name>
              <description>Provides the security state of the peripheral request interfaces:</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CRDn</name>
          <description>DMA Configuration Register</description>
          <addressOffset>0xe14</addressOffset>
          <size>32</size>
          <resetValue>0x2094733</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>DMAC_WD</name>
          <description>DMA Watchdog Register</description>
          <addressOffset>0xe80</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMAC_LOCKUP_ACTION</name>
              <description>Controls how the DMAC responds when it detects a lock-up
condition:
0 = the DMAC aborts all of the contributing DMA channels and sets
irq_abort HIGH
1 = the DMAC sets irq_abort HIGH.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="DMAC0">
      <name>DMAC1</name>
      <version>1.0</version>
      <groupname>DMAC</groupname>
      <baseAddress>0xff6e0000</baseAddress>
    </peripheral>
    <peripheral>
      <name>TIMER0</name>
      <version>1.0</version>
      <groupname>TIMER</groupname>
      <baseAddress>0xff850000</baseAddress>
      <registers>
        <register>
          <name>TIMER_n_LOAD_COUNT0</name>
          <description>Timer n higher Load Count Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>TIMER_n_LOAD_COUNT1</name>
          <description>Timer n higher Load Count Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>TIMER_n_CURRENT_VALUE0</name>
          <description>Timer n Current Value Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>TIMER_n_CURRENT_VALUE1</name>
          <description>Timer n Current Value Register</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>TIMER_n_LOAD_COUNT2</name>
          <description>Timer n lower Load Count Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>TIMER_n_LOAD_COUNT3</name>
          <description>Timer n lower Load Count Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>TIMER_n_INTSTATUS</name>
          <description>Timer Interrupt Stauts Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>TIMER_n_CONTROLREG</name>
          <description>Timer n Control Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="TIMER0">
      <name>TIMER1</name>
      <version>1.0</version>
      <groupname>TIMER</groupname>
      <baseAddress>0xff850020</baseAddress>
    </peripheral>
    <peripheral derivedFrom="TIMER0">
      <name>TIMER2</name>
      <version>1.0</version>
      <groupname>TIMER</groupname>
      <baseAddress>0xff850040</baseAddress>
    </peripheral>
    <peripheral derivedFrom="TIMER0">
      <name>TIMER3</name>
      <version>1.0</version>
      <groupname>TIMER</groupname>
      <baseAddress>0xff850060</baseAddress>
    </peripheral>
    <peripheral derivedFrom="TIMER0">
      <name>TIMER4</name>
      <version>1.0</version>
      <groupname>TIMER</groupname>
      <baseAddress>0xff850080</baseAddress>
    </peripheral>
    <peripheral derivedFrom="TIMER0">
      <name>TIMER5</name>
      <version>1.0</version>
      <groupname>TIMER</groupname>
      <baseAddress>0xff850100</baseAddress>
    </peripheral>
    <peripheral derivedFrom="TIMER0">
      <name>TIMER6</name>
      <version>1.0</version>
      <groupname>TIMER</groupname>
      <baseAddress>0xff858000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="TIMER0">
      <name>TIMER7</name>
      <version>1.0</version>
      <groupname>TIMER</groupname>
      <baseAddress>0xff858020</baseAddress>
    </peripheral>
    <peripheral derivedFrom="TIMER0">
      <name>TIMER8</name>
      <version>1.0</version>
      <groupname>TIMER</groupname>
      <baseAddress>0xff858040</baseAddress>
    </peripheral>
    <peripheral derivedFrom="TIMER0">
      <name>TIMER9</name>
      <version>1.0</version>
      <groupname>TIMER</groupname>
      <baseAddress>0xff858060</baseAddress>
    </peripheral>
    <peripheral derivedFrom="TIMER0">
      <name>TIMER10</name>
      <version>1.0</version>
      <groupname>TIMER</groupname>
      <baseAddress>0xff858080</baseAddress>
    </peripheral>
    <peripheral derivedFrom="TIMER0">
      <name>TIMER11</name>
      <version>1.0</version>
      <groupname>TIMER</groupname>
      <baseAddress>0xff858100</baseAddress>
    </peripheral>
    <peripheral derivedFrom="TIMER0">
      <name>STIMER0</name>
      <version>1.0</version>
      <groupname>TIMER</groupname>
      <baseAddress>0xff860000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="TIMER0">
      <name>STIMER1</name>
      <version>1.0</version>
      <groupname>TIMER</groupname>
      <baseAddress>0xff860020</baseAddress>
    </peripheral>
    <peripheral derivedFrom="TIMER0">
      <name>STIMER2</name>
      <version>1.0</version>
      <groupname>TIMER</groupname>
      <baseAddress>0xff860040</baseAddress>
    </peripheral>
    <peripheral derivedFrom="TIMER0">
      <name>STIMER3</name>
      <version>1.0</version>
      <groupname>TIMER</groupname>
      <baseAddress>0xff860060</baseAddress>
    </peripheral>
    <peripheral derivedFrom="TIMER0">
      <name>STIMER4</name>
      <version>1.0</version>
      <groupname>TIMER</groupname>
      <baseAddress>0xff860080</baseAddress>
    </peripheral>
    <peripheral derivedFrom="TIMER0">
      <name>STIMER5</name>
      <version>1.0</version>
      <groupname>TIMER</groupname>
      <baseAddress>0xff860100</baseAddress>
    </peripheral>
    <peripheral derivedFrom="TIMER0">
      <name>STIMER6</name>
      <version>1.0</version>
      <groupname>TIMER</groupname>
      <baseAddress>0xff868000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="TIMER0">
      <name>STIMER7</name>
      <version>1.0</version>
      <groupname>TIMER</groupname>
      <baseAddress>0xff868020</baseAddress>
    </peripheral>
    <peripheral derivedFrom="TIMER0">
      <name>STIMER8</name>
      <version>1.0</version>
      <groupname>TIMER</groupname>
      <baseAddress>0xff868040</baseAddress>
    </peripheral>
    <peripheral derivedFrom="TIMER0">
      <name>STIMER9</name>
      <version>1.0</version>
      <groupname>TIMER</groupname>
      <baseAddress>0xff868060</baseAddress>
    </peripheral>
    <peripheral derivedFrom="TIMER0">
      <name>STIMER10</name>
      <version>1.0</version>
      <groupname>TIMER</groupname>
      <baseAddress>0xff868080</baseAddress>
    </peripheral>
    <peripheral derivedFrom="TIMER0">
      <name>STIMER11</name>
      <version>1.0</version>
      <groupname>TIMER</groupname>
      <baseAddress>0xff868100</baseAddress>
    </peripheral>
    <peripheral derivedFrom="TIMER0">
      <name>PMUTIMER0</name>
      <version>1.0</version>
      <groupname>TIMER</groupname>
      <baseAddress>0xff360000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="TIMER0">
      <name>PMUTIMER1</name>
      <version>1.0</version>
      <groupname>TIMER</groupname>
      <baseAddress>0xff360020</baseAddress>
    </peripheral>
    <peripheral>
      <name>GRF</name>
      <version>1.0</version>
      <groupname>GRF</groupname>
      <baseAddress>0xff770000</baseAddress>
      <registers>
        <register>
          <name>GRF_USB3_PERF_CON0</name>
          <description>usb3 performance monitor control register</description>
          <addressOffset>0x2000</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>USB3_RKSOC_AXI_PERF_SEL</name>
              <description>0: usb3otg0
1: usb3otg1</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>USB3_SW_RD_LATENCY_ID</name>
              <description>Axi read channel id for latency
AXI_PERFormance test</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>USB3_SW_DDR_ALIGN_TYPE</name>
              <description>0: 16-Byte align
1: 32-Byte align
2: 64-Byte align
3: 128-Byte align</description>
              <bitRange>[6:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>USB3_SW_AW_CNT_ID_TYPE</name>
              <description>axi_perf counter id control
0: count all read channel id
1: count sw_ar_count_id read channel only</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>USB3_SW_AR_CNT_ID_TYPE</name>
              <description>axi_perf counter id control
0: count all read channel id
1: count sw_ar_count_id read channel only</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>USB3_SW_AXI_CNT_TYPE</name>
              <description>axi_perf counter type
0: axi transfer test
1: ddr align transfer test</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>USB3_SW_AXI_PERF_CLR</name>
              <description>Fi
axi_perf clear bit
0: disable
1: enable</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>USB3_SW_AXI_PERF_WORK</name>
              <description>axi_perf enable bit
0: disable
1: enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_USB3_PERF_CON1</name>
          <description>usb3 performance monitor control register</description>
          <addressOffset>0x2004</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>USB3_SW_RD_LATENCY_THR</name>
              <description>Axi read channel id for latency
AXI_PERFormance test</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_USB3_PERF_CON2</name>
          <description>usb3 performance monitor control register</description>
          <addressOffset>0x2008</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>USB3_SW_AW_COUNT_ID</name>
              <description>When    sw_aw_cnt_id_type=1,    only    count
the    id designated by sw_aw_count_id</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>USB3_SW_AR_COUNT_ID</name>
              <description>When    sw_ar_cnt_id_type=1,    only    count
the    id designated by sw_ar_count_id</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_USB3_PERF_RD_MAX_LATENCY_NUM</name>
          <description>usb3 performance monitor status register</description>
          <addressOffset>0x200c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RD_MAX_LATENCY_R</name>
              <description>axi read max latency oaxi read max latency
outpututput</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_USB3_PERF_RD_LATENCY_SAMP_NUM</name>
          <description>usb3 performance monitor status register</description>
          <addressOffset>0x2010</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RD_LATENCY_SAMP_R</name>
              <description>AXI read latency total sample number</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_USB3_PERF_RD_LATENCY_ACC_NUM</name>
          <description>usb3 performance monitor status register</description>
          <addressOffset>0x2014</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RD_LATENCY_ACC_CNT_R</name>
              <description>AXI    read    latency    (&gt;sw_rd_latency_thr)
total number</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_USB3_PERF_RD_AXI_TOTAL_BYTE</name>
          <description>usb3 performance monitor status register</description>
          <addressOffset>0x2018</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RD_AXI_TOTAL_BYTE</name>
              <description>AXI active total read bytes/ddr align read
bytes</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_USB3_PERF_WR_AXI_TOTAL_BYTE</name>
          <description>usb3 performance monitor status register</description>
          <addressOffset>0x201c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WR_AXI_TOTAL_BYTE</name>
              <description>AXI active total write bytes/ddr align write
bytes</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_USB3_PERF_WORKING_CNT</name>
          <description>usb3 performance monitor status register</description>
          <addressOffset>0x2020</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WORKING_CNT_R</name>
              <description>working counter</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_USB3OTG0_CON0</name>
          <description>USB3 OTG0 GRF Register0</description>
          <addressOffset>0x2430</addressOffset>
          <size>32</size>
          <resetValue>0x2000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HOST_U2_PORT_DISABLE</name>
              <description>host_u2_port_disable
USB2.0 Port Disable control.
0: Port Enabled
1: Port Disabled When 1, this signal stops
reporting connect/disconnect events the port
and keeps the port in disabled state.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HOST_PORT_POWER_CONTROL_PRESENT</name>
              <description>host_port_power_control_present
This indicates whether the host controller
implementation includes port power control.
0: Indicates that the port does not have port
power switches.
1: Indicates that the port has port power
switches</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLADJ_30MHZ_REG</name>
              <description>fladj_30mhz_reg
HS Jitter Adjustment. Indicates the correction
required to accommodate mac3 clock and
utmi clock jitter to measure 125 's duration.
With fladj_30mhz_reg tied to zero, the high
speed 125us micro-frame is counted for
123933ns. You must program the value in
terms of high speed bit times in a 30 MHz
cycle. The default value that must be driven is
32 (assuming 30 MHz perfect clock).</description>
              <bitRange>[13:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HUB_PORT_PERM_ATTACH</name>
              <description>hub_port_perm_attach
Indicates if the device attached to a
downstream port is permanently attached or
not.
0: Not permanently attached
1: Permanently attached
Bit0 is for USB2.0 port and bit1 are for USB
3.0 SS port.</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HUB_PORT_OVERCURRENT</name>
              <description>hub_port_overcurrent
This is the per port Overcurrent indication of
the root-hub ports:
0: No Overcurrent
1: Overcurrent
Bit0 is for USB 2.0 port and bit1 are for USB
3.0 SS port.</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUS_FILTER_BYPASS</name>
              <description>bus_filter_bypass
It is expected that this signal is set or reset at
power-on reset and is not changed during the
normal
operation of the core. The function of each bit
is:
bus_filter_bypass[3]: Bypass the filter for
utmiotg_iddig
bus_filter_bypass[2]: Bypass the filters for
utmisrp_bvalid and utmisrp_sessend
bus_filter_bypass[1]: Bypass the filter for
pipe3_PowerPresent all U3 ports
bus_filter_bypass[0]: Bypass the filter for
utmiotg_vbusvalid all U2 ports
In non-OTG Host-only mode, internal bus
filters are not needed.
Values:
1'b0: Bus filter(s) enabled
1'b1: Bus filter(s) disabled (bypassed)</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_USB3OTG0_CON1</name>
          <description>USB3 OTG0 GRF Register1</description>
          <addressOffset>0x2434</addressOffset>
          <size>32</size>
          <resetValue>0x1100</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HOST_U3_PORT</name>
              <description>host_u3_port
xHCI usb3 port number, default as 1.</description>
              <bitRange>[15:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HOST_U2_PORT</name>
              <description>host_u2_port
xHCI host USB2 Port number, default as 1.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HOST_LEGACY_SMI_BAR</name>
              <description>host_legacy_smi_bar
Use this register to support SMI on BAR
defined in xHCI spec.
SW must set this register, then clear this
register to indicate Base Address Register
written</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HOST_LEGACY_SMI_PCI_CMD</name>
              <description>host_legacy_smi_pci_cmd
Use this register to support SMI on PCI
Command defined in xHCI spec.
SW must set this register, then clear this
register to indicate PCI command register
written.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PME_EN</name>
              <description>pme_en
Enable signal for the pme_generation. Enable
the core to assert pme_generation.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HOST_U3_PORT_DISABLE</name>
              <description>host_u3_port_disable
USB 3.0 SS Port Disable control.
0: Port Enabled
1: Port Disabled</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_USB3OTG1_CON0</name>
          <description>USB3 OTG1 GRF Register0</description>
          <addressOffset>0x2440</addressOffset>
          <size>32</size>
          <resetValue>0x2000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HOST_U2_PORT_DISABLE</name>
              <description>host_u2_port_disable
USB2.0 Port Disable control.
0: Port Enabled
1: Port Disabled When 1, this signal stops
reporting connect/disconnect events the port
and keeps the port in disabled state.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HOST_PORT_POWER_CONTROL_PRESENT</name>
              <description>host_port_power_control_present
This indicates whether the host controller
implementation includes port power control.
0: Indicates that the port does not have port
power switches.
1: Indicates that the port has port power
switches</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLADJ_30MHZ_REG</name>
              <description>fladj_30mhz_reg
HS Jitter Adjustment. Indicates the correction
required to accommodate mac3 clock and
utmi clock jitter to measure 125 's duration.
With fladj_30mhz_reg tied to zero, the high
speed 125us micro-frame is counted for
123933ns. You must program the value in
terms of high speed bit times in a 30 MHz
cycle. The default value that must be driven is
32 (assuming 30 MHz perfect clock).</description>
              <bitRange>[13:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HUB_PORT_PERM_ATTACH</name>
              <description>hub_port_perm_attach
Indicates if the device attached to a
downstream port is permanently attached or
not.
0: Not permanently attached
1: Permanently attached
Bit0 is for USB2.0 port and bit1 are for USB
3.0 SS port.</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HUB_PORT_OVERCURRENT</name>
              <description>hub_port_overcurrent
This is the per port Overcurrent indication of
the root-hub ports:
0: No Overcurrent
1: Overcurrent
Bit0 is for USB 2.0 port and bit1 are for USB
3.0 SS port.</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUS_FILTER_BYPASS</name>
              <description>bus_filter_bypass
It is expected that this signal is set or reset at
power-on reset and is not changed during the
normal
operation of the core. The function of each bit
is:
bus_filter_bypass[3]: Bypass the filter for
utmiotg_iddig
bus_filter_bypass[2]: Bypass the filters for
utmisrp_bvalid and utmisrp_sessend
bus_filter_bypass[1]: Bypass the filter for
pipe3_PowerPresent all U3 ports
bus_filter_bypass[0]: Bypass the filter for
utmiotg_vbusvalid all U2 ports
In non-OTG Host-only mode, internal bus
filters are not needed.
Values:
1'b0: Bus filter(s) enabled
1'b1: Bus filter(s) disabled (bypassed)</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_USB3OTG1_CON1</name>
          <description>USB3 OTG1 GRF Register1</description>
          <addressOffset>0x2444</addressOffset>
          <size>32</size>
          <resetValue>0x1100</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HOST_U3_PORT</name>
              <description>host_u3_port
xHCI usb3 port number, default as 1.</description>
              <bitRange>[15:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HOST_U2_PORT</name>
              <description>host_u2_port
xHCI host USB2 port number, default as 1.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HOST_LEGACY_SMI_BAR</name>
              <description>host_legacy_smi_bar
Use this register to support SMI on BAR
defined in xHCI spec.
SW must set this register, then clear this
register to indicate Base Address Register
written</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HOST_LEGACY_SMI_PCI_CMD</name>
              <description>host_legacy_smi_pci_cmd
Use this register to support SMI on PCI
Command defined in xHCI spec.
SW must set this register, then clear this
register to indicate PCI command register
written.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PME_EN</name>
              <description>pme_en
Enable signal for the pme_generation. Enable
the core to assert pme_generation.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HOST_U3_PORT_DISABLE</name>
              <description>host_u3_port_disable
USB 3.0 SS Port Disable control.
0: Port Enabled
1: Port Disabled</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_USB3OTG0_STATUS_LAT0</name>
          <description>USB3 OTG0 status register</description>
          <addressOffset>0x2450</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>USBCPHY0_OTG_UTMI_IDDIG</name>
              <description>status of usbcphy0_otg_utmi_iddig[31:0]</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_USB3OTG0_STATUS_LAT1</name>
          <description>USB3 OTG1 status register</description>
          <addressOffset>0x2454</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>USBCPHY0_OTG_UTMI_IDDIG</name>
              <description>status of usbcphy0_otg_utmi_iddig[63:32]</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_USB3OTG0_STATUS_CB</name>
          <description>USB3 OTG0 status register</description>
          <addressOffset>0x2458</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>USB3OTG0_HOST_CURRENT_BELT</name>
              <description>status of usb3otg0_host_current_belt</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_USB3OTG1_STATUS_LAT0</name>
          <description>USB3 OTG1 status register</description>
          <addressOffset>0x2460</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>USBCPHY1_OTG_UTMI_IDDIG</name>
              <description>status of usbcphy1_otg_utmi_iddig[31:0]</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_USB3OTG1_STATUS_LAT1</name>
          <description>USB3 OTG1 status register</description>
          <addressOffset>0x2464</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>USBCPHY1_OTG_UTMI_IDDIG</name>
              <description>status of usbcphy1_otg_utmi_iddig[63:32]</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_USB3OTG1_STATUS_CB</name>
          <description>USB3 OTG1 status register</description>
          <addressOffset>0x2468</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>USB3OTG1_HOST_CURRENT_BELT</name>
              <description>status of usb3otg1_host_current_belt</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_PCIE_PERF_CON0</name>
          <description>pcie performance monitor control register</description>
          <addressOffset>0x4000</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCIE_SW_RD_LATENCY_ID</name>
              <description>Axi read channel id for latency
AXI_PERFormance test</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCIE_SW_DDR_ALIGN_TYPE</name>
              <description>0: 16-Byte align
1: 32-Byte align
2: 64-Byte align
3: 128-Byte align</description>
              <bitRange>[6:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCIE_SW_AW_CNT_ID_TYPE</name>
              <description>0: count all write channels
1: count sw_aw_count_id write channel only</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCIE_SW_AR_CNT_ID_TYPE</name>
              <description>axi_perf counter id control
0: count all read channel id
1: count sw_ar_count_id read channel only</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCIE_SW_AXI_CNT_TYPE</name>
              <description>axi_perf counter type
0: axi transfer test
1: ddr align transfer test</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCIE_SW_AXI_PERF_CLR</name>
              <description>axi_perf clear bit
0: disable
1: enable</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCIE_SW_AXI_PERF_WORK</name>
              <description>axi_perf enable bit
0: disable
1: enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_PCIE_PERF_CON1</name>
          <description>pcie performance monitor control register</description>
          <addressOffset>0x4004</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCIE_SW_RD_LATENCY_THR</name>
              <description>Axi read channel id for latency
AXI_PERFormance test</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_PCIE_PERF_CON2</name>
          <description>pcie performance monitor control register</description>
          <addressOffset>0x4008</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCIE_SW_AW_COUNT_ID</name>
              <description>When    sw_aw_cnt_id_type=1,    only    count
the    id designated by sw_aw_count_id</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCIE_SW_AR_COUNT_ID</name>
              <description>When    sw_ar_cnt_id_type=1,    only    count
the    id designated by sw_ar_count_id</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_PCIE_PERF_RD_MAX_LATENCY_NUM</name>
          <description>pcieperformance monitor status register</description>
          <addressOffset>0x400c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RD_MAX_LATENCY_R</name>
              <description>axi read max latency output</description>
              <bitRange>[12:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_PCIE_PERF_RD_LATENCY_SAMP_NUM</name>
          <description>pcie performance monitor status register</description>
          <addressOffset>0x4010</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RD_LATENCY_SAMP_R</name>
              <description>AXI read latency total sample number</description>
              <bitRange>[26:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_PCIE_PERF_RD_LATENCY_ACC_NUM</name>
          <description>pcie performance monitor status register</description>
          <addressOffset>0x4014</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RD_LATENCY_ACC_CNT_R</name>
              <description>AXI    read    latency    (&gt;sw_rd_latency_thr)
total number</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_PCIE_PERF_RD_AXI_TOTAL_BYTE</name>
          <description>pcie performance monitor status register</description>
          <addressOffset>0x4018</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RD_AXI_TOTAL_BYTE</name>
              <description>AXI active total read bytes/ddr align read
bytes</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_PCIE_PERF_WR_AXI_TOTAL_BYTE</name>
          <description>pcie performance monitor status register</description>
          <addressOffset>0x401c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WR_AXI_TOTAL_BYTE</name>
              <description>AXI active total write bytes/ddr align write
bytes</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_PCIE_PERF_WORKING_CNT</name>
          <description>pcie performance monitor status register</description>
          <addressOffset>0x4020</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WORKING_CNT_R</name>
              <description>working counter</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_USB20_HOST0_CON0</name>
          <description>USB20 Host0 GRF register0</description>
          <addressOffset>0x4100</addressOffset>
          <size>32</size>
          <resetValue>0x23e0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WORD_IF</name>
              <description>word_if
1: select 16bit utmi interface
0: select 8bit utmi interface
Note: usb2phy only support 16bit interface.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SIM_MODE</name>
              <description>sim_mode
Simulation only.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OHCI_SUSP_LGCY</name>
              <description>ohci_susp_lgcy
</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OHCI_CNTSEL</name>
              <description>ohci_cntsel
</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OHCI_CLKCKTRST</name>
              <description>ohci_clkcktrst
</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INCRX_EN</name>
              <description>incrx_en
Forces AHB master to start INCR4/8/16 busts
only on burst boundaries. AHB requires that
double word width burst be addressed-aligned
only to the double-word boundary.
1'b1: Start INCRX burst only on burst
x-aligned addresses
1'b0: Normal AHB operation; start bursts on
any double word boundary
Note: When this function is enabled, the burst
are started only when the lowest bits of haddr
are:
INCR4: haddr[3:0] == 4'b0000
INCR8: haddr[4:0] == 5'b00000
INCR16: haddr[5:0] == 6'b000000</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INCR8_EN</name>
              <description>incr8_en
1: enable AHB INCR8 burst
0: disable AHB INCR8 burst</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INCR4_EN</name>
              <description>incr4_en
1: enable AHB INCR4 burst
0: disable AHB INCR4 burst</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INCR16_EN</name>
              <description>incr16_en
1: enable AHB INCR16 burst
0: disable AHB INCR16 burst</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HUBSETUP_MIN</name>
              <description>hubsetup_min
</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTOPPD_ON_OVERCUR_EN</name>
              <description>autoppd_on_overcur_en
</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARB_PAUSE</name>
              <description>arb_pause
</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>APP_START_CLK</name>
              <description>app_start_clk
</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>APP_PRT_OVRCUR</name>
              <description>app_prt_ovrcur
</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_USB20_HOST0_CON1</name>
          <description>USB20 Host0 GRF register1</description>
          <addressOffset>0x4104</addressOffset>
          <size>32</size>
          <resetValue>0x820</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLADJ_VAL_COMMON</name>
              <description>fladj_val_common
Must set this register to 0x20.</description>
              <bitRange>[11:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLADJ_VAL</name>
              <description>fladj_val
Must set this register to 0x20.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_USB20_HOST1_CON0</name>
          <description>USB20 Host1 GRF register0</description>
          <addressOffset>0x4110</addressOffset>
          <size>32</size>
          <resetValue>0x23e0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WORD_IF</name>
              <description>word_if
1: select 16bit utmi interface
0: select 8bit utmi interface
Note: usb2phy only support 16bit interface.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SIM_MODE</name>
              <description>sim_mode
Simulation only.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OHCI_SUSP_LGCY</name>
              <description>ohci_susp_lgcy
</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OHCI_CNTSEL</name>
              <description>ohci_cntsel
</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OHCI_CLKCKTRST</name>
              <description>ohci_clkcktrst
</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INCRX_EN</name>
              <description>incrx_en
Forces AHB master to start INCR4/8/16 busts
only on burst boundaries. AHB requires that
double word width burst be addressed-aligned
only to the double-word boundary.
1'b1: Start INCRX burst only on burst
x-aligned addresses
1'b0: Normal AHB operation; start bursts on
any double word boundary
Note: When this function is enabled, the burst
are started only when the lowest bits of haddr
are:
INCR4: haddr[3:0] == 4'b0000
INCR8: haddr[4:0] == 5'b00000
INCR16: haddr[5:0] == 6'b000000</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INCR8_EN</name>
              <description>incr8_en
1: enable AHB INCR8 burst
0: disable AHB INCR8 burst</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INCR4_EN</name>
              <description>incr4_en
1: enable AHB INCR4 burst
0: disable AHB INCR4 burst</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INCR16_EN</name>
              <description>incr16_en
1: enable AHB INCR16 burst
0: disable AHB INCR16 burst</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HUBSETUP_MIN</name>
              <description>hubsetup_min
</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTOPPD_ON_OVERCUR_EN</name>
              <description>autoppd_on_overcur_en
</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARB_PAUSE</name>
              <description>arb_pause
</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>APP_START_CLK</name>
              <description>app_start_clk
</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>APP_PRT_OVRCUR</name>
              <description>app_prt_ovrcur
</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_USB20_HOST1_CON1</name>
          <description>USB20 Host1 GRF register1</description>
          <addressOffset>0x4114</addressOffset>
          <size>32</size>
          <resetValue>0x820</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLADJ_VAL_COMMON</name>
              <description>fladj_val_common
Must set this register to 0x20.</description>
              <bitRange>[11:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLADJ_VAL</name>
              <description>fladj_val
Must set this register to 0x20.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_HSIC_CON0</name>
          <description>HSIC controller GRF register 0</description>
          <addressOffset>0x4120</addressOffset>
          <size>32</size>
          <resetValue>0x2f0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HSIC_WORD_IF</name>
              <description>word_if
1: select 16bit utmi interface
0: select 8bit utmi interface
Note: HSICPHY only support 16bit utmi
interface.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HSIC_SIM_MODE</name>
              <description>sim_mode
Simulation only.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HSIC_INCRX_EN</name>
              <description>Burst Alignment Enable
Forces AHB master to start INCR4/8/16 busts
only on burst boundaries. AHB requires that
double word width burst be addressed-aligned
only to the double-word boundary.
1'b1: Start INCRX burst only on burst
x-aligned addresses
1'b0: Normal AHB operation; start bursts on
any double word boundary
Note: When this function is enabled, the burst
are started only when the lowest bits of haddr
are:
INCR4: haddr[3:0] == 4'b0000
INCR8: haddr[4:0] == 5'b00000
INCR16: haddr[5:0] == 6'b000000</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HSIC_INCR8_EN</name>
              <description>incr8_en
1: enable AHB INCR8 burst
0: disable AHB INCR8 burst</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HSIC_INCR4_EN</name>
              <description>incr4_en
1: enable AHB INCR4 burst
0: disable AHB INCR4 burst</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HSIC_INCR16_EN</name>
              <description>incr16_en
1: enable AHB INCR16 burst
0: disable AHB INCR16 burst</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HSIC_HUBSETUP_MIN</name>
              <description>hubsetup_min
</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HSIC_AUTOPPD_ON_OVERCUR</name>
              <description>autoppd_on_overcur
</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HSIC_APP_START_CLK</name>
              <description>app_start_clk
</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HSIC_APP_PRT_OVRCUR</name>
              <description>app_prt_ovrcur
</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_HSIC_CON1</name>
          <description>HSIC controller GRF register1</description>
          <addressOffset>0x4124</addressOffset>
          <size>32</size>
          <resetValue>0x820</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HSIC_FLADJ_VAL_COMMON</name>
              <description>fladj_val_common
Must set this register to 0x20</description>
              <bitRange>[11:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HSIC_FLADJ</name>
              <description>fladj
Must set this register to 0x20.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GRF_USBHOST0_STATUS</name>
          <description>usb host0 controller status register</description>
          <addressOffset>0x4140</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HOST0_EHCI_BUFACC</name>
              <description>host0_ehci_bufacc
</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HOST0_EHCI_XFER_PRDC</name>
              <description>host0_ehci_xfer_prdc
</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HOST0_OHCI_BUFACC</name>
              <description>host0_ohci_bufacc
</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HOST0_OHCI_CCS</name>
              <description>host0_ohci_ccs
</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HOST0_OHCI_DRWE</name>
              <description>host0_ohci_drwe
</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HOST0_OHCI_GLOBALSUSPEND</name>
              <description>host0_ohci_globalsuspend
</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HOST0_OHCI_RMTWKP</name>
              <description>host0_ohci_rmtwkp
</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HOST0_OHCI_RWE</name>
              <description>host0_ohci_rwe
</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HOST0_EHCI_LPSMC_STATE</name>
              <description>host0_ehci_lpsmc_state
</description>
              <bitRange>[20:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HOST0_EHCI_USBSTS</name>
              <description>host0_ehci_usbsts
</description>
              <bitRange>[16:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HOST0_EHCI_XFER_CNT</name>
              <description>host0_ehci_xfer_cnt
</description>
              <bitRange>[10:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GRF_USBHOST1_STATUS</name>
          <description>usb host1 controller status register</description>
          <addressOffset>0x4144</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HOST1_EHCI_BUFACC</name>
              <description>host1_ehci_bufacc
</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HOST1_EHCI_XFER_PRDC</name>
              <description>host1_ehci_xfer_prdc
</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HOST1_OHCI_BUFACC</name>
              <description>host1_ohci_bufacc
</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HOST1_OHCI_CCS</name>
              <description>host1_ohci_ccs
</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HOST1_OHCI_DRWE</name>
              <description>host1_ohci_drwe
</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HOST1_OHCI_GLOBALSUSPEND</name>
              <description>host1_ohci_globalsuspend
</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HOST1_OHCI_RMTWKP</name>
              <description>host1_ohci_rmtwkp
</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HOST1_OHCI_RWE</name>
              <description>host1_ohci_rwe
</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HOST1_EHCI_LPSMC_STATE</name>
              <description>host1_ehci_lpsmc_state
</description>
              <bitRange>[20:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HOST1_EHCI_USBSTS</name>
              <description>host1_ehci_usbsts
</description>
              <bitRange>[16:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HOST1_EHCI_XFER_CNT</name>
              <description>host1_ehci_xfer_cnt
</description>
              <bitRange>[10:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GRF_HSIC_STATUS</name>
          <description>hsic controller status register</description>
          <addressOffset>0x4148</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HSIC_EHCI_XFER_PRDC</name>
              <description>hsic_ehci_xfer_prdc
</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HSIC_EHCI_LPSMS_STATE</name>
              <description>hsic_ehci_lpsms_state
</description>
              <bitRange>[20:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HSIC_EHCI_USBSTS</name>
              <description>hsic_ehci_usbsts
</description>
              <bitRange>[16:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HSIC_EHCI_XFER_CNT</name>
              <description>hsic_ehci_xfer_cnt
</description>
              <bitRange>[10:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_HSICPHY_CON0</name>
          <description>HSICPHY GRF control register</description>
          <addressOffset>0x4470</addressOffset>
          <size>32</size>
          <resetValue>0x4f</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HSICPHY_SOFT_CON_SEL</name>
              <description>soft_con_sel
1: soft control select utmi signals from GRF to
HSIC PHY
0: soft control select utmi signals from HSIC
controller to HSIC PHY</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I_HSIC_UTMI_XCVRSELECT</name>
              <description>utmi_xcvrselect
select the value of this register to xcvrselect
port of HSIC PHY when    soft_con_sel=1.</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I_HSIC_UTMI_OPMODE</name>
              <description>utmi_opmode
select the value of this register to opmode
port of HSIC PHY when    soft_con_sel=1</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I_HSIC_UTMI_TERMSELECT</name>
              <description>utmi_termselect
select the value of this register to termselect
port of HSIC PHY when    soft_con_sel=1</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I_HSIC_UTMI_SUSPEND_N</name>
              <description>utmi_suspend_n
select the value of this register to ususpend_n
port of HSIC PHY when    soft_con_sel=1</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HSICPHY_UTMI_DMPULLDOWN</name>
              <description>utmi_dmpulldown
1:DM pull down resistor enable
0:DM pull down resistor disable</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HSICPHY_UTMI_DPPULLDOWN</name>
              <description>utmi_dppulldown
1:DP pull down resistor enable
0:DP pull down resistor disable
write_enable
bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;
usbphy_ctrl0
usbphy_ctrl0
Bit0~15 of usbphy_ctrl register
write_enable
bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;
usbphy_ctrl1
usbphy_ctrl1
Bit16~31 of usbphy_ctrl register
write_enable
bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;
usbphy_ctrl2
usbphy_ctrl2
Bit32~47 of usbphy_ctrl register
write_enable
bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;
usbphy_ctrl3
usbphy_ctrl3
Bit48~63 of usbphy_ctrl register
write_enable
bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;
usbphy_ctrl4
usbphy_ctrl4
Bit64~79 of usbphy_ctrl register
write_enable
bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;
usbphy_ctrl5
usbphy_ctrl5
Bit80~95 of usbphy_ctrl register
write_enable
bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;
usbphy_ctrl6
usbphy_ctrl6
Bit96~111 of usbphy_ctrl register
write_enable
bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;
usbphy_ctrl7
usbphy_ctrl7
Bit112~127 of usbphy_ctrl register
write_enable
bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;
usbphy_ctrl8
usbphy_ctrl8
Bit128~143 of usbphy_ctrl register
write_enable
bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;
usbphy_ctrl9
usbphy_ctrl9
Bit144~159 of usbphy_ctrl register
write_enable
bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;
usbphy_ctrl10
usbphy_ctrl10
Bit160~175 of usbphy_ctrl register
write_enable
bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;
usbphy_ctrl11
usbphy_ctrl11
Bit176~191 of usbphy_ctrl register
write_enable
bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;
usbphy_ctrl12
usbphy_ctrl12
Bit192~207 of usbphy_ctrl register
write_enable
bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;
usbphy_ctrl13
usbphy_ctrl13
Bit208~223 of usbphy_ctrl register
write_enable
bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;
usbphy_ctrl14
usbphy_ctrl14
Bit224~239 of usbphy_ctrl register
write_enable
bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;
usbphy_ctrl15
usbphy_ctrl15
Bit240~255 of usbphy_ctrl register
write_enable
bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;
usbphy_ctrl16
usbphy_ctrl16
Bit256~271 of usbphy_ctrl register
write_enable
bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;
usbphy_ctrl17
usbphy_ctrl17
Bit272~287 of usbphy_ctrl register
write_enable
bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;
usbphy_ctrl18
usbphy_ctrl18
Bit288~303 of usbphy_ctrl register
write_enable
bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;
usbphy_ctrl19
usbphy_ctrl19
Bit304~319 of usbphy_ctrl register
write_enable
bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;
usbphy_ctrl20
usbphy_ctrl20
Bit320~335 of usbphy_ctrl register
write_enable
bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;
usbphy_ctrl21
usbphy_ctrl21
Bit336~351 of usbphy_ctrl register
write_enable
bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;
usbphy_ctrl22
usbphy_ctrl22
Bit352~367 of usbphy_ctrl register
write_enable
bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;
usbphy_ctrl23
usbphy_ctrl23
Bit368~383 of usbphy_ctrl register
write_enable
bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;
usbphy_ctrl24
usbphy_ctrl24
Bit384~399 of usbphy_ctrl register
write_enable
bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;
usbphy_ctrl25
usbphy_ctrl25
Bit400~415 of usbphy_ctrl register
write_enable
bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;
usbphy_ctrl0
usbphy_ctrl0
Bit0~15 of usbphy_ctrl register
write_enable
bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;
usbphy_ctrl1
usbphy_ctrl1
Bit16~31 of usbphy_ctrl register
write_enable
bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;
usbphy_ctrl2
usbphy_ctrl2
Bit32~47 of usbphy_ctrl register
write_enable
bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;
usbphy_ctrl3
usbphy_ctrl3
Bit48~63 of usbphy_ctrl register
write_enable
bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;
usbphy_ctrl4
usbphy_ctrl4
Bit64~79 of usbphy_ctrl register
write_enable
bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;
usbphy_ctrl5
usbphy_ctrl5
Bit80~95 of usbphy_ctrl register
write_enable
bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;
usbphy_ctrl6
usbphy_ctrl6
Bit96~111 of usbphy_ctrl register
write_enable
bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;
usbphy_ctrl7
usbphy_ctrl7
Bit112~127 of usbphy_ctrl register
write_enable
bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;
usbphy_ctrl8
usbphy_ctrl8
Bit128~143 of usbphy_ctrl register
write_enable
bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;
usbphy_ctrl9
usbphy_ctrl9
Bit144~159 of usbphy_ctrl register
write_enable
bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;
usbphy_ctrl10
usbphy_ctrl10
Bit160~175 of usbphy_ctrl register
write_enable
bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;
usbphy_ctrl11
usbphy_ctrl11
Bit176~191 of usbphy_ctrl register
write_enable
bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;
usbphy_ctrl12
usbphy_ctrl12
Bit192~207 of usbphy_ctrl register
write_enable
bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;
usbphy_ctrl13
usbphy_ctrl13
Bit208~223 of usbphy_ctrl register
write_enable
bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;
usbphy_ctrl14
usbphy_ctrl14
Bit224~239 of usbphy_ctrl register
write_enable
bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;
usbphy_ctrl15
usbphy_ctrl15
Bit240~255 of usbphy_ctrl register
write_enable
bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;
usbphy_ctrl16
usbphy_ctrl16
Bit256~271 of usbphy_ctrl register
write_enable
bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;
usbphy_ctrl17
usbphy_ctrl17
Bit272~287 of usbphy_ctrl register
write_enable
bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;
usbphy_ctrl18
usbphy_ctrl18
Bit288~303 of usbphy_ctrl register
write_enable
bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;
usbphy_ctrl19
usbphy_ctrl19
Bit304~319 of usbphy_ctrl register
write_enable
bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;
usbphy_ctrl20
usbphy_ctrl20
Bit320~335 of usbphy_ctrl register
write_enable
bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;
usbphy_ctrl21
usbphy_ctrl21
Bit336~351 of usbphy_ctrl register
write_enable
bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;
usbphy_ctrl22
usbphy_ctrl22
Bit352~367 of usbphy_ctrl register
write_enable
bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;
usbphy_ctrl23
usbphy_ctrl23
Bit368~383 of usbphy_ctrl register
write_enable
bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;
usbphy_ctrl24
usbphy_ctrl24
Bit384~399 of usbphy_ctrl register
write_enable
bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;
usbphy_ctrl25
usbphy_ctrl25
Bit400~415 of usbphy_ctrl register</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_usbphy0_ctrl0</name>
          <description>usbphy0_ctrl0</description>
          <addressOffset>0x4480</addressOffset>
          <size>32</size>
          <resetValue>0x850f</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>GRF_usbphy0_ctrl1</name>
          <description>usbphy0_ctrl1</description>
          <addressOffset>0x4484</addressOffset>
          <size>32</size>
          <resetValue>0xe007</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>GRF_usbphy0_ctrl2</name>
          <description>usbphy0_ctrl2</description>
          <addressOffset>0x4488</addressOffset>
          <size>32</size>
          <resetValue>0x82e7</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>GRF_usbphy0_ctrl3</name>
          <description>usbphy0_ctrl3</description>
          <addressOffset>0x448c</addressOffset>
          <size>32</size>
          <resetValue>0x2a2</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>GRF_usbphy0_ctrl4</name>
          <description>usbphy0_ctrl4</description>
          <addressOffset>0x4490</addressOffset>
          <size>32</size>
          <resetValue>0x5554</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>GRF_usbphy0_ctrl5</name>
          <description>usbphy0_ctrl5</description>
          <addressOffset>0x4494</addressOffset>
          <size>32</size>
          <resetValue>0x4555</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>GRF_usbphy0_ctrl6</name>
          <description>usbphy0_ctrl6</description>
          <addressOffset>0x4498</addressOffset>
          <size>32</size>
          <resetValue>0x5</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>GRF_usbphy0_ctrl7</name>
          <description>usbphy0_ctrl7</description>
          <addressOffset>0x449c</addressOffset>
          <size>32</size>
          <resetValue>0x68c8</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>GRF_usbphy0_ctrl8</name>
          <description>usbphy0_ctrl8</description>
          <addressOffset>0x44a0</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>GRF_usbphy0_ctrl9</name>
          <description>usbphy0_ctrl9</description>
          <addressOffset>0x44a4</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>GRF_usbphy0_ctrl10</name>
          <description>usbphy0_ctrl10</description>
          <addressOffset>0x44a8</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>GRF_usbphy0_ctrl11</name>
          <description>usbphy0_ctrl11</description>
          <addressOffset>0x44ac</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>GRF_usbphy0_ctrl12</name>
          <description>usbphy0_ctrl12</description>
          <addressOffset>0x44b0</addressOffset>
          <size>32</size>
          <resetValue>0xa1</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>GRF_usbphy0_ctrl13</name>
          <description>usbphy0_ctrl13</description>
          <addressOffset>0x44b4</addressOffset>
          <size>32</size>
          <resetValue>0x850f</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>GRF_usbphy0_ctrl14</name>
          <description>usbphy0_ctrl14</description>
          <addressOffset>0x44b8</addressOffset>
          <size>32</size>
          <resetValue>0xe007</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>GRF_usbphy0_ctrl15</name>
          <description>usbphy0_ctrl15</description>
          <addressOffset>0x44bc</addressOffset>
          <size>32</size>
          <resetValue>0x2e7</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>GRF_usbphy0_ctrl16</name>
          <description>usbphy0_ctrl16</description>
          <addressOffset>0x44c0</addressOffset>
          <size>32</size>
          <resetValue>0x200</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>GRF_usbphy0_ctrl17</name>
          <description>usbphy0_ctrl17</description>
          <addressOffset>0x44c4</addressOffset>
          <size>32</size>
          <resetValue>0x5554</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>GRF_usbphy0_ctrl18</name>
          <description>usbphy0_ctrl18</description>
          <addressOffset>0x44c8</addressOffset>
          <size>32</size>
          <resetValue>0x4555</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>GRF_usbphy0_ctrl19</name>
          <description>usbphy0_ctrl19</description>
          <addressOffset>0x44cc</addressOffset>
          <size>32</size>
          <resetValue>0x5</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>GRF_usbphy0_ctrl20</name>
          <description>usbphy0_ctrl20</description>
          <addressOffset>0x44d0</addressOffset>
          <size>32</size>
          <resetValue>0x68c8</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>GRF_usbphy0_ctrl21</name>
          <description>usbphy0_ctrl21</description>
          <addressOffset>0x44d4</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>GRF_usbphy0_ctrl22</name>
          <description>usbphy0_ctrl22</description>
          <addressOffset>0x44d8</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>GRF_usbphy0_ctrl23</name>
          <description>usbphy0_ctrl23</description>
          <addressOffset>0x44dc</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>GRF_usbphy0_ctrl24</name>
          <description>usbphy0_ctrl24</description>
          <addressOffset>0x44e0</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>GRF_usbphy0_ctrl25</name>
          <description>usbphy0_ctrl25</description>
          <addressOffset>0x44e4</addressOffset>
          <size>32</size>
          <resetValue>0x21</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>GRF_usbphy1_ctrl0</name>
          <description>usbphy1_ctrl0</description>
          <addressOffset>0x4500</addressOffset>
          <size>32</size>
          <resetValue>0x850f</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>GRF_usbphy1_ctrl1</name>
          <description>usbphy1_ctrl1</description>
          <addressOffset>0x4504</addressOffset>
          <size>32</size>
          <resetValue>0xe007</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>GRF_usbphy1_ctrl2</name>
          <description>usbphy1_ctrl2</description>
          <addressOffset>0x4508</addressOffset>
          <size>32</size>
          <resetValue>0x82e7</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>GRF_usbphy1_ctrl3</name>
          <description>usbphy1_ctrl3</description>
          <addressOffset>0x450c</addressOffset>
          <size>32</size>
          <resetValue>0x2a2</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>GRF_usbphy1_ctrl4</name>
          <description>usbphy1_ctrl4</description>
          <addressOffset>0x4510</addressOffset>
          <size>32</size>
          <resetValue>0x5554</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>GRF_usbphy1_ctrl5</name>
          <description>usbphy1_ctrl5</description>
          <addressOffset>0x4514</addressOffset>
          <size>32</size>
          <resetValue>0x4555</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>GRF_usbphy1_ctrl6</name>
          <description>usbphy1_ctrl6</description>
          <addressOffset>0x4518</addressOffset>
          <size>32</size>
          <resetValue>0x5</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>GRF_usbphy1_ctrl7</name>
          <description>usbphy1_ctrl7</description>
          <addressOffset>0x451c</addressOffset>
          <size>32</size>
          <resetValue>0x68c8</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>GRF_usbphy1_ctrl8</name>
          <description>usbphy1_ctrl8</description>
          <addressOffset>0x4520</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>GRF_usbphy1_ctrl9</name>
          <description>usbphy1_ctrl9</description>
          <addressOffset>0x4524</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>GRF_usbphy1_ctrl10</name>
          <description>usbphy1_ctrl10</description>
          <addressOffset>0x4528</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>GRF_usbphy1_ctrl11</name>
          <description>usbphy1_ctrl11</description>
          <addressOffset>0x452c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>GRF_usbphy1_ctrl12</name>
          <description>usbphy1_ctrl12</description>
          <addressOffset>0x4530</addressOffset>
          <size>32</size>
          <resetValue>0xa1</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>GRF_usbphy1_ctrl13</name>
          <description>usbphy1_ctrl13</description>
          <addressOffset>0x4534</addressOffset>
          <size>32</size>
          <resetValue>0x850f</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>GRF_usbphy1_ctrl14</name>
          <description>usbphy1_ctrl14</description>
          <addressOffset>0x4538</addressOffset>
          <size>32</size>
          <resetValue>0xe007</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>GRF_usbphy1_ctrl15</name>
          <description>usbphy1_ctrl15</description>
          <addressOffset>0x453c</addressOffset>
          <size>32</size>
          <resetValue>0x2e7</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>GRF_usbphy1_ctrl16</name>
          <description>usbphy1_ctrl16</description>
          <addressOffset>0x4540</addressOffset>
          <size>32</size>
          <resetValue>0x200</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>GRF_usbphy1_ctrl17</name>
          <description>usbphy1_ctrl17</description>
          <addressOffset>0x4544</addressOffset>
          <size>32</size>
          <resetValue>0x5554</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>GRF_usbphy1_ctrl18</name>
          <description>usbphy1_ctrl18</description>
          <addressOffset>0x4548</addressOffset>
          <size>32</size>
          <resetValue>0x4555</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>GRF_usbphy1_ctrl19</name>
          <description>usbphy1_ctrl19</description>
          <addressOffset>0x454c</addressOffset>
          <size>32</size>
          <resetValue>0x5</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>GRF_usbphy1_ctrl20</name>
          <description>usbphy1_ctrl20</description>
          <addressOffset>0x4550</addressOffset>
          <size>32</size>
          <resetValue>0x68c8</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>GRF_usbphy1_ctrl21</name>
          <description>usbphy1_ctrl21</description>
          <addressOffset>0x4554</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>GRF_usbphy1_ctrl22</name>
          <description>usbphy1_ctrl22</description>
          <addressOffset>0x4558</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>GRF_usbphy1_ctrl23</name>
          <description>usbphy1_ctrl23</description>
          <addressOffset>0x455c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>GRF_usbphy1_ctrl24</name>
          <description>usbphy1_ctrl24</description>
          <addressOffset>0x4560</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>GRF_usbphy1_ctrl25</name>
          <description>usbphy1_ctrl25</description>
          <addressOffset>0x4564</addressOffset>
          <size>32</size>
          <resetValue>0x21</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>GRF_HDCP22_PERF_CON0</name>
          <description>hdcp performance monitor control register</description>
          <addressOffset>0x6000</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HDCP22_SW_RD_LATENCY_ID</name>
              <description>Axi read channel id for latency
AXI_PERFormance test</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HDCP22_SW_DDR_ALIGN_TYPE</name>
              <description>0: 16-Byte align
1: 32-Byte align
2: 64-Byte align
3: 128-Byte align</description>
              <bitRange>[6:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HDCP22_SW_AW_CNT_ID_TYPE</name>
              <description>0: count all write channels
1: count sw_aw_count_id write channel only</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HDCP22_SW_AR_CNT_ID_TYPE</name>
              <description>axi_perf counter id control
0: count all read channel id
1: count sw_ar_count_id read channel only</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HDCP22_SW_AXI_CNT_TYPE</name>
              <description>axi_perf counter type
0: axi transfer test
1: ddr align transfer test</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HDCP22_SW_AXI_PERF_CLR</name>
              <description>axi_perf clear bit
0: disable
1: enable</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HDCP22_SW_AXI_PERF_WORK</name>
              <description>axi_perf enable bit
0: disable
1: enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_HDCP22_PERF_CON1</name>
          <description>hdcp performance monitor control register</description>
          <addressOffset>0x6004</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HDCP22_SW_RD_LATENCY_THR</name>
              <description>Axi Read latency threshold</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_HDCP22_PERF_CON2</name>
          <description>hdcp performance monitor control register</description>
          <addressOffset>0x6008</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HDCP22_SW_AW_COUNT_ID</name>
              <description>When    sw_aw_cnt_id_type=1,    only    count
the    id designated by sw_aw_count_id</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HDCP22_SW_AR_COUNT_ID</name>
              <description>When    sw_ar_cnt_id_type=1,    only    count
the    id designated by sw_ar_count_id</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_HDCP22_PERF_RD_MAX_LATENCY_NUM</name>
          <description>hdcp performance monitor status register</description>
          <addressOffset>0x600c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RD_MAX_LATENCY_R</name>
              <description>axi read max latency output</description>
              <bitRange>[12:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_HDCP22_PERF_RD_LATENCY_SAMP_NUM</name>
          <description>hdcp performance monitor status register</description>
          <addressOffset>0x6010</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RD_LATENCY_SAMP_R</name>
              <description>AXI read latency total sample number</description>
              <bitRange>[26:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_HDCP22_PERF_RD_LATENCY_ACC_NUM</name>
          <description>hdcp performance monitor status register</description>
          <addressOffset>0x6014</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RD_LATENCY_ACC_CNT_R</name>
              <description>AXI    read    latency    (&gt;sw_rd_latency_thr)
total number</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_HDCP22_PERF_RD_AXI_TOTAL_BYTE</name>
          <description>hdcp performance monitor status register</description>
          <addressOffset>0x6018</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RD_AXI_TOTAL_BYTE</name>
              <description>AXI active total read bytes/ddr align read
bytes</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_HDCP22_PERF_WR_AXI_TOTAL_BYTE</name>
          <description>hdcp performance monitor status register</description>
          <addressOffset>0x601c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WR_AXI_TOTAL_BYTE</name>
              <description>AXI active total write bytes/ddr align write
bytes</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_HDCP22_PERF_WORKING_CNT</name>
          <description>hdcp performance monitor status register</description>
          <addressOffset>0x6020</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WORKING_CNT_R</name>
              <description>working counter</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_SOC_CON9</name>
          <description>SoC control register 9</description>
          <addressOffset>0x6224</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI0_DPIUPDATECFG</name>
              <description>DSI host0 dpiupdatecfg bit control</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI0_DPISHUTDN</name>
              <description>DSI0 dpishutdn bit control</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI0_DPICOLORM</name>
              <description>DSI0 dpicolorm bit control</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DP_LCDC_SEL</name>
              <description>dp lcdc select
1'b0: vop big
1'b1: vop little</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPHY_RX1_CLK_INV_SEL</name>
              <description>dphy rx1 clock inveter select bit</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPHY_RX0_CLK_INV_SEL</name>
              <description>dphy rx0 clock inveter select bit</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DISABLE_ISP1</name>
              <description>isp1 disable control</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DISABLE_ISP0</name>
              <description>isp0 disable control</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPHY_RX0_TURNREQUEST</name>
              <description>dphy rx0 runrequest port control</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_SOC_CON20</name>
          <description>SoC control register 20</description>
          <addressOffset>0x6250</addressOffset>
          <size>32</size>
          <resetValue>0x249</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HDCP_I2C_FORCE_SDA</name>
              <description>hdcp_i2c_force_sda bit control</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HDCP_I2C_FORCE_SCL</name>
              <description>hdcp_i2c_force_scl control</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GRF_VOP_RGB_DCLK_REV_SEL</name>
              <description>dclk phase selct
0: 0 degree
1: 180 degree</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GRF_CON_RGB_LCDC_SEL</name>
              <description>vop select
1'b0: vop big
1'b1: vop little
</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLKIN_DVP_REV_SEL</name>
              <description>pclkin dvp clock select
0: not invet phase
1: invert phase</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EDP_VIDEO_BIST_EN</name>
              <description>edp video bist enable
1: enable
0: disable</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VOP_FINISH_SEL</name>
              <description>vop finish select
1'b0: vop big
1'b1: vop little</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HDMI_LCDC_SEL</name>
              <description>hdmi lcdc select
1'b0: vop big
1'b1: vop little</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EDP_LCDC_SEL</name>
              <description>edp lcdc select
1'b0: vop big
1'b1: vop little</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI1_LCDC_SEL</name>
              <description>dsi1 lcdc select
1'b0: vop big
1'b1: vop little</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI1_DPIUPDATECFG</name>
              <description>dsi1 dpiupdatecfg bit control</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI1_DPISHUTDN</name>
              <description>dsi1 dpishutdn bit control</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI1_DPICOLORM</name>
              <description>dsi1 dpicolorm bit control</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI0_LCDC_SEL</name>
              <description>dsi0 vol select bit
1'b0: vop big
1'b1: vop little</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_SOC_CON21</name>
          <description>SoC control register 21</description>
          <addressOffset>0x6254</addressOffset>
          <size>32</size>
          <resetValue>0x2cb</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPHY_RX0_TURNDISABLE</name>
              <description>dphy_rx0_turndisable bit control</description>
              <bitRange>[15:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPHY_RX0_FORCETXSTOPMODE</name>
              <description>dphy_rx0_forcetxstopmode bit control</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPHY_RX0_FORCERXMODE</name>
              <description>dphy_rx0_forcerxmode bit control</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPHY_RX0_ENABLE</name>
              <description>dphy_rx0_enable bit control</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_SOC_CON22</name>
          <description>SoC control register 22</description>
          <addressOffset>0x6258</addressOffset>
          <size>32</size>
          <resetValue>0x10cb</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPHY_TX0_TURNREQUEST</name>
              <description>dphy_tx0_turnrequest bit control</description>
              <bitRange>[15:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPHY_TX0_TURNDISABLE</name>
              <description>dphy_tx0_turndisable bit control</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPHY_TX0_FORCETXSTOPMODE</name>
              <description>dphy_tx0_forcetxstopmode bit control</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPHY_TX0_FORCERXMODE</name>
              <description>dphy_tx0_forcerxmode bit control</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_SOC_CON23</name>
          <description>SoC control register 23</description>
          <addressOffset>0x625c</addressOffset>
          <size>32</size>
          <resetValue>0x21</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPHY_TX1RX1_TURNDISABLE</name>
              <description>dphy_tx1rx1_turndisable bit control</description>
              <bitRange>[15:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPHY_TX1RX1_FORCETXSTOPMODE</name>
              <description>dphy_tx1rx1_forcetxstopmode bit control</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPHY_TX1RX1_FORCERXMODE</name>
              <description>dphy_tx1rx1_forcerxmode bit control</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPHY_TX1RX1_ENABLE</name>
              <description>dphy_tx1rx1_enable bit control</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_SOC_CON24</name>
          <description>SoC control register 24</description>
          <addressOffset>0x6260</addressOffset>
          <size>32</size>
          <resetValue>0x39f0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VOPL_DSI_ITE_SEL</name>
              <description>vopl_dsi_ite_sel bit control
0: mipi_dsi0_edpite
1: mipi_dsi1_edpite
2: 0
3: 1</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VOPB_DSI_ITE_SEL</name>
              <description>vopb_dsi_ite_sel bit control
0: mipi_dsi0_edpite
1: mipi_dsi1_edpite
2: 0
3: 1</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VOPL_DSI_HALT_SEL</name>
              <description>vopl_dsi_halt_sel bit control
0: mipi_dsi0_edpihalt
1: mipi_dsi0_edpihalt
2: low
3: high</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VOPB_DSI_HALT_SEL</name>
              <description>vopb_dsi_halt_sel bit control
0: mipi_dsi0_edpihalt
1: mipi_dsi0_edpihalt
2: low
3: high</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPHY_TX1RX1_MASTERSLAVEZ</name>
              <description>dphy_tx1rx1_masterslavez bit control</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPHY_TX1RX1_ENABLECLK</name>
              <description>dphy_tx1rx1_enableclk bit control</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPHY_TX1RX1_BASEDIR</name>
              <description>dphy_tx1rx1_basedir bit control</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPHY_RX1_SRC_SEL</name>
              <description>dphy_rx1_src_sel bit control</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPHY_TX1TX1_TURNREQUEST</name>
              <description>dphy_tx1tx1_turnrequest bit control</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_SOC_CON25</name>
          <description>SoC control register 25</description>
          <addressOffset>0x6264</addressOffset>
          <size>32</size>
          <resetValue>0xd45b</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EDP_TX_BSCAN_DATA</name>
              <description>edp_tx_bscan_data bit control</description>
              <bitRange>[15:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EDP_REF_CLK_SEL</name>
              <description>edp_ref_clk_sel bit control</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPHY_RX0_TSETCLR</name>
              <description>dphy_rx0_tsetclr bit control</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPHY_RX0_TSETCLK</name>
              <description>dphy_rx0_tsetclk bit control</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPHY_RX0_TSETEN</name>
              <description>dphy_rx0_tseten bit control</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPHY_RX0_TSETDIN</name>
              <description>dphy_rx0_tsetdin bit control</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_SOC_CON26</name>
          <description>SoC control register 26</description>
          <addressOffset>0x6268</addressOffset>
          <size>32</size>
          <resetValue>0x110</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPTX_HPD_SEL</name>
              <description>dptx_hpd_sel bit control</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_DP_XT_OCDHALTONRESET</name>
              <description>force_dp_xt_ocdhaltonreset bit control</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPTX_LANE_SEL</name>
              <description>dptx_lane_sel bit control</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UPHY_DP_SEL</name>
              <description>uphy_dp_sel bit control</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HDCP22_SRC_SEL</name>
              <description>hdcp22_src_sel bit control</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EDP_TX_BSCAN_EN</name>
              <description>edp_tx_bscan_en bit control</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPU_PERF_CON0</name>
          <description>gpu performance monitor control register</description>
          <addressOffset>0x8000</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPU_SW_RD_LATENCY_ID</name>
              <description>Axi read channel id for latency
AXI_PERFormance test</description>
              <bitRange>[13:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPU_SW_DDR_ALIGN_TYPE</name>
              <description>0: 16-Byte align
1: 32-Byte align
2: 64-Byte align
3: 128-Byte align</description>
              <bitRange>[6:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPU_SW_AW_CNT_ID_TYPE</name>
              <description>axi_perf counter id control
0: count all write channel id
1: count sw_ar_count_id write channel only</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPU_SW_AR_CNT_ID_TYPE</name>
              <description>axi_perf counter id control
0: count all read channel id
1: count sw_ar_count_id read channel only</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPU_SW_AXI_CNT_TYPE</name>
              <description>axi_perf counter type
0: axi transfer test
1: ddr align transfer test</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPU_SW_AXI_PERF_CLR</name>
              <description>axi_perf clear bit
0: disable
1: enable</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPU_SW_AXI_PERF_WORK</name>
              <description>axi_perf enable bit
0: disable
1: enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPU_PERF_CON1</name>
          <description>gpu performance monitor control register</description>
          <addressOffset>0x8004</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPU_SW_RD_LATENCY_THR</name>
              <description>Axi read channel id for latency
AXI_PERFormance test</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPU_PERF_CON2</name>
          <description>gpu performance monitor control register</description>
          <addressOffset>0x8008</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPU_SW_AW_COUNT_ID</name>
              <description>When    sw_aw_cnt_id_type=1,    only    count
the    id designated by sw_aw_count_id</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPU_SW_AR_COUNT_ID</name>
              <description>When    sw_ar_cnt_id_type=1,    only    count
the    id designated by sw_ar_count_id</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPU_PERF_RD_MAX_LATENCY_NUM</name>
          <description>gpu performance monitor status register</description>
          <addressOffset>0x800c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RD_MAX_LATENCY_R</name>
              <description>axi read max latency output</description>
              <bitRange>[12:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPU_PERF_RD_LATENCY_SAMP_NUM</name>
          <description>gpu performance monitor status register</description>
          <addressOffset>0x8010</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RD_LATENCY_SAMP_R</name>
              <description>AXI read latency total sample number</description>
              <bitRange>[26:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPU_PERF_RD_LATENCY_ACC_NUM</name>
          <description>gpu performance monitor status register</description>
          <addressOffset>0x8014</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RD_LATENCY_ACC_CNT_R</name>
              <description>AXI    read    latency    (&gt;sw_rd_latency_thr)
total number</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPU_PERF_RD_AXI_TOTAL_BYTE</name>
          <description>gpu performance monitor status register</description>
          <addressOffset>0x8018</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RD_AXI_TOTAL_BYTE</name>
              <description>AXI active total read bytes/ddr align read
bytes</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPU_PERF_WR_AXI_TOTAL_BYTE</name>
          <description>gpu performance monitor status register</description>
          <addressOffset>0x801c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WR_AXI_TOTAL_BYTE</name>
              <description>AXI active total write bytes/ddr align write
bytes</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPU_PERF_WORKING_CNT</name>
          <description>gpu performance monitor status register</description>
          <addressOffset>0x8020</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WORKING_CNT_R</name>
              <description>working counter</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_CPU_CON0</name>
          <description>cpu control register 0</description>
          <addressOffset>0xa000</addressOffset>
          <size>32</size>
          <resetValue>0xb</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CFGTE_PD_CORE_L</name>
              <description>pd_core_l cpu cfgte bit control
0: disable
1: enable</description>
              <bitRange>[15:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CFGEND_PD_CORE_L</name>
              <description>pd_core_l cpu cfgend bit control
0: disable
1: enable</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>L2RSTDISABLE_PD_CORE_L</name>
              <description>pd_core_l cpu l2rstdisable bit control
0: disable
1: enable</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DBGL1RSTDISABLE_PD_CORE_L</name>
              <description>pd_core_l cpu dbgl1rstdisable bit control
0: disable
1: enable</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLREXMONREQ_PD_CORE_L</name>
              <description>pd_core_l cpu clrexmonreq bit control
0: disable
1: enable</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SYSBARDISABLE_PD_CORE_L</name>
              <description>pd_core_l cpu sysbardisable bit control
0: disable
1: enable</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BROADCASTCACHEMAINT_PD_CORE_L</name>
              <description>pd_core_l cpu broadcastcachemaint bit
control
0: disable
1: enable</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BROADCASTOUTER_PD_CORE_L</name>
              <description>pd_core_l cpu broadcastouter bit control
0: disable
1: enable</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BROADCASTINNER_PD_CORE_L</name>
              <description>pd_core_l    cpu broadcastinner bit control
1: enable
0: disable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_CPU_CON1</name>
          <description>cpu control register 1</description>
          <addressOffset>0xa004</addressOffset>
          <size>32</size>
          <resetValue>0xf000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GIC_ACTIVE_CORE_L</name>
              <description>pd_core_l gic_active bit control</description>
              <bitRange>[15:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLUSTERIDAFF1_PD_CORE_L</name>
              <description>pd_core_l clusteridaff1 bit control</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARQOS_PD_CORE_L</name>
              <description>pd_core_l arqos bit control</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AWQOS_PD_CORE_L</name>
              <description>pd_core_l awqos bit control</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_CPU_CON2</name>
          <description>cpu control register 2</description>
          <addressOffset>0xa008</addressOffset>
          <size>32</size>
          <resetValue>0xb</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GIC_AXIM_ERR_ACK</name>
              <description>gic axi master error acknowledges
0: disable
1: enable</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CFGTE_PD_CORE_B</name>
              <description>pd_core_b cpu cfgte bit control
0: disable
1: enable</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CFGEND_PD_CORE_B</name>
              <description>pd_core_b cpu cfgend bit control
0: disable
1: enable</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>L2RSTDISABLE_PD_CORE_B</name>
              <description>pd_core_b cpu l2rstdisable bit control
0: disable
1: enable</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DBGL1RSTDISABLE_PD_CORE_B</name>
              <description>pd_core_b cpu dbgl1rstdisable bit control
0: disable
1: enable</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLREXMONREQ_PD_CORE_B</name>
              <description>pd_core_b cpu clrexmonreq bit control
0: disable
1: enable</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SYSBARDISABLE_PD_CORE_B</name>
              <description>pd_core_b cpu sysbardisable bit control
0: disable
1: enable</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BROADCASTCACHEMAINT_PD_CORE_B</name>
              <description>pd_core_b cpu broadcastcachemaint bit
control
0: disable
1: enable</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BROADCASTOUTER_PD_CORE_B</name>
              <description>pd_core_b cpu broadcastouter bit control
0: disable
1: enable</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BROADCASTINNER_PD_CORE_B</name>
              <description>pd_core_b    cpu broadcastinner bit control
1: enable
0: disable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_CPU_CON3</name>
          <description>cpu control register 3</description>
          <addressOffset>0xa00c</addressOffset>
          <size>32</size>
          <resetValue>0x3110</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GIC_ACTIVE_CORE_B</name>
              <description>pd_core_b gic_active bit control</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLUSTERIDAFF1_PD_CORE_B</name>
              <description>pd_core_b clusteridaff1 bit control</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARQOS_PD_CORE_B</name>
              <description>pd_core_b arqos bit control</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AWQOS_PD_CORE_B</name>
              <description>pd_core_b awqos bit control</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_CPU_STATUS0</name>
          <description>cpu status register 0</description>
          <addressOffset>0xa080</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRMEMATTR_PD_CORE_B</name>
              <description>wrmemattr of pd_core_b status</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RDMEMATTR_PD_CORE_B</name>
              <description>rdmemattr of pd_core_b status</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RDMEMATTR_PD_CORE_L</name>
              <description>rdmemattr of pd_core_l status</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WRMEMATTR_PD_CORE_L</name>
              <description>wrmemattr of pd_core_l status</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_CPU_STATUS1</name>
          <description>cpu status register 1</description>
          <addressOffset>0xa084</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLREMONACK_PD_CORE_B</name>
              <description>the status of clremonack_pd_core_b</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLREMONACK_PD_CORE_L</name>
              <description>the status of clremonack_pd_core_l</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STANDBYWFIL2_PD_CORE_B</name>
              <description>standbywfil2 of pd_core_b status bit</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STANDBYWFIL2_PD_CORE_L</name>
              <description>standbywfil2 of pd_core_l status bit</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SMPEN_PD_CORE_B</name>
              <description>status of smpen_pd_core_b</description>
              <bitRange>[21:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SMPEN_PD_CORE_L</name>
              <description>status of smpen_pd_core_l</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STANDBYWFE_PD_CORE_B</name>
              <description>standbywfe of pd_core_b status bit</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STANDBYWFI_PD_CORE_B</name>
              <description>standbywfi of pd_core_b status bit</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STANDBYWFE_PD_CORE_L</name>
              <description>standbywfe of pd_core_l status bit</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STANDBYWFI_PD_CORE_L</name>
              <description>standbywfi of pd_core_l status bit</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_CPU_STATUS2</name>
          <description>cpu status register 2</description>
          <addressOffset>0xa088</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CCI_EVENT_BUS</name>
              <description>the status of cci_event_bus[31:0]</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_CPU_STATUS3</name>
          <description>cpu status register 3</description>
          <addressOffset>0xa08c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CCI_EVENT_BUS</name>
              <description>the status of cci_event_bus[63:32]</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_CPU_STATUS4</name>
          <description>cpu status register 4</description>
          <addressOffset>0xa090</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CCI_EVENT_BUS</name>
              <description>the status of cci_event_bus[93:64]</description>
              <bitRange>[29:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_CPU_STATUS5</name>
          <description>cpu status register 5</description>
          <addressOffset>0xa094</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GIC_AXIM_ERR</name>
              <description>gic_axim_err status bit</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GIC_ECC_FATAL</name>
              <description>gic_ecc_fatal status bit</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CCI_NEVNTCNTOVERFLOW</name>
              <description>cci_nevntcntoverflow status bit</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_A53_PERF_CON0</name>
          <description>a53 performance monitor control register</description>
          <addressOffset>0xa100</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>A53_SW_RD_LATENCY_ID</name>
              <description>Axi read channel id for latency
AXI_PERFormance test</description>
              <bitRange>[13:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>A53_SW_DDR_ALIGN_TYPE</name>
              <description>0: 16-Byte align
1: 32-Byte align
2: 64-Byte align
3: 128-Byte align</description>
              <bitRange>[6:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>A53_SW_AW_CNT_ID_TYPE</name>
              <description>axi_perf counter id control
0: count all write channel id
1: count sw_ar_count_id write channel only</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>A53_SW_AR_CNT_ID_TYPE</name>
              <description>axi_perf counter id control
0: count all read channel id
1: count sw_ar_count_id read channel only</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>A53_SW_AXI_CNT_TYPE</name>
              <description>axi_perf counter type
0: axi transfer test
1: ddr align transfer test</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>A53_SW_AXI_PERF_CLR</name>
              <description>axi_perf clear bit
0: disable
1: enable</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>A53_SW_AXI_PERF_WORK</name>
              <description>a53 performance monitor control register
axi_perf enable bit
0: disable
1: enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_A53_PERF_CON1</name>
          <description>a53 performance monitor control register</description>
          <addressOffset>0xa104</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>A53_SW_RD_LATENCY_THR</name>
              <description>Axi read channel id for latency
AXI_PERFormance test</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_A53_PERF_CON2</name>
          <description>a53 performance monitor control register</description>
          <addressOffset>0xa108</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>A53_SW_AW_COUNT_ID</name>
              <description>When    sw_aw_cnt_id_type=1,    only    count
the    id designated by sw_aw_count_id</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>A53_SW_AR_COUNT_ID</name>
              <description>When    sw_ar_cnt_id_type=1,    only    count
the    id designated by sw_ar_count_id</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_A53_PERF_CON3</name>
          <description>a53 performance monitor control register</description>
          <addressOffset>0xa10c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MON_ID</name>
              <description>mon_id bit control</description>
              <bitRange>[15:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MON_ID_BMSK</name>
              <description>mon_id_bmsk bit control</description>
              <bitRange>[8:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MON_ID_TYPE</name>
              <description>mon_id_type bit control</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MON_ID_MSK</name>
              <description>mon_id_msk bit control</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_A53_PERF_RD_MON_ST</name>
          <description>performance monitor read start address</description>
          <addressOffset>0xa110</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RD_START_ADDR</name>
              <description>monitor read start address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_A53_PERF_RD_MON_END</name>
          <description>performance monitor end address</description>
          <addressOffset>0xa114</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RD_END_ADDR</name>
              <description>monitor read end address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_A53_PERF_WR_MON_ST</name>
          <description>performance write monitor start address</description>
          <addressOffset>0xa118</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WR_START_ADDR</name>
              <description>monitor write start address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_A53_PERF_WR_MON_END</name>
          <description>performance monitor write end address</description>
          <addressOffset>0xa11c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WR_END_ADDR</name>
              <description>monitor write end address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_A53_PERF_RD_MAX_LATENCY_NUM</name>
          <description>a53 performance monitor status register</description>
          <addressOffset>0xa120</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RD_MAX_LATENCY_R</name>
              <description>axi read max latency output</description>
              <bitRange>[12:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_A53_PERF_RD_LATENCY_SAMP_NUM</name>
          <description>a53 performance monitor status register</description>
          <addressOffset>0xa124</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RD_LATENCY_SAMP_R</name>
              <description>AXI read latency total sample number</description>
              <bitRange>[26:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_A53_PERF_RD_LATENCY_ACC_NUM</name>
          <description>a53 performance monitor status register</description>
          <addressOffset>0xa128</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RD_LATENCY_ACC_CNT_R</name>
              <description>AXI    read    latency    (&gt;sw_rd_latency_thr)
total number</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_A53_PERF_RD_AXI_TOTAL_BYTE</name>
          <description>a53 performance monitor status register</description>
          <addressOffset>0xa12c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RD_AXI_TOTAL_BYTE</name>
              <description>AXI active total read bytes/ddr align read
bytes</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_A53_PERF_WR_AXI_TOTAL_BYTE</name>
          <description>a53 performance monitor status register</description>
          <addressOffset>0xa130</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WR_AXI_TOTAL_BYTE</name>
              <description>AXI active total write bytes/ddr align write
bytes</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_A53_PERF_WORKING_CNT</name>
          <description>a53 performance monitor status register</description>
          <addressOffset>0xa134</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WORKING_CNT_R</name>
              <description>working counter</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_A53_PERF_INT_STATUS</name>
          <description>a53 performance monitor status register</description>
          <addressOffset>0xa138</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INT_STATUS</name>
              <description>interrupt status bit</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_A72_PERF_CON0</name>
          <description>a72 performance monitor control register</description>
          <addressOffset>0xa200</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>A72_SW_RD_LATENCY_ID</name>
              <description>Axi read channel id for latency
AXI_PERFormance test</description>
              <bitRange>[14:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>A72_SW_DDR_ALIGN_TYPE</name>
              <description>0: 16-Byte align
1: 32-Byte align
2: 64-Byte align
3: 128-Byte align</description>
              <bitRange>[6:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>A72_SW_AW_CNT_ID_TYPE</name>
              <description>axi_perf counter id control
0: count all write channel id
1: count sw_ar_count_id write channel only</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>A72_SW_AR_CNT_ID_TYPE</name>
              <description>axi_perf counter id control
0: count all read channel id
1: count sw_ar_count_id read channel only</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>A72_SW_AXI_CNT_TYPE</name>
              <description>axi_perf counter type
0: axi transfer test
1: ddr align transfer test</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>A72_SW_AXI_PERF_CLR</name>
              <description>axi_perf clear bit
0: disable
1: enable</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>A72_SW_AXI_PERF_WORK</name>
              <description>axi_perf enable bit
0: disable
1: enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_A72_PERF_CON1</name>
          <description>a72 performance monitor control register</description>
          <addressOffset>0xa204</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>A72_SW_RD_LATENCY_THR</name>
              <description>Axi read channel id for latency
AXI_PERFormance test</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_A72_PERF_CON2</name>
          <description>a72 performance monitor control register</description>
          <addressOffset>0xa208</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>A72_SW_AW_COUNT_ID</name>
              <description>When    sw_aw_cnt_id_type=1,    only    count
the    id designated by sw_aw_count_id</description>
              <bitRange>[14:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>A72_SW_AR_COUNT_ID</name>
              <description>When    sw_ar_cnt_id_type=1,    only    count
the    id designated by sw_ar_count_id</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_A72_PERF_CON3</name>
          <description>a72 performance monitor control register</description>
          <addressOffset>0xa20c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MON_ID</name>
              <description>mon_id bit control</description>
              <bitRange>[15:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MON_ID_BMSK</name>
              <description>mon_id_bmsk bit control</description>
              <bitRange>[8:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MON_ID_TYPE</name>
              <description>mon_id_type bit control</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MON_ID_MSK</name>
              <description>mon_id_msk bit control</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_A72_PERF_RD_MON_ST</name>
          <description>performance monitor read start address</description>
          <addressOffset>0xa210</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RD_START_ADDR</name>
              <description>monitor read start address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_A72_PERF_RD_MON_END</name>
          <description>performance monitor end address</description>
          <addressOffset>0xa214</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RD_END_ADDR</name>
              <description>monitor read end address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_A72_PERF_WR_MON_ST</name>
          <description>performance write monitor start address</description>
          <addressOffset>0xa218</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WR_START_ADDR</name>
              <description>monitor write start address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_A72_PERF_WR_MON_END</name>
          <description>performance monitor write end address</description>
          <addressOffset>0xa21c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WR_END_ADDR</name>
              <description>monitor write end address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_A72_PERF_RD_MAX_LATENCY_NUM</name>
          <description>a72 performance monitor status register</description>
          <addressOffset>0xa220</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RD_MAX_LATENCY_R</name>
              <description>axi read max latency output</description>
              <bitRange>[12:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_A72_PERF_RD_LATENCY_SAMP_NUM</name>
          <description>a72 performance monitor status register</description>
          <addressOffset>0xa224</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RD_LATENCY_SAMP_R</name>
              <description>AXI read latency total sample number</description>
              <bitRange>[26:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_A72_PERF_RD_LATENCY_ACC_NUM</name>
          <description>a72 performance monitor status register</description>
          <addressOffset>0xa228</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RD_LATENCY_ACC_CNT_R</name>
              <description>AXI    read    latency    (&gt;sw_rd_latency_thr)
total number</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_A72_PERF_RD_AXI_TOTAL_BYTE</name>
          <description>a72 performance monitor status register</description>
          <addressOffset>0xa22c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RD_AXI_TOTAL_BYTE</name>
              <description>AXI active total read bytes/ddr align read
bytes</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_A72_PERF_WR_AXI_TOTAL_BYTE</name>
          <description>a72 performance monitor status register</description>
          <addressOffset>0xa230</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WR_AXI_TOTAL_BYTE</name>
              <description>AXI active total write bytes/ddr align write
bytes</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_A72_PERF_WORKING_CNT</name>
          <description>a72 performance monitor status register</description>
          <addressOffset>0xa234</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WORKING_CNT_R</name>
              <description>working counter</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_A72_PERF_INT_STATUS</name>
          <description>a72 performance monitor status register</description>
          <addressOffset>0xa238</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INT_STATUS</name>
              <description>interrupt status bit</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GMAC_PERF_CON0</name>
          <description>gmac performance monitor control register</description>
          <addressOffset>0xc000</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GMAC_SW_RD_LATENCY_ID</name>
              <description>Axi read channel id for latency
AXI_PERFormance test</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GMAC_SW_DDR_ALIGN_TYPE</name>
              <description>0: 16-Byte align
1: 32-Byte align
2: 64-Byte align
3: 128-Byte align</description>
              <bitRange>[6:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GMAC_SW_AW_CNT_ID_TYPE</name>
              <description>0: count all write channels
1: count sw_aw_count_id write channel only</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GMAC_SW_AR_CNT_ID_TYPE</name>
              <description>axi_perf counter id control
0: count all read channel id
1: count sw_ar_count_id read channel only</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GMAC_SW_AXI_CNT_TYPE</name>
              <description>axi_perf counter type
0: axi transfer test
1: ddr align transfer test</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GMAC_SW_AXI_PERF_CLR</name>
              <description>axi_perf clear bit
0: disable
1: enable</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GMAC_SW_AXI_PERF_WORK</name>
              <description>axi_perf enable bit
0: disable
1: enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GMAC_PERF_CON1</name>
          <description>gmac performance monitor control register</description>
          <addressOffset>0xc004</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GMAC_SW_RD_LATENCY_THR</name>
              <description>Axi read channel id for latency
AXI_PERFormance test</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GMAC_PERF_CON2</name>
          <description>gmac performance monitor control register</description>
          <addressOffset>0xc008</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GMAC_SW_AW_COUNT_ID</name>
              <description>When    sw_aw_cnt_id_type=1,    only    count
the    id designated by sw_aw_count_id</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GMAC_SW_AR_COUNT_ID</name>
              <description>When    sw_ar_cnt_id_type=1,    only    count
the    id designated by sw_ar_count_id</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GMAC_PERF_RD_MAX_LATENCY_NUM</name>
          <description>gmac performance monitor status register</description>
          <addressOffset>0xc00c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RD_MAX_LATENCY_R</name>
              <description>axi read max latency oaxi read max latency
outpututput</description>
              <bitRange>[12:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GMAC_PERF_RD_LATENCY_SAMP_NUM</name>
          <description>gmac performance monitor status register</description>
          <addressOffset>0xc010</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RD_LATENCY_SAMP_R</name>
              <description>AXI read latency total sample number</description>
              <bitRange>[26:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GMAC_PERF_RD_LATENCY_ACC_NUM</name>
          <description>gmac performance monitor status register</description>
          <addressOffset>0xc014</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RD_LATENCY_ACC_CNT_R</name>
              <description>AXI    read    latency    (&gt;sw_rd_latency_thr)
total number</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GMAC_PERF_RD_AXI_TOTAL_BYTE</name>
          <description>gmac performance monitor status register</description>
          <addressOffset>0xc018</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RD_AXI_TOTAL_BYTE</name>
              <description>AXI active total read bytes/ddr align read
bytes</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GMAC_PERF_WR_AXI_TOTAL_BYTE</name>
          <description>gmac performance monitor status register</description>
          <addressOffset>0xc01c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WR_AXI_TOTAL_BYTE</name>
              <description>AXI active total write bytes/ddr align write
bytes</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GMAC_PERF_WORKING_CNT</name>
          <description>gmac performance monitor status register</description>
          <addressOffset>0xc020</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WORKING_CNT_R</name>
              <description>working counter</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_SOC_CON5</name>
          <description>SoC control register 5</description>
          <addressOffset>0xc214</addressOffset>
          <size>32</size>
          <resetValue>0x8</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GMAC_PHY_INTF_SEL</name>
              <description>PHY interface select
3'b001: RGMII
3'b100: RMII
All others: Reserved</description>
              <bitRange>[11:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GMAC_FLOWCTRL</name>
              <description>GMAC transmit flow control
When set high, instructs the GMAC to transmit
PAUSE Control frames in
Full-duplex mode. In Half-duplex mode, the
GMAC enables the Back-pressure
function until this signal is made low again</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GMAC_SPEED</name>
              <description>MAC speed
1'b1: 100-Mbps
1'b0: 10-Mbps</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RMII_MODE</name>
              <description>RMII mode selection
1'b1: RMII mode
1'b0: MII mode</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GMAC_CLK_SEL</name>
              <description>RGMII clock selection
2'b00: 125MHz
2'b11: 25MHz
2'b10: 2.5MHz</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RMII_CLK_SEL</name>
              <description>RMII clock selection
1'b1: 25MHz
1'b0: 2.5MHz</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_SOC_CON6</name>
          <description>SoC control register 6</description>
          <addressOffset>0xc218</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GMAC_RXCLK_DLY_ENA</name>
              <description>RGMII TX clock delayline enable
1'b1: enable
1'b0: disable</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GMAC_CLK_RX_DL_CFG</name>
              <description>RGMII RX clock delayline value</description>
              <bitRange>[14:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GMAC_TXCLK_DLY_ENA</name>
              <description>RGMII TX clock delayline enable
1'b1: enable
1'b0: disable</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GMAC_CLK_TX_DL_CFG</name>
              <description>RGMII TX clock delayline value</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPIO2A_IOMUX</name>
          <description>GPIO2A iomux control</description>
          <addressOffset>0xe000</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2A7_SEL</name>
              <description>GPIO2A[7] iomux select
2'b00: gpio
2'b01: vop_data7
2'b10: i2c7nfc_sda
2'b11: cif_data7</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2A6_SEL</name>
              <description>GPIO2A[6] iomux select
2'b00: gpio
2'b01: vop_data6
2'b10: uphyjtag_tms
2'b11:cif_data6</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2A5_SEL</name>
              <description>GPIO2A[5] iomux select
2'b00: gpio
2'b01: vop_data5
2'b10: uphyjtag_tck
2'b11: cif_data5</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2A4_SEL</name>
              <description>GPIO2A[4] iomux select
2'b00: gpio
2'b01: vop_data4
2'b10: uphyjtag_tdo
2'b11: cif_data4</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2A3_SEL</name>
              <description>GPIO2A[3] iomux select
2'b00: gpio
2'b01: vop_data3
2'b10: uphyjtag_tdi
2'b11: cif_data3</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2A2_SEL</name>
              <description>GPIO2A[2] iomux select
2'b00: gpio
2'b01: vop_data2
2'b10: uphyjtag_trstn
2'b11: cif_data2</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2A1_SEL</name>
              <description>GPIO2A[1] iomux select
2'b00: gpio
2'b01: vop_data1
2'b10: i2c2tp_scl
2'b11: cif_data1</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2A0_SEL</name>
              <description>GPIO2A[0] iomux select
2'b00: gpio
2'b01: vop_data0
2'b10: i2c2tp_sda
2'b11: cif_data0</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPIO2B_IOMUX</name>
          <description>GPIO2B iomux control</description>
          <addressOffset>0xe004</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2B4_SEL</name>
              <description>GPIO2B[4] iomux select
2'b00: gpio
2'b01: spi2tpm_csn0
2'b10: reserved
2'b11: reserved</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2B3_SEL</name>
              <description>GPIO2B[3] iomux select
2'b00: gpio
2'b01: spi2tpm_clk
2'b10: vop_den
2'b11: cif_clkouta</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2B2_SEL</name>
              <description>GPIO2B[2] iomux select
2'b00: gpio
2'b01: spi2tpm_txd
2'b10: i2c6tpm_scl
2'b11: cif_clkin</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2B1_SEL</name>
              <description>GPIO2B[1] iomux select
2'b00: gpio
2'b01: spi2tpm_rxd
2'b10: i2c6tpm_sda
2'b11: cif_href</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2B0_SEL</name>
              <description>GPIO2B[0] iomux select
2'b00: gpio
2'b01: vop_dclk
2'b10: i2c7nfc_scl
2'b11: cif_vsync</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPIO2C_IOMUX</name>
          <description>GPIO2C iomux control</description>
          <addressOffset>0xe008</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2C7_SEL</name>
              <description>GPIO2C[7] iomux select
2'b00: gpio
2'b01: sdio_data3
2'b10: spi5expplus_csn0
2'b11: reserved</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2C6_SEL</name>
              <description>GPIO2C[6] iomux select
2'b00: gpio
2'b01: sdio_data2
2'b10: spi5expplus_clk
2'b11: reserved</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2C5_SEL</name>
              <description>GPIO2C[5] iomux select
2'b00: gpio
2'b01: sdio_data1
2'b10: spi5expplus_txd
2'b11: reserved</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2C4_SEL</name>
              <description>GPIO2C[4] iomux select
2'b00: gpio
2'b01: sdio_data0
2'b10: spi5expplus_rxd
2'b11: reserved</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2C3_SEL</name>
              <description>GPIO2C[3] iomux select
2'b00: gpio
2'b01: uart0bt_rtsn
2'b10: reserved
2'b11: reserved</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2C2_SEL</name>
              <description>GPIO2C[2] iomux select
2'b00: gpio
2'b01: uart0bt_ctsn
2'b10: reserved
2'b11: reserved</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2C1_SEL</name>
              <description>GPIO2C[1] iomux select
2'b00: gpio
2'b01: uart0bt_sout
2'b10: reserved
2'b11: reserved</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2C0_SEL</name>
              <description>GPIO2C[0] iomux select
2'b00: gpio
2'b01: uart0bt_sin
2'b10: reserved
2'b11: reserved</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPIO2D_IOMUX</name>
          <description>GPIO2D iomux control</description>
          <addressOffset>0xe00c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2D4_SEL</name>
              <description>GPIO2D[4] iomux select
2'b00: gpio
2'b01: sdio_bkpwr
2'b10: reserved
2'b11: reserved</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2D3_SEL</name>
              <description>GPIO2D[3] iomux select
2'b00: gpio
2'b01: sdio_pwren
2'b10: reserved
2'b11: reserved</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2D2_SEL</name>
              <description>GPIO2D[2] iomux select
2'b00: gpio
2'b01: sdio_detectn
2'b10: pcie_clkreqn
2'b11: reserved</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2D1_SEL</name>
              <description>GPIO2D[1] iomux select
2'b00: gpio
2'b01: sdio_clkout
2'b10: test_clkout1
2'b11: reserved</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2D0_SEL</name>
              <description>GPIO2D[0] iomux select
2'b00: gpio
2'b01: sdio_cmd
2'b10: reserved
2'b11: reserved</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPIO3A_IOMUX</name>
          <description>GPIO3A iomux control</description>
          <addressOffset>0xe010</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3A7_SEL</name>
              <description>GPIO3A[7] iomux select
2'b00: gpio
2'b01: mac_rxd1
2'b10: spi0norcodec_csn0
2'b11: reserved</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3A6_SEL</name>
              <description>GPIO3A[6] iomux select
2'b00: gpio
2'b01: mac_rxd0
2'b10: spi0norcodec_clk
2'b11: reserved</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3A5_SEL</name>
              <description>GPIO3A[5] iomux select
2'b00: gpio
2'b01: mac_txd1
2'b10: spi0norcodec_txd
2'b11: reserved</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3A4_SEL</name>
              <description>GPIO3A[4] iomux select
2'b00: gpio
2'b01: mac_txd0
2'b10: spi0norcodec_rxd
2'b11: reserved</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3A3_SEL</name>
              <description>GPIO3A[3] iomux select
2'b00: gpio
2'b01: mac_rxd3
2'b10: spi4exp_csn0
2'b11: trace_data15</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3A2_SEL</name>
              <description>GPIO3A[2] iomux select
2'b00: gpio
2'b01: mac_rxd2
2'b10: spi4exp_clk
2'b11: trace_data14</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3A1_SEL</name>
              <description>GPIO3A[1] iomux select
2'b00: gpio
2'b01: mac_txd3
2'b10: spi4exp_txd
2'b11: trace_data13</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3A0_SEL</name>
              <description>GPIO3A[0] iomux select
2'b00: gpio
2'b01: mac_txd2
2'b10: spi4exp_rxd
2'b11: trace_data12</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPIO3B_IOMUX</name>
          <description>GPIO3B iomux control</description>
          <addressOffset>0xe014</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3B7_SEL</name>
              <description>GPIO3B[7] iomux select
2'b00: gpio
2'b01: mac_crs
2'b10: uart3gps_sout
2'b11: cif_clkoutb</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3B6_SEL</name>
              <description>GPIO3B[6] iomux select
2'b00: gpio
2'b01: mac_rxclk
2'b10: uart3gps_sin
2'b11: reserved</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3B5_SEL</name>
              <description>GPIO3B[5] iomux select
2'b00: gpio
2'b01: mac_mdio
2'b10: uart1bb_sout
2'b11: reserved</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3B4_SEL</name>
              <description>GPIO3B[4] iomux select
2'b00: gpio
2'b01: mac_txen
2'b10: uart1bb_sin
2'b11: reserved</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3B3_SEL</name>
              <description>GPIO3B[3] iomux select
2'b00: gpio
2'b01: mac_clk
2'b10: i2c5trackpad_scl
2'b11: reserved</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3B2_SEL</name>
              <description>GPIO3B[2] iomux select
2'b00: gpio
2'b01: mac_rxer
2'b10:    i2c5trackpad_sda
2'b11: reserved</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3B1_SEL</name>
              <description>GPIO3B[1] iomux select
2'b00: gpio
2'b01: mac_rxdv
2'b10: reserved
2'b11: reserved</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3B0_SEL</name>
              <description>GPIO3B[0] iomux select
2'b00: gpio
2'b01: mac_mdc
2'b10: spi0norcodec_csn1
2'b11: reserved</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPIO3C_IOMUX</name>
          <description>GPIO3C iomux control</description>
          <addressOffset>0xe018</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3C1_SEL</name>
              <description>GPIO3C[1] iomux select
2'b00: gpio
2'b01: mac_txclk
2'b10: uart3gps_rtsn
2'b11: reserved</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3C0_SEL</name>
              <description>GPIO3C[0] iomux select
2'b00: gpio
2'b01: mac_col
2'b10: uart3gps_ctsn
2'b11: spdif_txb</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPIO3D_IOMUX</name>
          <description>GPIO3D iomux control</description>
          <addressOffset>0xe01c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3D7_SEL</name>
              <description>GPIO3D[7] iomux select
2'b00: gpio
2'b01: i2s0_sdo0
2'b10: trace_data7
2'b11: a53l2_wfi</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3D6_SEL</name>
              <description>GPIO3D[6] iomux select
2'b00: gpio
2'b01: i2s0_sdi3sdo1
2'b10: trace_data6
2'b11: a72l2_wfi</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3D5_SEL</name>
              <description>GPIO3D[5] iomux select
2'b00: gpio
2'b01: i2s0_sdi2sdo2
2'b10: trace_data5
2'b11: a53core3_wfi</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3D4_SEL</name>
              <description>GPIO3D[4] iomux select
2'b00: gpio
2'b01: i2s0_sdi1sdo3
2'b10: trace_data4
2'b11: a53core2_wfi</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3D3_SEL</name>
              <description>GPIO3D[3] iomux select
2'b00: gpio
2'b01: i2s0_sdi0
2'b10: trace_data3
2'b11: a53core1_wfi</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3D2_SEL</name>
              <description>GPIO3D[2] iomux select
2'b00: gpio
2'b01: i2s0_lrcktx
2'b10: trace_data2
2'b11: a53core0_wfi</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3D1_SEL</name>
              <description>GPIO3D[1] iomux select
2'b00: gpio
2'b01: i2s0_lrckrx
2'b10: trace_data1
2'b11: a72core1_wfi</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3D0_SEL</name>
              <description>GPIO3D[0] iomux select
2'b00: gpio
2'b01: i2s0_sclk
2'b10: trace_data0
2'b11: a72core0_wfi</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPIO4A_IOMUX</name>
          <description>GPIO4A iomux control</description>
          <addressOffset>0xe020</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4A7_SEL</name>
              <description>GPIO4A[7] iomux select
2'b00: gpio
2'b01: i2s1_sdo0
2'b10: reserved
2'b11: reserved</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4A6_SEL</name>
              <description>GPIO4A[6] iomux select
2'b00: gpio
2'b01: i2s1_sdi0
2'b10: reserved
2'b11: reserved</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4A5_SEL</name>
              <description>GPIO4A[5] iomux select
2'b00: gpio
2'b01: i2s1_lrcktx
2'b10: trace_data11
2'b11: reserved</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4A4_SEL</name>
              <description>GPIO4A[4] iomux select
2'b00: gpio
2'b01: i2s1_lrckrx
2'b10: trace_data10
2'b11: reserved</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4A3_SEL</name>
              <description>GPIO4A[3] iomux select
2'b00: gpio
2'b01: i2s1_sclk
2'b10: trace_data9
2'b11: reserved</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4A2_SEL</name>
              <description>GPIO4A[2] iomux select
2'b00: gpio
2'b01: i2c1audiocam_scl
2'b10: trace_data8
2'b11: reserved</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4A1_SEL</name>
              <description>GPIO4A[1] iomux select
2'b00: gpio
2'b01: i2c1audiocam_sda
2'b10: trace_clk
2'b11: reserved</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4A0_SEL</name>
              <description>GPIO4A[0] iomux select
2'b00: gpio
2'b01: i2s_clk
2'b10: trace_ctl
2'b11: lpm0_wfi</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPIO4B_IOMUX</name>
          <description>GPIO4B iomux control</description>
          <addressOffset>0xe024</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4B5_SEL</name>
              <description>GPIO4B[5] iomux select
2'b00: gpio
2'b01: sdmmc_cmd
2'b10: mcujtag_tms
2'b11: hdcpjtag_tms</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4B4_SEL</name>
              <description>GPIO4B[4] iomux select
2'b00: gpio
2'b01: sdmmc_clkout
2'b10: mcujtag_tck
2'b11: hdcpjtag_tck</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4B3_SEL</name>
              <description>GPIO4B[3] iomux select
2'b00: gpio
2'b01: sdmmc_data3
2'b10: cxcsjtag_tms
2'b11: hdcpjtag_tdo</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4B2_SEL</name>
              <description>GPIO4B[2] iomux select
2'b00: gpio
2'b01: sdmmc_data2
2'b10: cxcsjtag_tck
2'b11: hdcpjtag_tdi</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4B1_SEL</name>
              <description>GPIO4B[1] iomux select
2'b00: gpio
2'b01: sdmmc_data1
2'b10: uart2dbga_sout
2'b11: hdcpjtag_trstn</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4B0_SEL</name>
              <description>GPIO4B[0] iomux select
2'b00: gpio
2'b01: sdmmc_data0
2'b10: uart2dbga_sin
2'b11: reserved</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPIO4C_IOMUX</name>
          <description>GPIO4C iomux control</description>
          <addressOffset>0xe028</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4C7_SEL</name>
              <description>GPIO4C[7] iomux select
2'b00: gpio
2'b01: hdmi_cecinout
2'b10: edp_hotplug
2'b11: reserved</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4C6_SEL</name>
              <description>GPIO4C[6] iomux select
2'b00: gpio
2'b01: pwm_1
2'b10: reserved
2'b11: reserved</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4C5_SEL</name>
              <description>GPIO4C[5] iomux select
2'b00: gpio
2'b01: spdif_tx
2'b10: reserved
2'b11: reserved</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4C4_SEL</name>
              <description>GPIO4C[4] iomux select
2'b00: gpio
2'b01: uart2dbgc_sout
2'b10: uarthdcp_sout
2'b11: reserved</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4C3_SEL</name>
              <description>GPIO4C[3] iomux select
2'b00: gpio
2'b01: uart2dbgc_sin
2'b10: uarthdcp_sin
2'b11: reserved</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4C2_SEL</name>
              <description>GPIO4C[2] iomux select
2'b00: gpio
2'b01: pwm_0
2'b10: vop0_pwm
2'b11: vop1_pwm</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4C1_SEL</name>
              <description>GPIO4C[1] iomux select
2'b00: gpio
2'b01: i2c3hdmi_scl
2'b10: uart2dbgb_sout
2'b11: hdmii2c_scl</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4C0_SEL</name>
              <description>GPIO4C[0] iomux select
2'b00: gpio
2'b01: i2c3hdmi_sda
2'b10: uart2dbgb_sin
2'b11: hdmii2c_sda</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPIO4D_IOMUX</name>
          <description>GPIO4D iomux control</description>
          <addressOffset>0xe02c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4D1_SEL</name>
              <description>GPIO4D[1] iomux select
2'b00: gpio
2'b01: dp_hotplug
2'b10: reserved
2'b11: reserved</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4D0_SEL</name>
              <description>GPIO4D[0] iomux select
2'b00: gpio
2'b01: pcie_clkreqnb
2'b10: reserved
2'b11: reserved</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPIO2A_P</name>
          <description>GPIO2A PU/PD control</description>
          <addressOffset>0xe040</addressOffset>
          <size>32</size>
          <resetValue>0x6aa5</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2A7_P</name>
              <description>GPIO2A PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2A6_P</name>
              <description>GPIO2A PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2A5_P</name>
              <description>GPIO2A PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2A4_P</name>
              <description>GPIO2A PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2A3_P</name>
              <description>GPIO2A PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2A2_P</name>
              <description>GPIO2A PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2A1_P</name>
              <description>GPIO2A PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2A0_P</name>
              <description>GPIO2A PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPIO2B_P</name>
          <description>GPIO2B PU/PD control</description>
          <addressOffset>0xe044</addressOffset>
          <size>32</size>
          <resetValue>0x155</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2B4_P</name>
              <description>GPIO2B PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2B3_P</name>
              <description>GPIO2B PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2B2_P</name>
              <description>GPIO2B PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2B1_P</name>
              <description>GPIO2B PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2B0_P</name>
              <description>GPIO2B PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPIO2C_P</name>
          <description>GPIO2C PU/PD control</description>
          <addressOffset>0xe048</addressOffset>
          <size>32</size>
          <resetValue>0xffff</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2C7_P</name>
              <description>GPIO2C PE/PS programmation section, every
GPIO bit corresponding to 2bits
2'b00: pervious-state
2'b01: weak 0(pull-down);
2'b10: pervious-state
2'b11: weak 1(pull-up);</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2C6_P</name>
              <description>GPIO2C PE/PS programmation section, every
GPIO bit corresponding to 2bits
2'b00: pervious-state
2'b01: weak 0(pull-down);
2'b10: pervious-state
2'b11: weak 1(pull-up);</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2C5_P</name>
              <description>GPIO2C PE/PS programmation section, every
GPIO bit corresponding to 2bits
2'b00: pervious-state
2'b01: weak 0(pull-down);
2'b10: pervious-state
2'b11: weak 1(pull-up);</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2C4_P</name>
              <description>GPIO2C PE/PS programmation section, every
GPIO bit corresponding to 2bits
2'b00: pervious-state
2'b01: weak 0(pull-down);
2'b10: pervious-state
2'b11: weak 1(pull-up);</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2C3_P</name>
              <description>GPIO2C PE/PS programmation section, every
GPIO bit corresponding to 2bits
2'b00: pervious-state
2'b01: weak 0(pull-down);
2'b10: pervious-state
2'b11: weak 1(pull-up);</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2C2_P</name>
              <description>GPIO2C PE/PS programmation section, every
GPIO bit corresponding to 2bits
2'b00: pervious-state
2'b01: weak 0(pull-down);
2'b10: pervious-state
2'b11: weak 1(pull-up);</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2C1_P</name>
              <description>GPIO2C PE/PS programmation section, every
GPIO bit corresponding to 2bits
2'b00: pervious-state
2'b01: weak 0(pull-down);
2'b10: pervious-state
2'b11: weak 1(pull-up);</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2C0_P</name>
              <description>GPIO2C PE/PS programmation section, every
GPIO bit corresponding to 2bits
2'b00: pervious-state
2'b01: weak 0(pull-down);
2'b10: pervious-state
2'b11: weak 1(pull-up);
</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPIO2D_P</name>
          <description>GPIO2D PU/PD control</description>
          <addressOffset>0xe04c</addressOffset>
          <size>32</size>
          <resetValue>0x7f</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2D4_P</name>
              <description>GPIO2D PE/PS programmation section, every
GPIO bit corresponding to 2bits
2'b00: pervious-state
2'b01: weak 0(pull-down);
2'b10: pervious-state
2'b11: weak 1(pull-up);</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2D3_P</name>
              <description>GPIO2D PE/PS programmation section, every
GPIO bit corresponding to 2bits
2'b00: pervious-state
2'b01: weak 0(pull-down);
2'b10: pervious-state
2'b11: weak 1(pull-up);</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2D2_P</name>
              <description>GPIO2D PE/PS programmation section, every
GPIO bit corresponding to 2bits
2'b00: pervious-state
2'b01: weak 0(pull-down);
2'b10: pervious-state
2'b11: weak 1(pull-up);</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2D1_P</name>
              <description>GPIO2D PE/PS programmation section, every
GPIO bit corresponding to 2bits
2'b00: pervious-state
2'b01: weak 0(pull-down);
2'b10: pervious-state
2'b11: weak 1(pull-up);</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2D0_P</name>
              <description>GPIO2D PE/PS programmation section, every
GPIO bit corresponding to 2bits
2'b00: pervious-state
2'b01: weak 0(pull-down);
2'b10: pervious-state
2'b11: weak 1(pull-up);</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPIO3A_P</name>
          <description>GPIO3A PU/PD control</description>
          <addressOffset>0xe050</addressOffset>
          <size>32</size>
          <resetValue>0x5a5a</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3A7_P</name>
              <description>GPIO3A PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3A6_P</name>
              <description>GPIO3A PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3A5_P</name>
              <description>GPIO3A PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3A4_P</name>
              <description>GPIO3A PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3A3_P</name>
              <description>GPIO3A PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3A2_P</name>
              <description>GPIO3A PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3A1_P</name>
              <description>GPIO3A PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3A0_P</name>
              <description>GPIO3A PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPIO3B_P</name>
          <description>GPIO3B PU/PD control</description>
          <addressOffset>0xe054</addressOffset>
          <size>32</size>
          <resetValue>0x5559</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3B7_P</name>
              <description>GPIO3B PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3B6_P</name>
              <description>GPIO3B PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3B5_P</name>
              <description>GPIO3B PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3B4_P</name>
              <description>GPIO3B PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3B3_P</name>
              <description>GPIO3B PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3B2_P</name>
              <description>GPIO3B PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3B1_P</name>
              <description>GPIO3B PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3B0_P</name>
              <description>GPIO3B PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPIO3C_P</name>
          <description>GPIO3C PU/PD control</description>
          <addressOffset>0xe058</addressOffset>
          <size>32</size>
          <resetValue>0x5</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3C1_P</name>
              <description>GPIO3A PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3C0_P</name>
              <description>GPIO3C PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPIO3D_P</name>
          <description>GPIO3D PU/PD control</description>
          <addressOffset>0xe05c</addressOffset>
          <size>32</size>
          <resetValue>0xaaaa</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3D7_P</name>
              <description>GPIO3D PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3D6_P</name>
              <description>GPIO3D PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3D5_P</name>
              <description>GPIO3D PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3D4_P</name>
              <description>GPIO3D PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3D3_P</name>
              <description>GPIO3D PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3D2_P</name>
              <description>GPIO3D PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3D1_P</name>
              <description>GPIO3D PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3D0_P</name>
              <description>GPIO3D PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPIO4A_P</name>
          <description>GPIO4A PU/PD control</description>
          <addressOffset>0xe060</addressOffset>
          <size>32</size>
          <resetValue>0xaa96</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4A7_P</name>
              <description>GPIO4A PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4A6_P</name>
              <description>GPIO4A PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4A5_P</name>
              <description>GPIO4A PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4A4_P</name>
              <description>GPIO4A PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4A3_P</name>
              <description>GPIO4A PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4A2_P</name>
              <description>GPIO4A PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4A1_P</name>
              <description>GPIO4A PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4A0_P</name>
              <description>GPIO4A PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPIO4B_P</name>
          <description>GPIO4B PU/PD control</description>
          <addressOffset>0xe064</addressOffset>
          <size>32</size>
          <resetValue>0x655</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4B5_P</name>
              <description>GPIO4B PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4B4_P</name>
              <description>GPIO4B PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4B3_P</name>
              <description>GPIO4B PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4B2_P</name>
              <description>GPIO4B PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4B1_P</name>
              <description>GPIO4B PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4B0_P</name>
              <description>GPIO4B PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPIO4C_P</name>
          <description>GPIO4C PU/PD control</description>
          <addressOffset>0xe068</addressOffset>
          <size>32</size>
          <resetValue>0x6965</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4C7_P</name>
              <description>GPIO4C PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4C6_P</name>
              <description>GPIO4C PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4C5_P</name>
              <description>GPIO4C PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4C4_P</name>
              <description>GPIO4C PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4C3_P</name>
              <description>GPIO4C PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4C2_P</name>
              <description>GPIO4C PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4C1_P</name>
              <description>GPIO4C PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4C0_P</name>
              <description>GPIO4C PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPIO4D_P</name>
          <description>GPIO4D PU/PD control</description>
          <addressOffset>0xe06c</addressOffset>
          <size>32</size>
          <resetValue>0x2aa9</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4D6_P</name>
              <description>GPIO4D PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4D5_P</name>
              <description>GPIO4D PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4D4_P</name>
              <description>GPIO4D PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4D3_P</name>
              <description>GPIO4D PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4D2_P</name>
              <description>GPIO4D PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4D1_P</name>
              <description>GPIO4D PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4D0_P</name>
              <description>GPIO4D PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPIO2A_SR</name>
          <description>GPIO2A slew rate control</description>
          <addressOffset>0xe080</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2A_SR</name>
              <description>GPIO slew rate programmation section, every
GPIO bit corresponding to 1bits
1'b0: slow
1'b1: fast</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPIO2B_SR</name>
          <description>GPIO2B    slew rate control</description>
          <addressOffset>0xe084</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2B_SR</name>
              <description>GPIO slew rate programmation section, every
GPIO bit corresponding to 1bits
1'b0: slow
1'b1: fast</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPIO2C_SR</name>
          <description>GPIO2C    slew rate control</description>
          <addressOffset>0xe088</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2C_SR</name>
              <description>GPIO slew rate programmation section, every
GPIO bit corresponding to 1bits
1'b0: slow
1'b1: fast</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPIO2D_SR</name>
          <description>GPIO2D    slew rate control</description>
          <addressOffset>0xe08c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2D_SR</name>
              <description>GPIO slew rate programmation section, every
GPIO bit corresponding to 1bits
1'b0: slow
1'b1: fast</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPIO3D_SR</name>
          <description>GPIO3D slew rate control</description>
          <addressOffset>0xe09c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3D_SR</name>
              <description>GPIO slew rate programmation section, every
GPIO bit corresponding to 1bits
1'b0: slow
1'b1: fast</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPIO4A_SR</name>
          <description>GPIO4A    slew rate control</description>
          <addressOffset>0xe0a0</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4A_SR</name>
              <description>GPIO slew rate programmation section, every
GPIO bit corresponding to 1bits
1'b0: slow
1'b1: fast</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPIO4B_SR</name>
          <description>GPIO4B    slew rate control</description>
          <addressOffset>0xe0a4</addressOffset>
          <size>32</size>
          <resetValue>0x3f</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4B_SR</name>
              <description>GPIO slew rate programmation section, every
GPIO bit corresponding to 1bits
1'b0: slow
1'b1: fast</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPIO4C_SR</name>
          <description>GPIO4C    slew rate control</description>
          <addressOffset>0xe0a8</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4C_SR</name>
              <description>GPIO slew rate programmation section, every
GPIO bit corresponding to 1bits
1'b0: slow
1'b1: fast</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPIO4D_SR</name>
          <description>GPIO4D    slew rate control</description>
          <addressOffset>0xe0ac</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4D_SR</name>
              <description>GPIO slew rate programmation section, every
GPIO bit corresponding to 1bits
1'b0: slow
1'b1: fast</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPIO2A_SMT</name>
          <description>GPIO2A smitter control register</description>
          <addressOffset>0xe0c0</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2A_SMT</name>
              <description>GPIO schmitt trigger control, every GPIO bit
corresponding to 1bits .
0: No hysteresis
1: Schmitt trigger enabled.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPIO2B_SMT</name>
          <description>GPIO2B smitter control register</description>
          <addressOffset>0xe0c4</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2B_SMT</name>
              <description>GPIO schmitt trigger control, every GPIO bit
corresponding to 1bits .
0: No hysteresis
1: Schmitt trigger enabled.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPIO2C_SMT</name>
          <description>GPIO2C smitter control register</description>
          <addressOffset>0xe0c8</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2C_SMT</name>
              <description>GPIO schmitt trigger control, every GPIO bit
corresponding to 2 bits .
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPIO2D_SMT</name>
          <description>GPIO2D smitter control register</description>
          <addressOffset>0xe0cc</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2D_SMT</name>
              <description>GPIO schmitt trigger control, every GPIO bit
corresponding to 2 bits .
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPIO3A_SMT</name>
          <description>GPIO3A smitter control register</description>
          <addressOffset>0xe0d0</addressOffset>
          <size>32</size>
          <resetValue>0xf0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3A_SMT</name>
              <description>GPIO schmitt trigger control, every GPIO bit
corresponding to 1bits .
0: No hysteresis
1: Schmitt trigger enabled.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPIO3B_SMT</name>
          <description>GPIO3B smitter control register</description>
          <addressOffset>0xe0d4</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3B_SMT</name>
              <description>GPIO schmitt trigger control, every GPIO bit
corresponding to 1bits .
0: No hysteresis
1: Schmitt trigger enabled.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPIO3C_SMT</name>
          <description>GPIO3C smitter control register</description>
          <addressOffset>0xe0d8</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3C_SMT</name>
              <description>GPIO schmitt trigger control, every GPIO bit
corresponding to 1bits .
0: No hysteresis
1: Schmitt trigger enabled.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPIO3D_SMT</name>
          <description>GPIO3D smitter control register</description>
          <addressOffset>0xe0dc</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3D_SMT</name>
              <description>GPIO schmitt trigger control, every GPIO bit
corresponding to 1bits .
0: No hysteresis
1: Schmitt trigger enabled.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPIO4A_SMT</name>
          <description>GPIO4A smitter control register</description>
          <addressOffset>0xe0e0</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4A_SMT</name>
              <description>GPIO schmitt trigger control, every GPIO bit
corresponding to 1bits .
0: No hysteresis
1: Schmitt trigger enabled.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPIO4B_SMT</name>
          <description>GPIO4B smitter control register</description>
          <addressOffset>0xe0e4</addressOffset>
          <size>32</size>
          <resetValue>0x3f</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4B_SMT</name>
              <description>GPIO schmitt trigger control, every GPIO bit
corresponding to 1bits .
0: No hysteresis
1: Schmitt trigger enabled.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPIO4C_SMT</name>
          <description>GPIO4C smitter control register</description>
          <addressOffset>0xe0e8</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4C_SMT</name>
              <description>GPIO schmitt trigger control, every GPIO bit
corresponding to 1bits .
0: No hysteresis
1: Schmitt trigger enabled.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPIO4D_SMT</name>
          <description>GPIO4D smitter control register</description>
          <addressOffset>0xe0ec</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4D_SMT</name>
              <description>GPIO schmitt trigger control, every GPIO bit
corresponding to 1bits .
0: No hysteresis
1: Schmitt trigger enabled.</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPIO2A_E</name>
          <description>GPIO2A drive strength control</description>
          <addressOffset>0xe100</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2A7_E</name>
              <description>GPIO2A7 drive strength control, every GPIO
bit corresponding to 2bits
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2A6_E</name>
              <description>GPIO2A6 drive strength control, every GPIO
bit corresponding to 2bits
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2A5_E</name>
              <description>GPIO2A5 drive strength control, every GPIO
bit corresponding to 2bits
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2A4_E</name>
              <description>GPIO2A4 drive strength control, every GPIO
bit corresponding to 2bits
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2A3_E</name>
              <description>GPIO2A3 drive strength control, every GPIO
bit corresponding to 2bits
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2A2_E</name>
              <description>GPIO2A2 drive strength control, every GPIO
bit corresponding to 2bits
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2A1_E</name>
              <description>GPIO2A1 drive strength control, every GPIO
bit corresponding to 2bits
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2A0_E</name>
              <description>GPIO2A0 drive strength control, every GPIO
bit corresponding to 2bits
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPIO2B_E</name>
          <description>GPIO2B drive strength control</description>
          <addressOffset>0xe104</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2B7_E</name>
              <description>GPIO2B7 drive strength control, every GPIO
bit corresponding to 2bits
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2B6_E</name>
              <description>GPIO2B6 drive strength control, every GPIO
bit corresponding to 2bits
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2B5_E</name>
              <description>GPIO2B5 drive strength control, every GPIO
bit corresponding to 2bits
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2B4_E</name>
              <description>GPIO2B4 drive strength control, every GPIO
bit corresponding to 2bits
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2B3_E</name>
              <description>GPIO2B3 drive strength control, every GPIO
bit corresponding to 2bits
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2B2_E</name>
              <description>GPIO2B2 drive strength control, every GPIO
bit corresponding to 2bits
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2B1_E</name>
              <description>GPIO2B1 drive strength control, every GPIO
bit corresponding to 2bits
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2B0_E</name>
              <description>GPIO2B0 drive strength control, every GPIO
bit corresponding to 2bits
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPIO2C_E</name>
          <description>GPIO2C drive strength control</description>
          <addressOffset>0xe108</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2C7_E</name>
              <description>GPIO2C7 drive strength control, every GPIO
bit corresponding to 2bits
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2C6_E</name>
              <description>GPIO2C6 drive strength control, every GPIO
bit corresponding to 2bits
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2C5_E</name>
              <description>GPIO2C5 drive strength control, every GPIO
bit corresponding to 2bits
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2C4_E</name>
              <description>GPIO2C4 drive strength control, every GPIO
bit corresponding to 2bits
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2C3_E</name>
              <description>GPIO2C3 drive strength control, every GPIO
bit corresponding to 2bits
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2C2_E</name>
              <description>GPIO2C2 drive strength control, every GPIO
bit corresponding to 2bits
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2C1_E</name>
              <description>GPIO2C1 drive strength control, every GPIO
bit corresponding to 2bits
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2C0_E</name>
              <description>GPIO2C0 drive strength control, every GPIO
bit corresponding to 2bits
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPIO2D_E</name>
          <description>GPIO2D drive strength control</description>
          <addressOffset>0xe10c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2D7_E</name>
              <description>GPIO2D7 drive strength control, every GPIO
bit corresponding to 2bits
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2D6_E</name>
              <description>GPIO2D6 drive strength control, every GPIO
bit corresponding to 2bits
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2D5_E</name>
              <description>GPIO2D5 drive strength control, every GPIO
bit corresponding to 2bits
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2D4_E</name>
              <description>GPIO2D4 drive strength control, every GPIO
bit corresponding to 2bits
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2D3_E</name>
              <description>GPIO2D3 drive strength control, every GPIO
bit corresponding to 2bits
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2D2_E</name>
              <description>GPIO2D2 drive strength control, every GPIO
bit corresponding to 2bits
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2D1_E</name>
              <description>GPIO2D1 drive strength control, every GPIO
bit corresponding to 2bits
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2D0_E</name>
              <description>GPIO2D0 drive strength control, every GPIO
bit corresponding to 2bits
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPIO3A_E01</name>
          <description>GPIO3A drive strength control</description>
          <addressOffset>0xe110</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3A5_E0</name>
              <description>GPIO3A5 drive strength control bit0</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3A4_E</name>
              <description>GPIO3A4 drive strength control bit0 to bit2</description>
              <bitRange>[14:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3A3_E</name>
              <description>GPIO3A3 drive strength control bit0 to bit2</description>
              <bitRange>[11:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3A2_E</name>
              <description>GPIO3A2 drive strength control bit0 to bit2</description>
              <bitRange>[8:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3A1_E</name>
              <description>GPIO3A1 drive strength control bit0 to bit2</description>
              <bitRange>[5:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3A0_E</name>
              <description>GPIO3A0 drive strength control bit0 to bit2
</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPIO3A_E2</name>
          <description>GPIO3B drive strength control</description>
          <addressOffset>0xe114</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3A7_E</name>
              <description>GPIO3A7 drive strength control bit0 to bit2</description>
              <bitRange>[7:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3A6_E</name>
              <description>GPIO3A6 drive strength control bit0 to bit2</description>
              <bitRange>[4:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3A5_E12</name>
              <description>GPIO3A5 drive strength control bit1 and bit2</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPIO3B_E01</name>
          <description>GPIO3B drive strength control</description>
          <addressOffset>0xe118</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3B5_E0</name>
              <description>GPIO3B5 drive strength control bit0</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3B4_E</name>
              <description>GPIO3B4 drive strength control bit0 to bit2</description>
              <bitRange>[14:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3B3_E</name>
              <description>GPIO3B3 drive strength control bit0 to bit2</description>
              <bitRange>[11:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3B2_E</name>
              <description>GPIO3B2 drive strength control bit0 to bit2</description>
              <bitRange>[8:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3B1_E</name>
              <description>GPIO3B1 drive strength control bit0 to bit2</description>
              <bitRange>[5:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3B0_E</name>
              <description>GPIO3B0 drive strength control bit0 to bit2</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPIO3B_E2</name>
          <description>GPIO3B drive strength control</description>
          <addressOffset>0xe11c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3B7_E</name>
              <description>GPIO3B7 drive strength control bit0 to bit2</description>
              <bitRange>[7:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3B6_E</name>
              <description>GPIO3B6 drive strength control bit0 to bit2</description>
              <bitRange>[4:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3B5_E12</name>
              <description>GPIO3B5 drive strength control bit1 to bit2</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPIO3C_E01</name>
          <description>GPIO3C drive strength control</description>
          <addressOffset>0xe120</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3C5_E0</name>
              <description>GPIO3C5 drive strength control bit0</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3C4_E</name>
              <description>GPIO3C4 drive strength control bit0 to bit2</description>
              <bitRange>[14:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3C3_E</name>
              <description>GPIO3C3 drive strength control bit0 to bit2</description>
              <bitRange>[11:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3C2_E</name>
              <description>GPIO3C2 drive strength control bit0 to bit2</description>
              <bitRange>[8:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3C1_E</name>
              <description>GPIO3C1 drive strength control bit0 to bit2</description>
              <bitRange>[5:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3C0_E</name>
              <description>GPIO3C0 drive strength control bit0 to bit2</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPIO3C_E2</name>
          <description>GPIO3C drive strength control</description>
          <addressOffset>0xe124</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3C7_E</name>
              <description>GPIO3C7 drive strength control bit0 to bit2</description>
              <bitRange>[7:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3C6_E</name>
              <description>GPIO3C6 drive strength control bit0 to bit2</description>
              <bitRange>[4:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3C5_E12</name>
              <description>GPIO3C5 drive strength control bit1 and bit2</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPIO3D_E</name>
          <description>GPIO3D drive strength control</description>
          <addressOffset>0xe128</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3D7_E</name>
              <description>GPIO3D7 drive strength control, every GPIO
bit corresponding to 2bits
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3D6_E</name>
              <description>GPIO3D6 drive strength control, every GPIO
bit corresponding to 2bits
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3D5_E</name>
              <description>GPIO3D5 drive strength control, every GPIO
bit corresponding to 2bits
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3D4_E</name>
              <description>GPIO3D4 drive strength control, every GPIO
bit corresponding to 2bits
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3D3_E</name>
              <description>GPIO3D3 drive strength control, every GPIO
bit corresponding to 2bits
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3D2_E</name>
              <description>GPIO3D2 drive strength control, every GPIO
bit corresponding to 2bits
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3D1_E</name>
              <description>GPIO3D1 drive strength control, every GPIO
bit corresponding to 2bits
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO3D0_E</name>
              <description>GPIO3D0 drive strength control, every GPIO
bit corresponding to 2bits
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPIO4A_E</name>
          <description>GPIO4A drive strength control</description>
          <addressOffset>0xe12c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4A7_E</name>
              <description>GPIO4A7 drive strength control, every GPIO
bit corresponding to 2bits
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4A6_E</name>
              <description>GPIO4A6 drive strength control, every GPIO
bit corresponding to 2bits
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4A5_E</name>
              <description>GPIO4A5 drive strength control, every GPIO
bit corresponding to 2bits
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4A4_E</name>
              <description>GPIO4A4 drive strength control, every GPIO
bit corresponding to 2bits
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4A3_E</name>
              <description>GPIO4A3 drive strength control, every GPIO
bit corresponding to 2bits
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4A2_E</name>
              <description>GPIO4A2 drive strength control, every GPIO
bit corresponding to 2bits
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4A1_E</name>
              <description>GPIO4A1 drive strength control, every GPIO
bit corresponding to 2bits
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4A0_E</name>
              <description>GPIO4A0 drive strength control, every GPIO
bit corresponding to 2bits
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPIO4B_E01</name>
          <description>GPIO4B drive strength control</description>
          <addressOffset>0xe130</addressOffset>
          <size>32</size>
          <resetValue>0x9249</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4B5_E0</name>
              <description>GPIO4B5 drive strength control bit0</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4B4_E</name>
              <description>GPIO4B4 drive strength control bit0 to bit2</description>
              <bitRange>[14:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4B3_E</name>
              <description>GPIO4B3 drive strength control bit0 to bit2</description>
              <bitRange>[11:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4B2_E</name>
              <description>GPIO4B2 drive strength control bit0 to bit2</description>
              <bitRange>[8:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4B1_E</name>
              <description>GPIO4B1 drive strength control bit0 to bit2</description>
              <bitRange>[5:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4B0_E</name>
              <description>GPIO4B0 drive strength control bit0 to bit2</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPIO4B_E2</name>
          <description>GPIO4B drive strength control</description>
          <addressOffset>0xe134</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4B7_E</name>
              <description>GPIO4B7 drive strength control bit0 to bit2</description>
              <bitRange>[7:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4B6_E</name>
              <description>GPIO4B6 drive strength control bit0 to bit2</description>
              <bitRange>[4:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4B5_E12</name>
              <description>GPIO4B5 drive strength control bit2</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPIO4C_E</name>
          <description>GPIO4C drive strength control</description>
          <addressOffset>0xe138</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4C7_E</name>
              <description>GPIO4C7 drive strength control, every GPIO
bit corresponding to 2bits
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4C6_E</name>
              <description>GPIO4C6 drive strength control, every GPIO
bit corresponding to 2bits
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4C5_E</name>
              <description>GPIO4C5 drive strength control, every GPIO
bit corresponding to 2bits
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4C4_E</name>
              <description>GPIO4C4 drive strength control, every GPIO
bit corresponding to 2bits
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4C3_E</name>
              <description>GPIO4C3 drive strength control, every GPIO
bit corresponding to 2bits
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4C2_E</name>
              <description>GPIO4C2 drive strength control, every GPIO
bit corresponding to 2bits
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4C1_E</name>
              <description>GPIO4C1 drive strength control, every GPIO
bit corresponding to 2bits
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4C0_E</name>
              <description>GPIO4C0 drive strength control, every GPIO
bit corresponding to 2bits
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPIO4D_E</name>
          <description>GPIO4D drive strength control</description>
          <addressOffset>0xe13c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4D7_E</name>
              <description>GPIO4D7 drive strength control, every GPIO
bit corresponding to 2bits
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4D6_E</name>
              <description>GPIO4D6 drive strength control, every GPIO
bit corresponding to 2bits
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4D5_E</name>
              <description>GPIO4D5 drive strength control, every GPIO
bit corresponding to 2bits
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4D4_E</name>
              <description>GPIO4D4 drive strength control, every GPIO
bit corresponding to 2bits
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4D3_E</name>
              <description>GPIO4D3 drive strength control, every GPIO
bit corresponding to 2bits
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4D2_E</name>
              <description>GPIO4D2 drive strength control, every GPIO
bit corresponding to 2bits
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4D1_E</name>
              <description>GPIO4D1 drive strength control, every GPIO
bit corresponding to 2bits
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO4D0_E</name>
              <description>GPIO4D0 drive strength control, every GPIO
bit corresponding to 2bits
2'b00: level 0
2'b01: level 1
2'b10: level 2
2'b11: level 3</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPIO2C_HE</name>
          <description>GPIO2C HE control</description>
          <addressOffset>0xe188</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2C_HE</name>
              <description>GPIO2C gpio keep privous state control, every
GPIO bit corresponding to 1bit
1'b0: disable
1'b1: enable</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_GPIO2D_HE</name>
          <description>GPIO2D HE control</description>
          <addressOffset>0xe18c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2D_HE</name>
              <description>GPIO2D gpio keep privous state control, every
GPIO bit corresponding to 1bit
1'b0: disable
1'b1: enable</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_SOC_CON0</name>
          <description>SoC control register 0</description>
          <addressOffset>0xe200</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMMC_FWD_PERIHP_PWRDISCTARGPWRSTALL</name>
              <description>noc_emmc_fwd_perihp_rsp_err_stall bit
control
0: error response
1: stall response</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CENTERSRV_FWD_CCIM1_PWRDISCTARGPWRSTALL</name>
              <description>noc_centersrv_fwd_ccim1_rsp_err_stall bit
control
0: error response
1: stall response</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CENTER_FWD_VIO_PWRDISCTARGPWRSTALL</name>
              <description>noc_center_fwd_vio_rsp_err_stall bit control
0: error response
1: stall response</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CENTER_FWD_VDU_PWRDISCTARGPWRSTALL</name>
              <description>noc_center_fwd_vdu_rsp_err_stall bit control
0: error response
1: stall response</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CENTER_FWD_VCODEC_PWRDISCTARGPWRSTALL</name>
              <description>noc_center_fwd_vcodec_rsp_err_stall bit
control
0: error response
1: stall response</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CENTER_FWD_USB3_PWRDISCTARGPWRSTALL</name>
              <description>noc_center_fwd_usb3_rsp_err_stall bit
control
0: error response
1: stall response</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CENTER_FWD_RGA_PWRDISCTARGPWRSTALL</name>
              <description>noc_center_fwd_rga_rsp_err_stall bit control
0: error response
1: stall response</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CENTER_FWD_PERIHP_PWRDISCTARGPWRSTALL</name>
              <description>noc_center_fwd_perihp_rsp_err_stall bit
control
0: error response
1: stall response</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CENTER_FWD_IEP_PWRDISCTARGPWRSTALL</name>
              <description>noc_center_fwd_iep_rsp_err_stall bit control
0: error response
1: stall response</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CENTER_FWD_GPU_PWRDISCTARGPWRSTALL</name>
              <description>noc_center_fwd_gpu_rsp_err_stall bit control
0: error response
1: stall response</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PERILP_FWD_GMAC_PWRDISCTARGPWRSTALL</name>
              <description>perilp_fwd_gmac_rsp_err_stall bit control
0: error response
1: stall response</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PERILP_FWD_EMMC_PWRDISCTARGPWRSTALL</name>
              <description>perilp_fwd_emmc_rsp_err_stall bit control
0: error response
1: stall response</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CENTER_FWD_EDP_PWRDISCTARGPWRSTALL</name>
              <description>noc_center_fwd_edp_rsp_err_stall bit control
0: error response
1: stall response</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CCI_REQ_MSCH1_PWRDISCTARGPWRSTALL</name>
              <description>noc_cci_req_msch1_rsp_err_stall bit control
0: error response
1: stall response</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CCI_REQ_MSCH0_PWRDISCTARGPWRSTALL</name>
              <description>noc__rsp_err_stall bit control
0: error response
1: stall response</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CCI_FWD_PERILP_PWRDISCTARGPWRSTALL</name>
              <description>noc_cci_fwd_perilp_rsp_err_stall bit control
0: error response
1: stall response</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_SOC_CON1</name>
          <description>SoC control register 2</description>
          <addressOffset>0xe204</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PERIHP_FWD_CCI_PWRDISCTARGPWRSTALL</name>
              <description>noc_perihp_fwd_cci_rsp_err_stall bit control
0: error response
1: stall response</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PERIHP_FWD_ALIVE_PWRDISCTARGPWRSTALL</name>
              <description>noc_perihp_fwd_alive_rsp_err_stall bit
control
0: error response
1: stall response</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PERIHP_CM0_FWD_PERIHP_PWRDISCTARGPWRSTAL</name>
              <description>l
noc_perihp_cm0_fwd_perihp_rsp_err_stall
bit control
0: error response
1: stall response</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PERIHP_REQ_MSCH1_PWRDISCTARGPWRSTALL</name>
              <description>noc_perihp_req_msch1_rsp_err_stall bit
control
0: error response
1: stall response</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PERIHP_REQ_MSCH0_PWRDISCTARGPWRSTALL</name>
              <description>noc_perihp_req_msch0_rsp_err_stall bit
control
0: error response
1: stall response</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PERIHP_FWD_CENTER_PWRDISCTARGPWRSTALL</name>
              <description>noc_perihp_fwd_center_rsp_err_stall bit
control
0: error response
1: stall response</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCIE_FWD_PERIHP_PWRDISCTARGPWRSTALL</name>
              <description>noc_pcie_fwd_perihp_rsp_err_stall bit control
0: error response
1: stall response</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MSCH1REGSRV_FWD_MSCH1_PWRDISCTARGPWRST</name>
              <description>all
noc_msch1regsrv_fwd_msch1_rsp_err_stall
bit control
0: error response
1: stall response</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MSCH0REGSRV_FWD_MSCH0_PWRDISCTARGPWRST</name>
              <description>all
noc_msch0regsrv_fwd_msch0_rsp_err_stall
bit control
0: error response
1: stall response</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ISP1_REQ_MSCH01_PWRDISCTARGPWRSTALL</name>
              <description>noc_isp1_req_msch01_rsp_err_stall bit
control
0: error response
1: stall response</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ISP0_REQ_MSCH01_PWRDISCTARGPWRSTALL</name>
              <description>noc_isp0_req_msch01_rsp_err_stall bit
control
0: error response
1: stall response</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IEP_REQ_MSCH1_PWRDISCTARGPWRSTALL</name>
              <description>noc_iep_req_msch1_rsp_err_stall bit control
0: error response
1: stall response</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IEP_REQ_MSCH0_PWRDISCTARGPWRSTALL</name>
              <description>noc_iep_req_msch0_rsp_err_stall bit control
0: error response
1: stall response</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HDCP_REQ_MSCH01_PWRDISCTARGPWRSTALL</name>
              <description>noc_hdcp_req_msch01_rsp_err_stall bit
control
0: error response
1: stall response</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPU_REQ_MSCH1_PWRDISCTARGPWRSTALL</name>
              <description>noc_gpu_req_msch1_rsp_err_stall bit control
0: error response
1: stall response</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPU_REQ_MSCH0_PWRDISCTARGPWRSTALL</name>
              <description>noc_gpu_req_msch0_rsp_err_stall bit control
0: error response
1: stall response</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_SOC_CON2</name>
          <description>SoC control register 1</description>
          <addressOffset>0xe208</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>Fbit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VIO0_REQ_MSCH0_PWRDISCTARGPWRSTALL</name>
              <description>noc_vio0_req_msch0_rsp_err_stall bit
control
0: error response
1: stall response</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VDU_REQ_MSCH1_PWRDISCTARGPWRSTALL</name>
              <description>noc_vdu_req_msch1_rsp_err_stall bit control
0: error response
1: stall response</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VDU_REQ_MSCH0_PWRDISCTARGPWRSTALL</name>
              <description>noc_vdu_req_msch0_rsp_err_stall bit control
0: error response
1: stall response</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VCODEC_REQ_MSCH1_PWRDISCTARGPWRSTALL</name>
              <description>noc_vcodec_req_msch1_rsp_err_stall bit
control
0: error response
1: stall response</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VCODEC_REQ_MSCH0_PWRDISCTARGPWRSTALL</name>
              <description>noc_vcodec_req_msch0_rsp_err_stall bit
control
0: error response
1: stall response</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>USB3_REQ_MSCH1_PWRDISCTARGPWRSTALL</name>
              <description>noc_usb3_req_msch1_rsp_err_stall bit
control
0: error response
1: stall response</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>USB3_REQ_MSCH0_PWRDISCTARGPWRSTALL</name>
              <description>noc_usb3_req_msch0_rsp_err_stall bit
control
0: error response
1: stall response</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RGA_REQ_MSCH1_PWRDISCTARGPWRSTALL</name>
              <description>noc_rga_req_msch1_rsp_err_stall bit control
0: error response
1: stall response</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RGA_REQ_MSCH0_PWRDISCTARGPWRSTALL</name>
              <description>noc_rga_req_msch0_rsp_err_stall bit control
0: error response
1: stall response</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDIOAUDIO_FWD_PERILP_PWRDISCTARGPWRSTALL</name>
              <description>noc_pmu_fwd_perilp_rsp_err_stall bit control
0: error response
1: stall response</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GMAC_FWD_PERIHP_PWRDISCTARGPWRSTALL</name>
              <description>noc_gmac_fwd_perihp_rsp_err_stall bit
control
0: error response
1: stall response</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PERILPSRV_FWD_CM0_PWRDISCTARGPWRSTALL</name>
              <description>noc_perilpsrv_fwd_cm0_rsp_err_stall bit
control
0: error response
1: stall response</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PERILP_REQ_MSCH1_PWRDISCTARGPWRSTALL</name>
              <description>noc_perilp_req_msch1_rsp_err_stall bit
control
0: error response
1: stall response</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PERILP_REQ_MSCH0_PWRDISCTARGPWRSTALL</name>
              <description>noc_perilp_req_msch0_rsp_err_stall bit
control
0: error response
1: stall response</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PERILP_FWD_PMU_PWRDISCTARGPWRSTALL</name>
              <description>noc_perilp_fwd_pmu_rsp_err_stall bit control
0: error response
1: stall response
</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PERILP_FWD_CENTER_PWRDISCTARGPWRSTALL</name>
              <description>noc_perilp_fwd_center_rsp_err_stall bit
control
0: error response
1: stall response</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_SOC_CON3</name>
          <description>SoC control register 3</description>
          <addressOffset>0xe20c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PERIHP_FWD_SD_PWRDISCTARGPWRSTALL</name>
              <description>noc_perihp_fwd_sd_rsp_err_stall bit control
0: error response
1: stall response</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GIC_FWD_PERILP_PWRDISCTARGPWRSTALL</name>
              <description>noc_gic_fwd_perilp_rsp_err_stall bit control
0: error response
1: stall response</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SD_FWD_PERIHP_PWRDISCTARGPWRSTALL</name>
              <description>noc_sd_fwd_perihp_rsp_err_stall bit control
0: error response
1: stall response</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VOPL_REQ_MSCH11_PWRDISCTARGPWRSTALL</name>
              <description>noc_vopl_req_msch11_rsp_err_stall bit
control
0: error response
1: stall response</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VOPB_REQ_MSCH11_PWRDISCTARGPWRSTALL</name>
              <description>noc_vopb_req_msch11_rsp_err_stall bit
control
0: error response
1: stall response</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VIO_FWD_HDCP_PWRDISCTARGPWRSTALL</name>
              <description>noc_vio_fwd_hdcp_rsp_err_stall bit control
0: error response
1: stall response</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VIO_FWD_VOPL_PWRDISCTARGPWRSTALL</name>
              <description>noc_vio_fwd_vopl_rsp_err_stall bit control
0: error response
1: stall response</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VIO_FWD_VOPB_PWRDISCTARGPWRSTALL</name>
              <description>noc_vio_fwd_vopb_rsp_err_stall bit control
0: error response
1: stall response</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VIO_FWD_ISP1_PWRDISCTARGPWRSTALL</name>
              <description>noc_vio_fwd_isp1_rsp_err_stall bit control
0: error response
1: stall response</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VIO_FWD_ISP0_PWRDISCTARGPWRSTALL</name>
              <description>noc_vio_fwd_isp0_rsp_err_stall bit control
0: error response
1: stall response</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>USB3_FWD_PERILP_PWRDISCTARGPWRSTALL</name>
              <description>noc_usb3_fwd_perilp_rsp_err_stall bit
control
0: error response
1: stall response</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VIOL_REQ_MSCH01_PWRDISCTARGPWRSTALL</name>
              <description>noc_viol_req_msch01_rsp_err_stall bit
control
0: error response
1: stall response</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VIOB_REQ_MSCH01_PWRDISCTARGPWRSTALL</name>
              <description>noc_viob_req_msch01_rsp_err_stall bit
control
0: error response
1: stall response</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VIO1_REQ_MSCH1_PWRDISCTARGPWRSTALL</name>
              <description>noc_vio1_req_msch1_rsp_err_stall bit
control
0: error response
1: stall response</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VIO1_REQ_MSCH0_PWRDISCTARGPWRSTALL</name>
              <description>noc_vio1_req_msch0_rsp_err_stall bit
control
0: error response
1: stall response</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VIO0_REQ_MSCH1_PWRDISCTARGPWRSTALL</name>
              <description>noc_vio0_req_msch1_rsp_err_stall bit
control
0: error response
1: stall response</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_SOC_CON4</name>
          <description>SoC control register 4</description>
          <addressOffset>0xe210</addressOffset>
          <size>32</size>
          <resetValue>0x10f</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PERILP_FWD_CENTERSLV_PWRDISCTARGPWRSTALL</name>
              <description>noc_perilp_fwd_centerslv_rsp_err_stall bit
control
0: error response
1: stall response</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PERILP_FWD_SDIOAUDIO_PWRDISCTARGPWRSTALL</name>
              <description>noc_perilp_fwd_sdioaudio_rsp_err_stall bit
control
0: error response
1: stall response</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PERILP_FWD_GIC_PWRDISCTARGPWRSTALL</name>
              <description>noc_perilp_fwd_gic_rsp_err_stall bit control
0: error response
1: stall response</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DDR_DEBUG_SEL</name>
              <description>select ddr debug port
0: ddr_dbug_port[7:0]
1: ddr_dbug_port[15:8]
2: ddr_dbug_port[23:16]
3: ddr_dbug_port[31:24]
4: ddr_dbug_port[39:32]
5: ddr_dbug_port[47:40]
6: ddr_dbug_port[55:48]
7: ddr_dbug_port[63:56]</description>
              <bitRange>[11:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CCI_FORCE_WAKEUP</name>
              <description>cci force wakeup control
1'b0: disable
1'b1: enable</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CCI_QOSOVERRIDE</name>
              <description>cci port QOSOVERRIDE bit control</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CCI_ORDERED_WR_OBSV</name>
              <description>cci port ORDERED_WRITE_OBSERVATION
control
</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACCHANNELENS1_CCI500</name>
              <description>CCI ACCHANNELEN input control.
Slave interface supports DVM messages.
This is overridden to 0x0 if you set the Control
Override Register[1].</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACCHANNELENS0_CCI500</name>
              <description>CCI ACCHANNELEN input control.
Slave interface supports DVM messages.
This is overridden to 0x0 if you set the Control
Override Register[1].</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_SOC_CON_5_PCIE</name>
          <description>SoC control register 5</description>
          <addressOffset>0xe214</addressOffset>
          <size>32</size>
          <resetValue>0x2</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCIE_TX_ELEC_IDLE_OFF</name>
              <description>pcie_tx_elec_idle_off[3:0] port control</description>
              <bitRange>[6:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCIE_RX_ELEC_IDLE_IRQ_EN</name>
              <description>pcie_rx_elec_idle_irq_en port control</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCIE_TX_ELEC_IDLE_SET</name>
              <description>pcie_tx_elec_idle_set port control</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCIE_TX_ELEC_IDLE_SEL</name>
              <description>pcie_tx_elec_idle_sel port control</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_SOC_CON7</name>
          <description>SoC control register 7</description>
          <addressOffset>0xe21c</addressOffset>
          <size>32</size>
          <resetValue>0x1000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GIC_AWUSER_MODE</name>
              <description>gic_awuser mode select
1: address mode
0: user mode</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCIE_CLKREQ_SEL</name>
              <description>pcie_clkreq_sel port control</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GRF_CON_FORCE_JTAG</name>
              <description>grf_con_force_jtag
</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GRF_UART_DBG_SEL</name>
              <description>grf_uart_dbg_sel
</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GRF_UART_RTS_SEL</name>
              <description>uart_rts_sel bit control
UART polarity selection for rts port
Every bit for one UART.
1'b1: invert    uart_rts_n
1'b0: keep the rts_n value from UART module
output</description>
              <bitRange>[9:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GRF_UART_CTS_SEL</name>
              <description>UART polarity selection for cts port
Every bit for one UART.
1'b1: invert    uart_cts_n
1'b0: keep the cts_n value from IO</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_SOC_CON8</name>
          <description>SoC control register 8</description>
          <addressOffset>0xe220</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2S0_SCLK_OE_N</name>
              <description>i2s0_sclk_oe_n bit control</description>
              <bitRange>[14:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCIE_TEST_I</name>
              <description>pci test input</description>
              <bitRange>[10:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCIE_TEST_ADDR</name>
              <description>pci test address control</description>
              <bitRange>[6:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCIE_TEST_WRITE</name>
              <description>pcie test    write control
1'b0: disable
1'b1: enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_SOC_CON_9_PCIE</name>
          <description>SoC control register 9 for PCIE</description>
          <addressOffset>0xe224</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCIE_RC_MODE_IDLE_IRQ_CLR</name>
              <description>irq clear bit for pcie_rc_mode_idle_irq
</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_SOC_STATUS0</name>
          <description>SOC status register 0</description>
          <addressOffset>0xe2a0</addressOffset>
          <size>32</size>
          <resetValue>0x3</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DDR1_MEM_RST_VALID</name>
              <description>status bit of ddr1_mem_rst_valid</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DDR1_Q_ALMOST_FULL</name>
              <description>status bit of ddr1_q_almost_full</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DDR1_REFRESH_IN_PROCESS</name>
              <description>status bit of ddr1_refresh_in_process</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DDR1_CONTROLLER_BUSY</name>
              <description>status bit of ddr1_controller_busy</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DDR1_PORT_BUSY</name>
              <description>status bit of ddr1_port_busy</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DDR1_ZQ_STATUS_OUT</name>
              <description>status bit of ddr1_zq_status_out</description>
              <bitRange>[19:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DDR1_CKE_STATUS</name>
              <description>status bit of ddr1_cke_status</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DDR0_MEM_RST_VALID</name>
              <description>status bit of ddr0_mem_rst_valid</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DDR0_Q_ALMOST_FULL</name>
              <description>status bit of ddr0_q_almost_full</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DDR0_REFRESH_IN_PROCESS</name>
              <description>status bit of ddr0_refresh_in_process</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DDR0_CONTROLLER_BUSY</name>
              <description>status bit of ddr0_controller_busy</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DDR0_PORT_BUSY</name>
              <description>status bit of ddr0_port_busy</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DDR0_ZQ_STATUS_OUT</name>
              <description>status bit of ddr0_zq_status_out</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DDR0_CKE_STATUS</name>
              <description>status bit of ddr0_cke_status</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_SOC_STATUS1</name>
          <description>SOC status register 1</description>
          <addressOffset>0xe2a4</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GRF_PCIE_TEST_O</name>
              <description>status bit of grf_pcie_test_o</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPHY_RX0_TESTDOUT</name>
              <description>status bit of dphy_rx0_testdout</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_SOC_STATUS2</name>
          <description>SOC status register 2</description>
          <addressOffset>0xe2a8</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>M0_PERILP_CDBGPWRUPREQ</name>
              <description>m0_perilp_cdbgpwrupreq status bit</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M0_PERILP_SYSRESETREQ</name>
              <description>m0_perilp_sysresetreq</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>JTAGNSW_ST</name>
              <description>status bit of jtagnsw_st</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>JTAGTOP_ST</name>
              <description>status bit of jtagtop_st</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TXEV_M0_PERILP</name>
              <description>status bit of xev_m0_perilp</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M0_PERILP_DBGRESTARTED</name>
              <description>status bit of m0_perilp_dbgrestarted</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M0_PERILP_HALTED</name>
              <description>status bit of m0_perilp_halted</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M0_PERILP_CORE_LOCKUP</name>
              <description>status bit of m0_perilp_core_lockup</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M0_PERILP_SLEEPDEEP</name>
              <description>status bit of m0_perilp_sleeping</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M0_PERILP_SLEEPING</name>
              <description>status bit of m0_perilp_sleeping</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M0_PERILP_WAKEUP</name>
              <description>status bit of m0_perilp_wakeup</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_SOC_STATUS3</name>
          <description>SOC status register 3</description>
          <addressOffset>0xe2ac</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>USBCPHY1_HOST_UTMI_HOSTDISCONNECT</name>
              <description>usbcphy1_host_utmi_hostdisconnect status</description>
              <bitRange>[27:27]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>USBCPHY1_HOST_UTMI_LINESTATE</name>
              <description>usbcphy1_host_utmi_linestate status</description>
              <bitRange>[26:25]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>USBCPHY1_HOST_UTMI_FS_XVER_OWN</name>
              <description>1: ohci owns usb2phy
0: ehci owns usb2phy</description>
              <bitRange>[24:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>USBCPHY0_HOST_UTMI_HOSTDISCONNECT</name>
              <description>usbcphy0_host_utmi_hostdisconnect status</description>
              <bitRange>[23:23]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>USBCPHY0_HOST_UTMI_LINESTATE</name>
              <description>usbcphy0_host_utmi_linestate status</description>
              <bitRange>[22:21]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>USBCPHY0_HOST_UTMI_FS_XVER_OWN</name>
              <description>1: ohci owns usb2phy
0: ehci owns usb2phy</description>
              <bitRange>[20:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>USBCPHY1_OTG_UTMI_HOSTDISCONNECT</name>
              <description>usbcphy1_otg_utmi_hostdisconnect status</description>
              <bitRange>[19:19]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>USBCPHY1_OTG_UTMI_LINESTATE</name>
              <description>usbcphy1_otg_utmi_linestate status bit</description>
              <bitRange>[18:17]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>USBCPHY1_OTG_UTMI_BVALID</name>
              <description>usbcphy1_otg_utmi_bvalid status bit</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>USBCPHY0_OTG_UTMI_HOSTDISCONNECT</name>
              <description>usbcphy0_otg_utmi_hostdisconnect status</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>USBCPHY0_OTG_UTMI_LINESTATE</name>
              <description>usbcphy0_otg_utmi_linestate status bit</description>
              <bitRange>[14:13]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>USBCPHY0_OTG_UTMI_BVALID</name>
              <description>usbcphy0_otg_utmi_bvalid status bit</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>USBCPHY1_OTG_UTMI_IDDIG</name>
              <description>usbcphy1_otg_utmi_iddig status bit</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>USBCPHY1_OTG_UTMI_AVALID</name>
              <description>usbcphy1_otg_utmi_avalid status bit</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>USBCPHY1_OTG_UTMI_SESSEND</name>
              <description>usbcphy1_otg_utmi_sessend status bit</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>USBCPHY0_OTG_UTMI_IDDIG</name>
              <description>usbcphy0_otg_utmi_iddig status bit</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>USBCPHY0_OTG_UTMI_AVALID</name>
              <description>usbcphy0_otg_utmi_avalid status bit</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>USBCPHY0_OTG_UTMI_SESSEND</name>
              <description>usbcphy0_otg_utmi_sessend status bit</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>USB20_PHY1_STAT_CP_DETECTED</name>
              <description>usb20_phy1_stat_cp_detected status bit</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>USB20_PHY1_STAT_DCP_DETECTED</name>
              <description>usb20_phy1_stat_dcp_detected status bit</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>USB20_PHY1_STAT_DP_ATTACHED</name>
              <description>usb20_phy1_stat_dp_attached status bit</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>USB20_PHY0_STAT_CP_DETECTED</name>
              <description>usb20_phy0_stat_cp_detected status bit</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>USB20_PHY0_STAT_DCP_DETECTED</name>
              <description>usb20_phy0_stat_dcp_detected status bit</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>USB20_PHY0_STAT_DP_ATTACHED</name>
              <description>usb20_phy0_stat_dp_attached status bit</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_SOC_STATUS4</name>
          <description>SOC status register 4</description>
          <addressOffset>0xe2b0</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DDR_MONITOR</name>
              <description>ddr_monitor[31:0] status bit</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_SOC_STATUS5</name>
          <description>SOC status register 5</description>
          <addressOffset>0xe2b4</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DDR_MONITOR</name>
              <description>ddr_monitor[62:32] status bit</description>
              <bitRange>[30:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_DDRC0_CON0</name>
          <description>ddrc0 control register 0</description>
          <addressOffset>0xe380</addressOffset>
          <size>32</size>
          <resetValue>0x1f81</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DDR0_OE_POLARITY</name>
              <description>bit control of ddr0_oe_polarity</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DDR0_DRAM_CLK_ENABLE_POLARITY</name>
              <description>bit control of ddr0_dram_clk_enable_polarity</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DDR0_IO_CTRL_OE_POLARITY</name>
              <description>bit control of ddr0_io_ctrl_ie_polarity</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DDR0_IO_CTRL_IE_POLARITY</name>
              <description>bit control of ddr0_io_ctrl_ie_polarity</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DDR0_IE_POLARITY</name>
              <description>bit control of ddr0_ie_polarity</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DDR0_TSEL_EN_POLARITY</name>
              <description>bit control of ddr0_tsel_en_polarity</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DDR0_LP4_ADDR_DUP</name>
              <description>bit conrol of ddr0_lp4_addr_dup</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DDR0_ZQ_STATUS_IN</name>
              <description>bit control of ddr0_zq_status_in</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_DDRC0_CON1</name>
          <description>ddrc0 control register 1</description>
          <addressOffset>0xe384</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DENALI0_COMMAND_PRIORITY</name>
              <description>bit control of denali0_command_priority</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_DDR0_MSCH_EN_STDBY</name>
              <description>bit control of clk_ddr0_msch_en_stdby</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_DDRPHY0_EN_STDBY</name>
              <description>bit control of clk_ddrphy0_en_stdby</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_DDRPHY_CTRL0_EN_STDBY</name>
              <description>bit control of clk_ddrc0_en_stdby</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_DDRC0_EN_STDBY</name>
              <description>bit control of clk_ddrc0_en_stdby</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_DDRC1_CON0</name>
          <description>ddrc1 control register 0</description>
          <addressOffset>0xe388</addressOffset>
          <size>32</size>
          <resetValue>0x1f81</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DDR1_OE_POLARITY</name>
              <description>bit control of ddr1_oe_polarity</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DDR1_DRAM_CLK_ENABLE_POLARITY</name>
              <description>bit control of ddr1_dram_clk_enable_polarity</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DDR1_IO_CTRL_OE_POLARITY</name>
              <description>bit control of ddr1_io_ctrl_oe_polarity</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DDR1_IO_CTRL_IE_POLARITY</name>
              <description>bit control of ddr1_io_ctrl_ie_polarity</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DDR1_IE_POLARITY</name>
              <description>bit control of ddr1_ie_polarity</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DDR1_TSEL_EN_POLARITY</name>
              <description>bit control of ddr1_tsel_en_polarity</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DDR1_LP4_ADDR_DUP</name>
              <description>bit control of ddr1_lp4_addr_dup</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DDR1_ZQ_STATUS_IN</name>
              <description>bit control of ddr1_zq_status_in</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_DDRC1_CON1</name>
          <description>ddrc1 control register 1</description>
          <addressOffset>0xe38c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DENALI1_COMMAND_PRIORITY</name>
              <description>bit control of denali1_command_priority</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_DDR1_MSCH_EN_STDBY</name>
              <description>bit control of clk_ddr1_msch_en_stdby</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_DDRPHY1_EN_STDBY</name>
              <description>bit control of clk_ddrphy1_en_stdby</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_DDRPHY_CTRL1_EN_STDBY</name>
              <description>bit control of clk_ddrphy_ctrl1_en_stdby</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_DDRC1_EN_STDBY</name>
              <description>bit control of clk_ddrc1_en_stdby</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_SIG_DETECT_CON0</name>
          <description>Singal detect control register0</description>
          <addressOffset>0xe3c0</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UPHY1_RXDET_EN</name>
              <description>uphy1_rxdet phy conrol bit</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UPHY0_RXDET_EN</name>
              <description>uphy0_rxdet phy conrol bit</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UPHY1_RXDET_CHANGE</name>
              <description>uphy1_rxdet_change detect control
1'b0: disbale
1'b1: enable</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UPHY0_RXDET_CHANGE</name>
              <description>uphy0_rxdet_change detect control
1'b0: disbale
1'b1: enable</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPHY1_HOST_LINESTATE_CHANGE</name>
              <description>cphy1_host_linestate_change detect control
1'b0: disbale
1'b1: enable</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPHY1_OTG_ID_FALL</name>
              <description>cphy1_otg_id_fall detect control
1'b0: disbale
1'b1: enable</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPHY1_OTG_ID_RISE</name>
              <description>cphy1_otg_id_rise detect control
1'b0: disbale
1'b1: enable</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPHY1_OTG_BVALID_RISE</name>
              <description>cphy1_otg_bvalid_rise detect control
1'b0: disbale
1'b1: enable</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPHY1_OTG_LINESTATE_CHANGE</name>
              <description>cphy1_otg_linestate_change detect control
1'b0: disbale
1'b1: enable</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPHY0_HOST_LINESTATE_CHANGE</name>
              <description>cphy0_host_linestate_change detect control
1'b0: disbale
1'b1: enable</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPHY0_OTG_ID_FALL</name>
              <description>cphy0_otg_id_fall detect control
1'b0: disbale
1'b1: enable</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPHY0_OTG_ID_RISE</name>
              <description>cphy0_otg_id_rise detect control
1'b0: disbale
1'b1: enable</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPHY0_OTG_BVALID_RISE</name>
              <description>cphy0_otg_bvalid_rise detect control
1'b0: disbale
1'b1: enable</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPHY0_OTG_LINESTATE_CHANGE</name>
              <description>cphy0_otg_linestate_change detect control
1'b0: disbale
1'b1: enable</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDMMC_CARD_FALL_EDGE</name>
              <description>sdmmc card fall edge detect control
1'b0: disbale
1'b1: enable</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDMMC_CARD_RISE_EDGE</name>
              <description>sdmmc card rise edge detect control
1'b0: disbale
1'b1: enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_SIG_DETECT_CON1</name>
          <description>Singal detect control register1</description>
          <addressOffset>0xe3c8</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HOST0_LLINESTATE_FILTER_TIME_SEL</name>
              <description>filter time select
00: 100us
01: 500us
10: 1ms
11: 10ms</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OTG0_LLINESTATE_FILTER_TIME_SEL</name>
              <description>filter time select
00: 100us
01: 500us
10: 1ms
11: 10ms</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OTG0_ID_FILTER_TIME_SEL</name>
              <description>filter time select
00: 5ms
01: 15ms
10: 35ms
11: 50ms</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_SIG_DETECT_CLR</name>
          <description>Signal detect status clear register</description>
          <addressOffset>0xe3d0</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UPHY1_RXDET_CHANGE</name>
              <description>uphy1_rxdet_change detect control
1'b0: disbale
1'b1: enable</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UPHY0_RXDET_CHANGE</name>
              <description>uphy0_rxdet_change detect control
1'b0: disbale
1'b1: enable</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPHY1_HOST_LINESTATE_CHANGE</name>
              <description>cphy1_host_linestate_change detect control
1'b0: disbale
1'b1: enable</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPHY1_OTG_ID_FALL</name>
              <description>cphy1_otg_id_fall detect control
1'b0: disbale
1'b1: enable</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPHY1_OTG_ID_RISE</name>
              <description>cphy1_otg_id_rise detect control
1'b0: disbale
1'b1: enable</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPHY1_OTG_BVALID_RISE</name>
              <description>cphy1_otg_bvalid_rise detect control
1'b0: disbale
1'b1: enable</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPHY1_OTG_LINESTATE_CHANGE</name>
              <description>cphy1_otg_linestate_change detect control
1'b0: disbale
1'b1: enable</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPHY0_HOST_LINESTATE_CHANGE</name>
              <description>cphy0_host_linestate_change detect control
1'b0: disbale
1'b1: enable</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPHY0_OTG_ID_FALL</name>
              <description>cphy0_otg_id_fall detect control
1'b0: disbale
1'b1: enable</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPHY0_OTG_ID_RISE</name>
              <description>cphy0_otg_id_rise detect control
1'b0: disbale
1'b1: enable</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPHY0_OTG_BVALID_RISE</name>
              <description>cphy0_otg_bvalid_rise detect control
1'b0: disbale
1'b1: enable</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPHY0_OTG_LINESTATE_CHANGE</name>
              <description>cphy0_otg_linestate_change detect control
1'b0: disbale
1'b1: enable</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDMMC_CARD_FALL_EDGE</name>
              <description>sdmmc card fall edge detect control
1'b0: disbale
1'b1: enable</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDMMC_CARD_RISE_EDGE</name>
              <description>sdmmc card rise edge detect control
1'b0: disbale
1'b1: enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_SIG_DETECT_STATUS</name>
          <description>Signal detect status register</description>
          <addressOffset>0xe3e0</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>UPHY1_RXDET_CHANGE</name>
              <description>uphy1_rxdet_change detect    status</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UPHY0_RXDET_CHANGE</name>
              <description>uphy0_rxdet_change detect status</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPHY1_HOST_LINESTATE_CHANGE</name>
              <description>cphy1_host_linestate_change detect    status</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPHY1_OTG_ID_FALL</name>
              <description>cphy1_otg_id_fall detect    status</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPHY1_OTG_ID_RISE</name>
              <description>cphy1_otg_id_rise detect    status</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPHY1_OTG_BVALID_RISE</name>
              <description>cphy1_otg_bvalid_rise detect status</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPHY1_OTG_LINESTATE_CHANGE</name>
              <description>cphy1_otg_linestate_change detect status</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPHY0_HOST_LINESTATE_CHANGE</name>
              <description>cphy0_host_linestate_change detect status</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPHY0_OTG_ID_FALL</name>
              <description>cphy0_otg_id_fall detect    status</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPHY0_OTG_ID_RISE</name>
              <description>cphy0_otg_id_rise detect status</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPHY0_OTG_BVALID_RISE</name>
              <description>cphy0_otg_bvalid_rise detect    status</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPHY0_OTG_LINESTATE_CHANGE</name>
              <description>cphy0_otg_linestate_change detect status</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDMMC_CARD_FALL_EDGE</name>
              <description>sdmmc card fall edge detect    status</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDMMC_CARD_RISE_EDGE</name>
              <description>sdmmc card rise edge detect status
</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_USB20_PHY0_CON0</name>
          <description>USB20 PHY0 GRF Register 0</description>
          <addressOffset>0xe450</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VDM_SRC_EN</name>
              <description>vdm_src_en
1: enable vdm_src for battery charge for
usb3otg0</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VDP_SRC_EN</name>
              <description>vdp_src_en
1:enable vdp_src for battery charge for
usb3otg0</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RDM_PDWN_EN</name>
              <description>rdm_pdwn_en
1: enable rdm_pdwn for battery charge for
usb3otg0</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IDP_SRC_EN</name>
              <description>idp_src_en
1: enable idp_src for battery charge for
usb3otg0</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IDM_SINK_EN</name>
              <description>idm_sink_en
1: enable idm_sink for battery charge for
usb3otg0</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IDP_SINK_EN</name>
              <description>idp_sink_en
1: enable idp_sink for battery charge for
usb3otg0</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OTG_COMMONONN</name>
              <description>otg_commononn
configure pll clock output in suspend mode</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BYPASSSEL</name>
              <description>bypasssel
1: bypass DP/DM as uart sin/sout for
usb3otg0
0: Normal USB function for usb3otg0</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BYPASSDMEN</name>
              <description>bypassdmen
1: enable bypass uart_sout to DM for
usb3otg0
0: disable bypass uart_sout to DM for
usb3otg0</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OTG_DISABLE_1</name>
              <description>otg_disable_1
1:disable otg function of usb20 host0
0:enable otg function of usb20 host0</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OTG_DISABLE_0</name>
              <description>otg_disable_0
1:disable otg function of usb3otg0
0:enable otg function of usb3otg0</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_USB20_PHY0_CON1</name>
          <description>USB20 PHY0 GRF Register 1</description>
          <addressOffset>0xe454</addressOffset>
          <size>32</size>
          <resetValue>0x1452</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[28:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SUSPEND_N_SEL1</name>
              <description>suspend_n_sel1
Pls see suspend_n.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SUSPEND_N_SEL</name>
              <description>suspend_n_sel
Pls see suspend_n.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IDDIG</name>
              <description>iddig
Select the value of this register to usb3otg0
register</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IDDIG_SEL</name>
              <description>iddig_sel
1: select the value of bit10 of
USB20_PHY0_CON1 to usb3otg0 controller
0: select the iddig from usb2phy to usb3otg0
controller</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DMPULLDOWN</name>
              <description>dmpulldown
Select the value of this register to usb2phy
when utmi_sel=1</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPPULLDOWN</name>
              <description>dppulldown
Select the value of this register to usb2phy
when utmi_sel=1</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TERMSELECT</name>
              <description>termselect
Select the value of this register to usb2phy
when utmi_sel=1</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>XCVRSELECT</name>
              <description>xcvrselect
Select the value of this register to usb2phy
when utmi_sel=1</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OPMODE</name>
              <description>opmode
Select the value of this register to usb2phy
when utmi_sel=1</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SUSPEND_N</name>
              <description>suspend_n
utmi_sel=1, select the value of this register to
usb2phy
utmi_sel=0 and bit11 of
USB20_PHY0_CON1=0,    and bit 12 of
USB20_PHY0_CON1=0 select the value of the
value of this bit to usb2phy
utmi_sel=0 and bit11 of
USB20_PHY0_CON1=0,    and bit 12 of
USB20_PHY0_CON1=1 select    suspend_n
signals from usb3otg0 controller to usb2phy
for free running utmi clock
utmi_sel=0 and bit11 of
USB20_PHY0_CON1=1, select
suspend_com_n signals from usb3otg0
controller to usb2phy for not free running utmi
clock</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UTMI_SEL</name>
              <description>utmi_sel
1: select utmi interface signals from GRF
reister to usb2phy
0: select utmi interface signals from utmi
interface of usb3otg0 controller to usb2phy</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_USB20_PHY0_CON2</name>
          <description>USB20 PHY0 GRF Register 2</description>
          <addressOffset>0xe458</addressOffset>
          <size>32</size>
          <resetValue>0x3d2</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IDPULLUP</name>
              <description>idpullup
Use the value of this register input to idpullup
of usb2phy</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DMPULLDOWN</name>
              <description>dmpulldown
Use the value of this register input to
dmpulldown of usb2phy</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPPULLDOWN</name>
              <description>dppulldown
Use the value of this register input to
dppulldown of usb2phy</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TERMSELECT</name>
              <description>termselect
Select the value of this register to usb2phy
when utmi_sel=1</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>XCVRSELECT</name>
              <description>xcvrselect
Select the value of this register to usb2phy
when utmi_sel=1</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OPMODE</name>
              <description>opmode
Select the value of this register to usb2phy
when utmi_sel=1</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SUSPEND_N</name>
              <description>suspend_n
Select the value of this register to usb2phy
when utmi_sel=1</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UTMI_SEL</name>
              <description>utmi_sel
1: select utmi interface signals from GRF
reister to usb2phy
0: select utmi interface signals from utmi
interface of usb20 host0 controller to usb2phy</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_USB20_PHY0_CON3</name>
          <description>USB20 PHY0 GRF Register 3</description>
          <addressOffset>0xe45c</addressOffset>
          <size>32</size>
          <resetValue>0x1</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DISCHRGVBUS</name>
              <description>dischrgvbus
Use the value of this register input to
chrgvbus of usb2phy</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CHRGVBUS</name>
              <description>chrgvbus
Use the value of this register input to
chrgvbus of usb2phy</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DRVVBUS</name>
              <description>drvvbus
Pls see drvvbus_sel.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DRVVBUS_SEL</name>
              <description>drvvbus_sel
1: select the value of bit2 of
USB20_PHY0_CON3 to drvvbus of usb2phy
and GPIO to external PMIC
0: select drvvbus from usb3otg0 controller to
drvvbus of usb2phy and GPIO to external
PMIC</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IDPULLUP</name>
              <description>idpullup
Use the value of this register input to idpullup
of usb2phy</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_USB20_PHY1_CON0</name>
          <description>USB20 PHY1 GRF Register 0</description>
          <addressOffset>0xe460</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VDM_SRC_EN</name>
              <description>vdm_src_en
1: enable vdm_src for battery charge for
usb3otg1</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VDP_SRC_EN</name>
              <description>vdp_src_en
1:enable vdp_src for battery charge for
usb3otg1</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RDM_PDWN_EN</name>
              <description>rdm_pdwn_en
1: enable rdm_pdwn for battery charge for
usb3otg1</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IDP_SRC_EN</name>
              <description>idp_src_en
1: enable idp_src for battery charge for
usb3otg1</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IDM_SINK_EN</name>
              <description>idm_sink_en
1: enable idm_sink for battery charge for
usb3otg1</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IDP_SINK_EN</name>
              <description>idp_sink_en
1: enable idp_sink for battery charge for
usb3otg1</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OTG_COMMONONN</name>
              <description>otg_commononn
configure pll clock output in suspend mode</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BYPASSSEL</name>
              <description>bypasssel
1: bypass DP/DM as uart sin/sout for
usb3otg1
0: Normal USB function for usb3otg1</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BYPASSDMEN</name>
              <description>bypassdmen
1: enable bypass uart_sout to DM for
usb3otg1
0: disable bypass uart_sout to DM for
usb3otg1</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OTG_DISABLE_1</name>
              <description>otg_disable_1
1:disable otg function of usb2 host1
0:enable otg function of usb2 host1</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OTG_DISABLE_0</name>
              <description>otg_disable_0
1:disable otg function of usb3otg1
0:enable otg function of usb3otg1</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_USB20_PHY1_CON1</name>
          <description>USB20 PHY1GRF Register 1</description>
          <addressOffset>0xe464</addressOffset>
          <size>32</size>
          <resetValue>0x1452</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[28:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SUSPEND_N_SEL1</name>
              <description>suspend_n-_sel1
Pls see suspend_n.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SUSPEND_N_SEL</name>
              <description>suspend_n_sel
Pls see suspend_n.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IDDIG</name>
              <description>iddig
Select the value of this register to usb3otg1
register</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IDDIG_SEL</name>
              <description>iddig_sel
1: select the value of bit10 of
USB20_PHY0_CON1 to usb3otg1 controller
0: select the iddig from usb2phy to usb3otg1
controller</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DMPULLDOWN</name>
              <description>dmpulldown
Select the value of this register to usb2phy
when utmi_sel=1</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPPULLDOWN</name>
              <description>dppulldown
Select the value of this register to usb2phy
when utmi_sel=1</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TERMSELECT</name>
              <description>termselect
Select the value of this register to usb2phy
when utmi_sel=1</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>XCVRSELECT</name>
              <description>xcvrselect
Select the value of this register to usb2phy
when utmi_sel=1</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OPMODE</name>
              <description>opmode
Select the value of this register to usb2phy
when utmi_sel=1</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SUSPEND_N</name>
              <description>suspend_n
utmi_sel=1, select the value of this register to
usb2phy
utmi_sel=0 and bit11 of
USB20_PHY0_CON1=0,    and bit 12 of
USB20_PHY0_CON1=0 select the value of the
value of this bit to usb2phy
utmi_sel=0 and bit11 of
USB20_PHY0_CON1=0,    and bit 12 of
USB20_PHY0_CON1=1 select    suspend_n
signals from usb3otg0 controller to usb2phy
for free running utmi clock
utmi_sel=0 and bit11 of
USB20_PHY0_CON1=1, select
suspend_com_n signals from usb3otg0
controller to usb2phy for not free running utmi
clock</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UTMI_SEL</name>
              <description>utmi_sel
1: select utmi interface signals from GRF
reister to usb2phy
0: select utmi interface signals from utmi
interface of usb3otg1 controller to usb2phy</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_USB20_PHY1_CON2</name>
          <description>USB20 PHY1 GRF Register 2</description>
          <addressOffset>0xe468</addressOffset>
          <size>32</size>
          <resetValue>0x3d2</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IDPULLUP</name>
              <description>idpullup
Use the value of this register input to idpullup
of usb2phy</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DMPULLDOWN</name>
              <description>dmpulldown
Use the value of this register input to
dmpulldown of usb2phy</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPPULLDOWN</name>
              <description>dppulldown
Use the value of this register input to
dppulldown of usb2phy</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TERMSELECT</name>
              <description>termselect
Select the value of this register to usb2phy
when utmi_sel=1</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>XCVRSELECT</name>
              <description>xcvrselect
Select the value of this register to usb2phy
when utmi_sel=1</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OPMODE</name>
              <description>opmode
Select the value of this register to usb2phy
when utmi_sel=1</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SUSPEND_N</name>
              <description>suspend_n
Select the value of this register to usb2phy
when utmi_sel=1</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UTMI_SEL</name>
              <description>utmi_sel
1: select utmi interface signals from GRF
reister to usb2phy
0: select utmi interface signals from utmi
interface of usb20 host1 controller to usb2phy</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_USB20_PHY1_CON3</name>
          <description>USB20 PHY1 GRF Register 3</description>
          <addressOffset>0xe46c</addressOffset>
          <size>32</size>
          <resetValue>0x1</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DISCHRGVBUS</name>
              <description>dischrgvbus
Use the value of this register input to
chrgvbus of usb2phy</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CHRGVBUS</name>
              <description>chrgvbus
Use the value of this register input to
chrgvbus of usb2phy</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DRVVBUS</name>
              <description>drvvbus
Pls see drvvbus_sel.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DRVVBUS_SEL</name>
              <description>drvvbus_sel
1: select the value of bit2 of
USB20_PHY1_CON3 to drvvbus of usb2phy
and GPIO to external PMIC
0: select drvvbus from usb3otg1 controller to
drvvbus of usb2phy and GPIO to external
PMIC</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IDPULLUP</name>
              <description>idpullup
Use the value of this register input to idpullup
of usb2phy</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_USB3PHY0_CON0</name>
          <description>TypeC PHY/TCPD PHY/TCPC Control register0</description>
          <addressOffset>0xe580</addressOffset>
          <size>32</size>
          <resetValue>0x99c8</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VBUS_SRC_SEL</name>
              <description>vbus source select to IOMUX
0: select vbus_source_en of TCPC0 to IOMUX
1: select vbus_source_en of TCPC1 to IOMUX
2: select host0_drvvbus, host1_drvvbus,
otg0_drvvbus, otg1_drvvbus to IOMUX</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CC2_OVERCURRENT_N</name>
              <description>cc2 overcurrent
0: cc2 overcurrent
1: cc2 not overcurrent</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CC1_OVERCURRENT_N</name>
              <description>cc1 overcurrent
0: cc1 overcurrent
1: cc1 not overcurrent</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VBUS_VALID_SEL</name>
              <description>vbus valid select
0: use bvalid from usb2phy to usb3 controller
1: usb vbus_valid from TCPC to usb3
controller</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TCPC_VBUS_ON</name>
              <description>TCPC Vbus On
0: disable TCPC vbus supply
1: enable TCPC vbus supply</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TYPEC_CONN_DIR_SEL</name>
              <description>TypeC connect direction select
0: select typec_conn_dir (bit0 of this register)
to TypeC PHY
1: select TCPC ouput typec_con_dir to TypeC
PHY</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEAD_BATTERY_N</name>
              <description>dead_battery_n
1: no dead battery
0: dead battery</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEAD_BATTERY_SEL</name>
              <description>dead_battery_sel
0: select external dead_battery_n from
IOMUX
1: select internal bit7 of this register</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TCPC_ROLE_STRAP</name>
              <description>TCPC role trap
01: TCPC default as DFP
10: TCPC default as UFP
11: TCPC default as DRP</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>USB3TOUSB2_EN</name>
              <description>force usb3 to usb2 enable control
1: force usb3 controller work as usb2.
0: not force usb3 controller work as usb2.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PIPE_DATA_BUS_WIDTH</name>
              <description>Pipe interface data bus width
0: 32bit data bus width, only support 32bit
data bus width.</description>
              <bitRange>[2:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TYPEC_CONN_DIR</name>
              <description>TypeC PHY connect direction
0: normal orientation
1: flip orientation</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_USB3PHY0_CON1</name>
          <description>TypeC PHY/TCPD PHY/TCPC Control register1</description>
          <addressOffset>0xe584</addressOffset>
          <size>32</size>
          <resetValue>0x1000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>JTAG_SELECT</name>
              <description>JTAG_select
0: select TDO of TCPC0 to IOMUX
1: select TDO of TCPC1 to IOMUX</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VBUS_OVERVOLTAGE_N</name>
              <description>vbus overvoltage
0: vbus over voltage
1: vbus not over voltage</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>JTRST</name>
              <description>JTRST
TCPC extensa core JTAG JTRST reset control</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DRESET</name>
              <description>DReset
TCPC extensa core JTAG DReset</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BRRESET</name>
              <description>BRreset
TCPC extensa core JTAG BRreset</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OCDHALTONRESET</name>
              <description>OCDHaltOnReset
TCPC extensa core JTAG OCDHaltOnReset</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TXDETECTRXLOOPBK</name>
              <description>txdetectrxloopbk
pipe_sel=1, select this bit to TypeC PHY</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POWERDOWN</name>
              <description>powerdown
pipe_sel: select this two bit to TypeC PHY</description>
              <bitRange>[4:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TXELECIDLE</name>
              <description>txelecidle
pipe_sel=1, select this bit to TypeC PHY</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RXTERMINATION</name>
              <description>rx termination
pipe_sel=1, select this bit to TypeC PHY</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PIPE_SEL</name>
              <description>pipe interface select
0: select pipe interface from usb3otg
1: select pipe interface from grf controller
register</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_USB3PHY0_CON2</name>
          <description>TypeC PHY/TCPD PHY/TCPC Control register2</description>
          <addressOffset>0xe588</addressOffset>
          <size>32</size>
          <resetValue>0x3cc8</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VBUS_OVERCURRENT_N</name>
              <description>vbus source overcurrent
0: vbus source over current
1: vbus source not over current</description>
              <bitRange>[13:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VBUS_VOLTAGE</name>
              <description>TCPC vbus voltage
TCPC vbus voltage</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_USB3PHY1_CON0</name>
          <description>TypeC PHY/TCPD PHY/TCPC Control register0</description>
          <addressOffset>0xe58c</addressOffset>
          <size>32</size>
          <resetValue>0x19c8</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CC2_OVERCURRENT_N</name>
              <description>cc2 overcurrent
0: cc2 overcurrent
1: cc2 not overcurrent</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CC1_OVERCURRENT_N</name>
              <description>cc1 overcurrent
0: cc1 overcurrent
1: cc1 not overcurrent</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VBUS_VALID_SEL</name>
              <description>vbus valid select
0: use bvalid from usb2phy to usb3 controller
1: usb vbus_valid from TCPC to usb3
controller</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TCPC_VBUS_ON</name>
              <description>TCPC Vbus On
0: disable TCPC vbus supply
1: enable TCPC vbus supply</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TYPEC_CONN_DIR_SEL</name>
              <description>TypeC connect direction select
0: select typec_conn_dir (bit0 of this register)
to TypeC PHY
1: select TCPC ouput typec_con_dir to TypeC
PHY</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEAD_BATTERY_N</name>
              <description>dead_battery_n
1: no dead battery
0: dead battery</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEAD_BATTERY_SEL</name>
              <description>dead_battery_sel
0: select external dead_battery_n from
IOMUX
1: select internal bit7 of this register</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TCPC_ROLE_STRAP</name>
              <description>TCPC role trap
01: TCPC default as DFP
10: TCPC default as UFP
11: TCPC default as DRP</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>USB3TOUSB2_EN</name>
              <description>force usb3 to usb2 enable control
1: force usb3 controller work as usb2.
0: not force usb3 controller work as usb2.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PIPE_DATA_BUS_WIDTH</name>
              <description>Pipe interface data bus width
0: 32bit data bus width, only support 32bit
data bus width.</description>
              <bitRange>[2:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TYPEC_CONN_DIR</name>
              <description>TypeC PHY connect direction
0: normal orientation
1: flip orientation</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_USB3PHY1_CON1</name>
          <description>TypeC PHY/TCPD PHY/TCPC Control register1</description>
          <addressOffset>0xe590</addressOffset>
          <size>32</size>
          <resetValue>0x1000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VBUS_OVERVOLTAGE_N</name>
              <description>vbus overvoltage
0: vbus over voltage
1: vbus not over voltage</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>JTRST</name>
              <description>JTRST
TCPC extensa core JTAG JTRST reset control</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DRESET</name>
              <description>DReset
TCPC extensa core JTAG DReset</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BRRESET</name>
              <description>BRreset
TCPC extensa core JTAG BRreset</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OCDHALTONRESET</name>
              <description>OCDHaltOnReset
TCPC extensa core JTAG OCDHaltOnReset</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TXDETECTRXLOOPBK</name>
              <description>txdetectrxloopbk
pipe_sel=1, select this bit to TypeC PHY</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POWERDOWN</name>
              <description>powerdown
pipe_sel: select this two bit to TypeC PHY</description>
              <bitRange>[4:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TXELECIDLE</name>
              <description>txelecidle
pipe_sel=1, select this bit to TypeC PHY</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RXTERMINATION</name>
              <description>rx termination
pipe_sel=1, select this bit to TypeC PHY</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PIPE_SEL</name>
              <description>pipe interface select
0: select pipe interface from usb3otg
1: select pipe interface from grf controller
register</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_USB3PHY1_CON2</name>
          <description>TypeC PHY/TCPD PHY/TCPC Control register2</description>
          <addressOffset>0xe594</addressOffset>
          <size>32</size>
          <resetValue>0x3cc8</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VBUS_OVERCURRENT_N</name>
              <description>vbus source overcurrent
0: vbus source over current
1: vbus source not over current</description>
              <bitRange>[13:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VBUS_VOLTAGE</name>
              <description>TCPC vbus voltage
TCPC vbus voltage</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_USB3PHY_STATUS0</name>
          <description>USB3PHY_STATUS0</description>
          <addressOffset>0xe5c0</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TCPC1_VBUS_SOURCE_EN</name>
              <description>TCPC1_vbus_source_en
1: select corresponding vbus source</description>
              <bitRange>[28:25]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TCPC1_SINK_EN</name>
              <description>TCPC1_sink_en
1: TCPC1 enable to sink vbus</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TCPC1_BDIS_EN</name>
              <description>TCPC1_bdis_en
1: TCPC1 bleed discharge enable</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TCPC1_FDIS_EN</name>
              <description>TCPC1_fdis_en
1: TCPC1 force discharge enable</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TCPC1_VCONN_TO_CC2</name>
              <description>TCPC1 supply VCONN to CC2
1: TCPC1 supply VCONN to CC2</description>
              <bitRange>[21:21]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TCPC1_VCONN_TO_CC1</name>
              <description>TCPC1 vconn supply to CC1
1: support voconn to CC1</description>
              <bitRange>[20:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TCPC1_VBUS_OVERCURRENT</name>
              <description>TCPC1 vbus overcurrent ouput
1: vbus over current</description>
              <bitRange>[19:19]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TCPC1_JTAG_XOCDMODE</name>
              <description>TCPC1 JTAG XOCDMode
</description>
              <bitRange>[18:18]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TYPEC_PD_PHY1_READY</name>
              <description>TypeC PD PHY 1 ready
1: TypeC PD PHY ready</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TYPEC_PHY1_PIPE_STATUS</name>
              <description>TypeC PHY 0 pipe status
0: indicate TypeC PHY pipe ready after release
TypeC PHY pipe reset.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TCPC0_VBUS_SOURCE_EN</name>
              <description>TCPC0_vbus_source_en
1: select corresponding vbus source</description>
              <bitRange>[12:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TCPC0_SINK_EN</name>
              <description>TCPC0_sink_en
1: TCPC0 enable to sink vbus</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TCPC0_BDIS_EN</name>
              <description>TCPC0_bdis_en
1: TCPC0 bleed discharge enable</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TCPC0_FDIS_EN</name>
              <description>TCPC0_fdis_en
1: TCPC0 force discharge enable</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TCPC0_VCONN_TO_CC2</name>
              <description>TCPC0 supply VCONN to CC2
1: TCPC0 supply VCONN to CC2</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TCPC0_VCONN_TO_CC1</name>
              <description>TCPC0 vconn supply to CC1
1: support voconn to CC1</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TCPC0_VBUS_OVERCURRENT</name>
              <description>TCPC0 vbus overcurrent ouput
1: vbus over current</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TCPC0_JTAG_XOCDMODE</name>
              <description>TCPC0 JTAG XOCDMode
</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TYPEC_PD_PHY0_READY</name>
              <description>TypeC PD PHY 0 ready
1: TypeC PD PHY ready</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TYPEC_PHY0_PIPE_STATUS</name>
              <description>TypeC PHY 0 pipe status
0: indicate TypeC PHY pipe ready after release
TypeC PHY pipe reset.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_USB3PHY_STATUS1</name>
          <description>USB3PHY_STATUS1</description>
          <addressOffset>0xe5c4</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CC_DEAD_BATTERY_N</name>
              <description>CC dead battery indicator from IOMUX
0: dead battery happen
1: No dead battery happen</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TCPC1_VBUS_OVERCURRENT_EN</name>
              <description>TCPC vbus over current enable
1: enable</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TCPC1_VCONN_OVERCURRENT_EN</name>
              <description>TCPC vconn overcurrent enable
1: enable</description>
              <bitRange>[26:26]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TCPC1_VBUS_VOLTAGE_EN</name>
              <description>TCPC vbus voltage enable
1: enable</description>
              <bitRange>[25:25]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TCPC1_VBUS_OVERVOLTAGE_EN</name>
              <description>TCPC vbus overvoltage enable
1: enable</description>
              <bitRange>[24:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TCPC1_OUTS_TO_HIZ</name>
              <description>TCPC outs to hiz
</description>
              <bitRange>[23:23]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TCPC1_DBG_ACC_CONN_N</name>
              <description>TCPC debug accessory connect
0: Debug accessory connected
1: No debug accessory connected</description>
              <bitRange>[22:22]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TCPC1_AUDIO_ACC_CONN_N</name>
              <description>TCPC audio accessory connect
0: audio accessory connected
1: No audio accessory connected</description>
              <bitRange>[21:21]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TCPC1_ACT_CABLE_CONN_N</name>
              <description>TCPC active cable connect
0: No connected
1: Active cable connected</description>
              <bitRange>[20:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TCPC1_MUX_CTRL</name>
              <description>TCPC MUX CTRL
0: No connect
1: USB3.1 connect
2: DP 4 lanes
3: USB3.1 and DP 2 lanes</description>
              <bitRange>[19:18]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TCPC1_CONN_PRESENT</name>
              <description>TCPC connect present
0: No connect
1: Connected</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TCPC1_CONN_ORIENTATION</name>
              <description>TCPC connect orientation
0: normal
1: flip</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TCPC0_VBUS_OVERCURRENT_EN</name>
              <description>TCPC vbus over current enable
1: enable</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TCPC0_VCONN_OVERCURRENT_EN</name>
              <description>TCPC vconn overcurrent enable
1: enable</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TCPC0_VBUS_VOLTAGE_EN</name>
              <description>TCPC vbus voltage enable
1: enable</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TCPC0_VBUS_OVERVOLTAGE_EN</name>
              <description>TCPC vbus overvoltage enable
1: enable</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TCPC0_OUTS_TO_HIZ</name>
              <description>TCPC outs to hiz
</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TCPC0_DBG_ACC_CONN_N</name>
              <description>TCPC debug accessory connect
0: Debug accessory connected
1: No debug accessory connected</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TCPC0_AUDIO_ACC_CONN_N</name>
              <description>TCPC audio accessory connect
0: audio accessory connected
1: No audio accessory connected</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TCPC0_ACT_CABLE_CONN_N</name>
              <description>TCPC active cable connect
0: No connected
1: Active cable connected</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TCPC0_MUX_CTRL</name>
              <description>TCPC MUX CTRL
0: No connect
1: USB3.1 connect
2: DP 4 lanes
3: USB3.1 and DP 2 lanes</description>
              <bitRange>[3:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TCPC0_CONN_PRESENT</name>
              <description>TCPC connect present
0: No connect
1: Connected</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TCPC0_CONN_ORIENTATION</name>
              <description>TCPC connect orientation
0: normal
1: flip</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_DLL_CON0</name>
          <description>pvtm control register</description>
          <addressOffset>0xe600</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PVTM_GPU_OSC_RING_SEL</name>
              <description>gpu PVT monitor oscilator ring select</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PVTM_GPU_OSC_EN</name>
              <description>gpu PVT monitor oscilator enable
1'b1: enable
1'b0: disable</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PVTM_GPU_START</name>
              <description>gpu PVT monitor start control</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PVTM_DDR_OSC_RING_SEL</name>
              <description>ddr PVT monitor oscilator ring select</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PVTM_DDR_OSC_EN</name>
              <description>ddr PVT monitor oscilator enable
1'b1: enable
1'b0: disable</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PVTM_DDR_START</name>
              <description>ddr PVT monitor start control</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PVTM_CORE_B_OSC_SEL</name>
              <description>pd_core_l PVT monitor oscilator select
pvtm_core_b_osc_sel[1:0]</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PVTM_CORE_B_OSC_EN</name>
              <description>pd_core_b PVT monitor oscilator enable
1'b1: enable
1'b0: disable</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PVTM_CORE_B_START</name>
              <description>pd_core_b PVT monitor start control</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PVTM_CORE_L_OSC_SEL</name>
              <description>pd_core_l PVT monitor oscilator select</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PVTM_CORE_L_OSC_EN</name>
              <description>pd_core_l PVT monitor oscilator enable
1'b1: enable
1'b0: disable</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PVTM_CORE_L_START</name>
              <description>pd_core_l PVT monitor start control</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_DLL_CON1</name>
          <description>pvtm control register</description>
          <addressOffset>0xe604</addressOffset>
          <size>32</size>
          <resetValue>0x16e3600</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PVTM_CORE_L_CAL_CNT</name>
              <description>pd_core_l pvtm calculator counter</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_DLL_CON2</name>
          <description>pvtm control register</description>
          <addressOffset>0xe608</addressOffset>
          <size>32</size>
          <resetValue>0x16e3600</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PVTM_CORE_B_CAL_CNT</name>
              <description>pd_core_b pvtm calculator counter</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_DLL_CON3</name>
          <description>pvtm control register</description>
          <addressOffset>0xe60c</addressOffset>
          <size>32</size>
          <resetValue>0x16e3600</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PVTM_DDR_CAL_CNT</name>
              <description>ddr pvtm calculator counter</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_DLL_CON4</name>
          <description>pvtm control register</description>
          <addressOffset>0xe610</addressOffset>
          <size>32</size>
          <resetValue>0x16e3600</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PVTM_GPU_CAL_CNT</name>
              <description>gpu pvtm calculator counter</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_DLL_CON5</name>
          <description>pvtm control register</description>
          <addressOffset>0xe614</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PVTM_CORE_B_OSC_SEL</name>
              <description>pvtm_core_b_osc_sel[2]</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_DLL_STATUS0</name>
          <description>pvtm status register</description>
          <addressOffset>0xe620</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PVTM_DDR_FREQ_DONE</name>
              <description>ddr pvtm frequency calculate done stutus</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PVTM_GPU_FREQ_DONE</name>
              <description>gpu pvtm frequency calculate done stutus</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PVTM_CORE_B_FREQ_DONE</name>
              <description>pd_core_b pvtm frequency calculate done
stutus</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PVTM_CORE_L_FREQ_DONE</name>
              <description>pd_core_l pvtm frequency calculate done
stutus</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_DLL_STATUS1</name>
          <description>pvtm status register</description>
          <addressOffset>0xe624</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PVTM_CORE_L_FREQ_CNT</name>
              <description>pd_core_l pvtm frequency count</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_DLL_STATUS2</name>
          <description>pvtm status register</description>
          <addressOffset>0xe628</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PVTM_CORE_B_FREQ_CNT</name>
              <description>pd_core_b pvtm frequency count</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_DLL_STATUS3</name>
          <description>pvtm status register</description>
          <addressOffset>0xe62c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PVTM_GPU_FREQ_CNT</name>
              <description>gpu pvtm frequency count</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_DLL_STATUS4</name>
          <description>pvtm status register</description>
          <addressOffset>0xe630</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PVTM_DDR_FREQ_CNT</name>
              <description>ddr pvtm frequency count</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_IO_VSEL</name>
          <description>GRF_IO_VSEL</description>
          <addressOffset>0xe640</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO1833_GPIO4CD_MS</name>
              <description>gpio1833_gpio4cd_ms
</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDMMC_GPIO4B_MS</name>
              <description>sdmmc_gpio4b_ms
</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AUDIO_GPIO3D4A_MS</name>
              <description>audio_gpio3d4a_ms
</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BT656_GPIO2AB_MS</name>
              <description>bt656_gpio2ab_ms
</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_SARADC_TESTBIT</name>
          <description>saradc test bit control register</description>
          <addressOffset>0xe644</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SARADC_TESTBIT</name>
              <description>saradc test bit control</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_TSADC_TESTBIT_L</name>
          <description>saradc test bit control register</description>
          <addressOffset>0xe648</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GRF_TSADC_DIG_BYPASS</name>
              <description>grf_tsadc_dig_bypass
</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GRF_TSADC_CLK_SEL</name>
              <description>grf_tsadc_clk_sel
</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GRF_TSADC_TSEN_PD_1</name>
              <description>grf_tsadc_tsen_pd_1
</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GRF_TSADC_TSEN_PD_0</name>
              <description>grf_tsadc_tsen_pd_0
</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_TSADC_TESTBIT_H</name>
          <description>tsadc test bit control register</description>
          <addressOffset>0xe64c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TSADC_TESTBIT_H</name>
              <description>tsadc test bit control</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_CHIP_ID_ADDR</name>
          <description>chip id register</description>
          <addressOffset>0xe800</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CHIP_ID</name>
              <description>3399</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_FAST_BOOT_ADDR</name>
          <description>faster boot address register</description>
          <addressOffset>0xe880</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FAST_BOOT_ADDR</name>
              <description>fast boot address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_EMMCCORE_CON0</name>
          <description>emmc core control register</description>
          <addressOffset>0xf000</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMMCCORE_CON0</name>
              <description>emmc controller control register 0</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_EMMCCORE_CON1</name>
          <description>emmc core control register</description>
          <addressOffset>0xf004</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMMCCORE_CON1</name>
              <description>emmc controller control register 1</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_EMMCCORE_CON2</name>
          <description>emmc core control register</description>
          <addressOffset>0xf008</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMMCCORE_CON2</name>
              <description>emmc controller control register 2</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_EMMCCORE_CON3</name>
          <description>emmc core control register</description>
          <addressOffset>0xf00c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMMCCORE_CON3</name>
              <description>emmc controller control register 3</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_EMMCCORE_CON4</name>
          <description>emmc core control register</description>
          <addressOffset>0xf010</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMMCCORE_CON4</name>
              <description>emmc controller control register 4</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_EMMCCORE_CON5</name>
          <description>emmc core control register</description>
          <addressOffset>0xf014</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMMCCORE_CON5</name>
              <description>emmc controller control register 5</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_EMMCCORE_CON6</name>
          <description>emmc core control register</description>
          <addressOffset>0xf018</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMMCCORE_CON6</name>
              <description>emmc controller control register 6</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_EMMCCORE_CON7</name>
          <description>emmc core control register</description>
          <addressOffset>0xf01c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMMCCORE_CON7</name>
              <description>emmc controller control register 7</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_EMMCCORE_CON8</name>
          <description>emmc core control register</description>
          <addressOffset>0xf020</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMMCCORE_CON8</name>
              <description>emmc controller control register 8</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_EMMCCORE_CON9</name>
          <description>emmc core control register</description>
          <addressOffset>0xf024</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMMCCORE_CON9</name>
              <description>emmc controller control register 9</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_EMMCCORE_CON10</name>
          <description>emmc core control register</description>
          <addressOffset>0xf028</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMMCCORE_CON10</name>
              <description>emmc controller control register 10</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_EMMCCORE_CON11</name>
          <description>emmc core control register</description>
          <addressOffset>0xf02c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMMCCORE_CON11</name>
              <description>emmc controller control register 11</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_EMMCCORE_STATUS0</name>
          <description>emmc core status register</description>
          <addressOffset>0xf040</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EMMCCORE_STATUS0</name>
              <description>emmc controller status register 0</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_EMMCCORE_STATUS1</name>
          <description>emmc core status register</description>
          <addressOffset>0xf044</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EMMCCORE_STATUS1</name>
              <description>emmc controller status register 1</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_EMMCCORE_STATUS2</name>
          <description>emmc core status register</description>
          <addressOffset>0xf048</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EMMCCORE_STATUS2</name>
              <description>emmc controller status register 2</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_EMMCCORE_STATUS3</name>
          <description>emmc core status register</description>
          <addressOffset>0xf04c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EMMCCORE_STATUS3</name>
              <description>emmc controller status register 3</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_EMMCPHY_CON0</name>
          <description>emmc phy control register</description>
          <addressOffset>0xf780</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMMCPHY_CON0</name>
              <description>emmc phy control register 0</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_EMMCPHY_CON1</name>
          <description>emmc phy control register</description>
          <addressOffset>0xf784</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMMCPHY_CON1</name>
              <description>emmc phy control register 1</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_EMMCPHY_CON2</name>
          <description>emmc phy control register</description>
          <addressOffset>0xf788</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMMCPHY_CON2</name>
              <description>emmc phy control register 2</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_EMMCPHY_CON3</name>
          <description>emmc phy control register</description>
          <addressOffset>0xf78c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMMCPHY_CON3</name>
              <description>emmc phy control register 3</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_EMMCPHY_CON4</name>
          <description>emmc phy control register</description>
          <addressOffset>0xf790</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMMCPHY_CON4</name>
              <description>emmc phy control register 4</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_EMMCPHY_CON5</name>
          <description>emmc phy control register</description>
          <addressOffset>0xf794</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMMCPHY_CON5</name>
              <description>emmc phy control register 5</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_EMMCPHY_CON6</name>
          <description>emmc phy control register</description>
          <addressOffset>0xf798</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EMMCPHY_CON6</name>
              <description>emmc phy control register 5</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRF_EMMCPHY_STATUS</name>
          <description>emmc phy status register</description>
          <addressOffset>0xf7a0</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EMMCPHY_STATUS</name>
              <description>emmc phy status register</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>MSCH0</name>
      <version>1.0</version>
      <groupname>MSCH</groupname>
      <baseAddress>0xffa84000</baseAddress>
      <registers>
        <register>
          <name>MSCH_Id_CoreId</name>
          <description>Core ID register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0xd867004</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>MSCH_Id_RevisionId</name>
          <description>Revision ID register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x1aa00</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>MSCH_DeviceConf</name>
          <description>ddr configuration pointers</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>MSCH_DeviceSize</name>
          <description>ddr configuration sizes.</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>MSCH_DdrTimingA0</name>
          <description>DdrTimingA bank 0</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x28140916</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>MSCH_DdrTimingB0</name>
          <description>DdrTimingB bank 0</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x40702</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>MSCH_DdrTimingC0</name>
          <description>DdrTimingC bank 0</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x2</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>MSCH_DevToDev0</name>
          <description>Timing values concerning device to device data bus ownership c</description>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <resetValue>0x222</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>MSCH_DdrMode</name>
          <description>ddr mode definition.</description>
          <addressOffset>0x110</addressOffset>
          <size>32</size>
          <resetValue>0x4c</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>MSCH_AgingX0</name>
          <description>Aging threshold multiplicator.</description>
          <addressOffset>0x1000</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="MSCH0">
      <name>MSCH1</name>
      <version>1.0</version>
      <groupname>MSCH</groupname>
      <baseAddress>0xffa8c000</baseAddress>
    </peripheral>
    <peripheral>
      <name>PMUGRF</name>
      <version>1.0</version>
      <groupname>PMUGRF</groupname>
      <baseAddress>0xff320000</baseAddress>
      <registers>
        <register>
          <name>PMUGRF_GPIO0A_IOMUX</name>
          <description>GPIO0A iomux control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO0A7_SEL</name>
              <description>GPIO0A[7] iomux select
2'b00: gpio
2'b01: sdmmc_dectn
2'b10: pmu_debug5
2'b11: reserved</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO0A6_SEL</name>
              <description>GPIO0A[6] iomux select
2'b00: gpio
2'b01: pwm_3a
2'b10: pmu_debug4
2'b11: reserved</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO0A5_SEL</name>
              <description>GPIO0A[5] iomux select
2'b00: gpio
2'b01: emmc_pwren
2'b10: pmu_debug3
2'b11: reserved</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO0A4_SEL</name>
              <description>GPIO0A[4] iomux select
2'b00: gpio
2'b01: sdio_intn
2'b10: pmu_debug2
2'b11: reserved</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO0A3_SEL</name>
              <description>GPIO0A[3] iomux select
2'b00: gpio
2'b01: sdio_wrprt
2'b10: pmu_debug1
2'b11: reserved</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO0A2_SEL</name>
              <description>GPIO0A[2] iomux select
2'b00: gpio
2'b01: wifi_26m
2'b10: pmu_debug0
2'b11: reserved</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO0A1_SEL</name>
              <description>GPIO0A[1] iomux select
2'b00: gpio
2'b01: ddrio_pwroff
2'b10: tcpd_ccdben
2'b11: reserved</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO0A0_SEL</name>
              <description>GPIO0A[0] iomux select
2'b00: gpio
2'b01: test_clkout0
2'b10: clk_32k
2'b11: reserved</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMUGRF_GPIO0B_IOMUX</name>
          <description>GPIO0B iomux control</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x14</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO0B5_SEL</name>
              <description>GPIO0B[5] iomux select
2'b00: gpio
2'b01: tcpd_vbusfdis
2'b10: tcpdusb2_vbussource3
2'b11: reserved</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO0B4_SEL</name>
              <description>GPIO0B4] iomux select
2'b00: gpio
2'b01: tcpd_vbusbdis
2'b10: reserved
2'b11: reserved</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO0B3_SEL</name>
              <description>GPIO0B[3] iomux select
2'b00: gpio
2'b01: reserved
2'b10: reserved
2'b11: reserved</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO0B2_SEL</name>
              <description>GPIO0B[2] iomux select
2'b00: gpio
2'b01: reserved
2'b10: reserved
2'b11: reserved</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO0B1_SEL</name>
              <description>GPIO0B[1] iomux select
2'b00: gpio
2'b01: pmu1830_volsel
2'b10: reserved
2'b11: reserved</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO0B0_SEL</name>
              <description>GPIO0B[0] iomux select
2'b00: gpio
2'b01: sdmmc_wrprt
2'b10: pmum0_wfi
2'b11: test_clkout2</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMUGRF_GPIO1A_IOMUX</name>
          <description>GPIO1A iomux control</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO1A7_SEL</name>
              <description>GPIO1A[7] iomux select
2'b00: gpio
2'b01: uart4m0_sin
2'b10: spi1ec_rxd
2'b11: reserved</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO1A6_SEL</name>
              <description>GPIO1A[6] iomux select
2'b00: gpio
2'b01: tsadc_int
2'b10: reserved
2'b11: reserved</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO1A5_SEL</name>
              <description>GPIO1A[5] iomux select
2'b00: gpio
2'b01: ap_pwroff
2'b10: reserved
2'b11: reserved</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO1A4_SEL</name>
              <description>GPIO1A[4] iomux select
2'b00: gpio
2'b01: isp0_prelighttrig
2'b10: isp1_prelighttrig
2'b11: reserved</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO1A3_SEL</name>
              <description>GPIO1A[3] iomux select
2'b00: gpio
2'b01: isp0_flashtrigout
2'b10: isp1_flashtrigout
2'b11: reserved</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO1A2_SEL</name>
              <description>GPIO1A[2] iomux select
2'b00: gpio
2'b01: isp0_flashtrigin
2'b10: isp1_flashtrigin
2'b11: tcpd_cc1vconn
</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO1A1_SEL</name>
              <description>GPIO1A[1] iomux select
2'b00: gpio
2'b01: isp0_shuttertrig
2'b10: isp1_shuttertrig
2'b11: tcpd_cc0vconn</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO1A0_SEL</name>
              <description>GPIO1A[0] iomux select
2'b00: gpio
2'b01: isp0_shutteren
2'b10: isp1_shutteren
2'b11: tcpd_vbussink</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMUGRF_GPIO1B_IOMUX</name>
          <description>GPIO1B iomux control</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>GPIO1B7_SEL</name>
              <description>GPIO1B[7] iomux select
2'b00: gpio
2'b01: spi3pmu_rxd
2'b10: i2c0pmu_scl
2'b11: reserved</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO1B6_SEL</name>
              <description>GPIO1B[6] iomux select
2'b00: gpio
2'b01: pwm_3b
2'b10: reserved
2'b11: reserved</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO1B5_SEL</name>
              <description>GPIO1B[5] iomux select
2'b00: gpio
2'b01: reserved
2'b10: reserved
2'b11: reserved</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO1B4_SEL</name>
              <description>GPIO1B[4] iomux select
2'b00: gpio
2'b01: i2c4sensor_scl
2'b10: reserved
2'b11: reserved</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO1B3_SEL</name>
              <description>GPIO1B[3] iomux select
2'b00: gpio
2'b01: i2c4sensor_sda
2'b10: reserved
2'b11: reserved</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO1B2_SEL</name>
              <description>GPIO1B[2] iomux select
2'b00: gpio
2'b01: pmum0jtag_tms
2'b10: spi1ec_csn0
2'b11: reserved</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO1B1_SEL</name>
              <description>GPIO1B[1] iomux select
2'b00: gpio
2'b01: pmum0jtag_tck
2'b10: spi1ec_clk
2'b11: reserved</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO1B0_SEL</name>
              <description>GPIO1B[0] iomux select
2'b00: gpio
2'b01: uart4m0_sout
2'b10: spi1ec_txd
2'b11: reserved</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMUGRF_GPIO1C_IOMUX</name>
          <description>GPIO1C iomux control</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>GPIO1C7_SEL</name>
              <description>GPIO1C[7] iomux select
2'b00: gpio
2'b01: tcpdusb2_vbussource1
2'b10: reserved
2'b11: reserved</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO1C6_SEL</name>
              <description>GPIO1C[6] iomux select
2'b00: gpio
2'b01: tcpdusb2_vbussource0
2'b10: reserved
2'b11: reserved</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO1C5_SEL</name>
              <description>GPIO1C[5] iomux select
2'b00: gpio
2'b01: i2c8dcdc_scl
2'b10: reserved
2'b11: reserved</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO1C4_SEL</name>
              <description>GPIO1C[4] iomux select
2'b00: gpio
2'b01: i2c8dcdc_sda
2'b10: reserved
2'b11: reserved</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO1C3_SEL</name>
              <description>GPIO1C[3] iomux select
2'b00: gpio
2'b01: pwm_2
2'b10: reserved
2'b11: reserved</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO1C2_SEL</name>
              <description>GPIO1C[2] iomux select
2'b00: gpio
2'b01: spi3pmu_csn0
2'b10: reserved
2'b11: reserved</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO1C1_SEL</name>
              <description>GPIO1C[1] iomux select
2'b00: gpio
2'b01: spi3pmu_clk
2'b10: reserved
2'b11: reserved</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO1C0_SEL</name>
              <description>GPIO1C[0] iomux select
2'b00: gpio
2'b01: spi3pmu_txd
2'b10: i2c0pmu_scl
2'b11: reserved</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMUGRF_GPIO1D_IOMUX</name>
          <description>GPIO1D iomux control</description>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>GPIO1D0_SEL</name>
              <description>GPIO1D[0] iomux select
2'b00: gpio
2'b01: tcpdusb2_vbussource2
2'b10: reserved
2'b11: reserved</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMUGRF_GPIO0A_P</name>
          <description>GPIO0A PU/PD control</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <resetValue>0xdd5f</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>GPIO0A_P</name>
              <description>GPIO0A PE/PS programmation section, every
GPIO bit corresponding to 2bits[PS:PE]
2'b00: Z(Noraml operaton);
2'b11: weak 1(pull-up);
2'b01: weak 0(pull-down);
2'b10: Z(Noraml operaton);</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMUGRF_GPIO0B_P</name>
          <description>GPIO0B PU/PD control</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <resetValue>0x557</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>GPIO0B_P</name>
              <description>GPIO0A PE/PS programmation section, every
GPIO bit corresponding to 2bits[PS:PE]
2'b00: Z(Noraml operaton);
2'b11: weak 1(pull-up);
2'b01: weak 0(pull-down);
2'b10: Z(Noraml operaton);</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMUGRF_GPIO1A_P</name>
          <description>GPIO1A PU/PD control</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <resetValue>0x6aaa</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>GPIO1A_P</name>
              <description>GPIO1A PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMUGRF_GPIO1B_P</name>
          <description>GPIO1B PU/PD control</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <resetValue>0x6955</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>GPIO1B_P</name>
              <description>GPIO1B PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMUGRF_GPIO1C_P</name>
          <description>GPIO1C PU/PD control</description>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <resetValue>0xa599</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>GPIO1C_P</name>
              <description>GPIO1C PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMUGRF_GPIO1D_P</name>
          <description>GPIO0D PU/PD control</description>
          <addressOffset>0x5c</addressOffset>
          <size>32</size>
          <resetValue>0x2</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>GPIO1D_P</name>
              <description>GPIO1D PU/PD programmation section, every
GPIO bit corresponding to 2bits
2'b00: Z(Noraml operaton);
2'b01: weak 1(pull-up);
2'b10: weak 0(pull-down);
2'b11: Repeater(Bus keeper)</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMUGRF_GPIO0A_E</name>
          <description>GPIO0A drive strength control</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>GPIO0A_E</name>
              <description>GPIO0A drive strength control, every GPIO bit
corresponding to 2bits
2'b00: 2mA
2'b01: 4mA
2'b10: 8mA
2'b11: 12mA</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMUGRF_GPIO0B_E</name>
          <description>GPIO0D drive strength control</description>
          <addressOffset>0x88</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>GPIO0B_E</name>
              <description>GPIO0B drive strength control, every GPIO bit
corresponding to 2bits
2'b00: 2mA
2'b01: 4mA
2'b10: 8mA
2'b11: 12mA</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMUGRF_GPIO1A_E</name>
          <description>GPIO1A drive strength control</description>
          <addressOffset>0xa0</addressOffset>
          <size>32</size>
          <resetValue>0x4000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>GPIO1A_E</name>
              <description>GPIO1A drive strength control, every GPIO bit
corresponding to 2bits
2'b00: 2mA
2'b01: 4mA
2'b10: 8mA
2'b11: 12mA</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMUGRF_GPIO1B_E</name>
          <description>GPIO1D drive strength control</description>
          <addressOffset>0xa8</addressOffset>
          <size>32</size>
          <resetValue>0x15</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>GPIO1B_E</name>
              <description>GPIO1B drive strength control, every GPIO bit
corresponding to 2bits
2'b00: 2mA
2'b01: 4mA
2'b10: 8mA
2'b11: 12mA</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMUGRF_GPIO1C_E</name>
          <description>GPIO1C drive strength control</description>
          <addressOffset>0xb0</addressOffset>
          <size>32</size>
          <resetValue>0x5000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>GPIO1C_E</name>
              <description>GPIO1C drive strength control, every GPIO bit
corresponding to 2bits
2'b00: 2mA
2'b01: 4mA
2'b10: 8mA
2'b11: 12mA</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMUGRF_GPIO1D_E</name>
          <description>GPIO1D drive strength control</description>
          <addressOffset>0xb8</addressOffset>
          <size>32</size>
          <resetValue>0x1</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>GPIO1D_E</name>
              <description>GPIO1D drive strength control, every GPIO bit
corresponding to 2bits
2'b00: 2mA
2'b01: 4mA
2'b10: 8mA
2'b11: 12mA</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMUGRF_GPIO0L_SR</name>
          <description>GPIO0 A/B SR control</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>GPIO0B_SR</name>
              <description>GPIO0B slew rate control for each bit
1'b0: slow (half frequency)
1'b1: fast</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO0A_SR</name>
              <description>GPIO0A slew rate control for each bit
1'b0: slow (half frequency)
1'b1: fast</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMUGRF_GPIO1L_SR</name>
          <description>GPIO1 A/B SR control</description>
          <addressOffset>0x108</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>GPIO1B_SR</name>
              <description>GPIO1B slew rate control for each bit
1'b0: slow (half frequency)
1'b1: fast</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO1A_SR</name>
              <description>GPIO1A slew rate control for each bit
1'b0: slow (half frequency)
1'b1: fast</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMUGRF_GPIO1H_SR</name>
          <description>GPIO1C/D SR control</description>
          <addressOffset>0x10c</addressOffset>
          <size>32</size>
          <resetValue>0xf</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>GPIO0D_SR</name>
              <description>GPIO0D slew rate control for each bit
1'b0: slow (half frequency)
1'b1: fast</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO1C_SR</name>
              <description>GPIO1C slew rate control for each bit
1'b0: slow (half frequency)
1'b1: fast</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMUGRF_GPIO0A_SMT</name>
          <description>GPIO0A smit control</description>
          <addressOffset>0x120</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>GPIO0A_SMT</name>
              <description>GPIO0A drive strength control, every GPIO bit
corresponding to 2bits
2'b00: smit disable
2'b01: smit enable
2'b10: reserved
2'b11: reserved</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMUGRF_GPIO0B_SMT</name>
          <description>GPIO0B smit control</description>
          <addressOffset>0x124</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>GPIO0B_SMT</name>
              <description>GPIO0B drive strength control, every GPIO bit
corresponding to 2bits
2'b00: smit disable
2'b01: smit enable
2'b10: reserved
2'b11: reserved</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMUGRF_GPIO1A_SMT</name>
          <description>GPIO1A smit control</description>
          <addressOffset>0x130</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>GPIO1A_SMT</name>
              <description>GPIO1A drive strength control, every GPIO bit
corresponding to 2bits
2'b00: smit disable
2'b01: smit enable
2'b10: reserved
2'b11: reserved</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMUGRF_GPIO1B_SMT</name>
          <description>GPIO1B smit control</description>
          <addressOffset>0x134</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>GPIO1B_SMT</name>
              <description>GPIO1B drive strength control, every GPIO bit
corresponding to 2bits
2'b00: smit disable
2'b01: smit enable
2'b10: reserved
2'b11: reserved</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMUGRF_GPIO1C_SMT</name>
          <description>GPIO1C smit control</description>
          <addressOffset>0x138</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>GPIO1C_SMT</name>
              <description>GPIO1C drive strength control, every GPIO bit
corresponding to 2bits
2'b00: smit disable
2'b01: smit enable
2'b10: reserved
2'b11: reserved</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMUGRF_GPIO1D_SMT</name>
          <description>GPIO1D smit control</description>
          <addressOffset>0x13c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>GPIO1D_SMT</name>
              <description>GPIO1D drive strength control, every GPIO bit
corresponding to 2bits
2'b00: smit disable
2'b01: smit enable
2'b10: reserved
2'b11: reserved</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMUGRF_GPIO0L_HE</name>
          <description>GPIO0 A/B HE control</description>
          <addressOffset>0x160</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>GPIO0B_SR</name>
              <description>GPIO0B slew rate control for each bit
1'b0: slow (half frequency)
1'b1: fast</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO0A_SR</name>
              <description>GPIO0A slew rate control for each bit
1'b0: slow (half frequency)
1'b1: fast</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMUGRF_GPIO1L_HE</name>
          <description>GPIO1 A/B HE control</description>
          <addressOffset>0x168</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>GPIO0B_SR</name>
              <description>GPIO0B slew rate control for each bit
1'b0: slow (half frequency)
1'b1: fast</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO0A_SR</name>
              <description>GPIO0A slew rate control for each bit
1'b0: slow (half frequency)
1'b1: fast</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMUGRF_GPIO1H_HE</name>
          <description>GPIO1C/D HE control</description>
          <addressOffset>0x16c</addressOffset>
          <size>32</size>
          <resetValue>0xf</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>GPIO0D_SR</name>
              <description>GPIO0D slew rate control for each bit
1'b0: slow (half frequency)
1'b1: fast</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO1C_SR</name>
              <description>GPIO1C slew rate control for each bit
1'b0: slow (half frequency)
1'b1: fast</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMUGRF_SOC_CON0</name>
          <description>SoC control register 0</description>
          <addressOffset>0x180</addressOffset>
          <size>32</size>
          <resetValue>0x320</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMU1830_VOL</name>
              <description>pmu IO 1.8v/3.0v select.
0: 3.0v ;
1: 1.8v ;
</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMU1830_VOLSEL</name>
              <description>pmu GPIO1 1.8v/3.0v control source select.
0: controlled by IO_GPIO0B1 ;
1: controlled by
PMUGRF.SOC_CON0.pmu1830_vol
</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_ALIVE_NIU_EN</name>
              <description>pd_alive pclk_niu gating.
1: gating ;
0: not gating .</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM3_SEL</name>
              <description>Use 2 optional IOs for pwm3.
0: pwm3a
1: pwm3b</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CRU_PMU_PCLK_GATE</name>
              <description>1: gate clock ;
0: not gate .</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMU_NOC_OBSRV</name>
              <description>pmu_noc_obsrv
</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMU_MCU_NIU_OBSRV</name>
              <description>pmu_mcu_niu_obsrv
</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMU_NOC_STALL</name>
              <description>When pmu noc meet illegal access, the noc
will
0: error reponse
1: stall</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CHIP_32K_SRC</name>
              <description>chip 32K clock source select
0: from external
1: from internal, pvtm</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMUGRF_SOC_CON10</name>
          <description>SoC control register 10</description>
          <addressOffset>0x1a8</addressOffset>
          <size>32</size>
          <resetValue>0x61a8</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDMMC_DETTIME0</name>
              <description>sdmmc_dettime[15:0]</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMUGRF_SOC_CON11</name>
          <description>SoC control register 11</description>
          <addressOffset>0x1ac</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDMMC_DETTIME1</name>
              <description>sdmmc_dettime[19:16]</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMUGRF_PMUPVTM_CON0</name>
          <description>pmu pvtm configuration register0</description>
          <addressOffset>0x240</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
......
When bit 31=1, bit 15    can be written by
software .
When bit 31=0, bit 15    cannot be written by
software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PVTM_CLKOUT_DIV</name>
              <description>clk_pvtm_out_div=clk_pvtm_out/pvtm_clko
ut_div</description>
              <bitRange>[15:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PVTM_OSC_EN</name>
              <description>pmu pvtm osc enable</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PVTM_START</name>
              <description>pmu pvtm start</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMUGRF_PMUPVTM_CON1</name>
          <description>pmu pvtm configuration register1</description>
          <addressOffset>0x244</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PVTM_CORE_CAL_CNT</name>
              <description>pd_core pvtm calculator counter</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMUGRF_PMUPVTM_STATUS0</name>
          <description>pmu pvtm status register</description>
          <addressOffset>0x248</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PVTM_FREQ_DONE</name>
              <description>pvtm frequency calculate done status</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMUGRF_PMUPVTM_STATUS1</name>
          <description>pmu pvtm status register</description>
          <addressOffset>0x24c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PVTM_FREQ_CNT</name>
              <description>pvtm frequency count</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMUGRF_OSC_E</name>
          <description>OSC control register</description>
          <addressOffset>0x250</addressOffset>
          <size>32</size>
          <resetValue>0x6</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>When bit 16=1, bit 0    can be written by
software .
When bit 16=0, bit 0    cannot be written by
software;
When bit 17=1, bit 1    can be written by
software .
When bit 17=0, bit 1    cannot be written by
software;
When bit 18=1, bit 2    can be written by
software .
When bit 18=0, bit 2    cannot be written by
software;</description>
              <bitRange>[18:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OSC_E</name>
              <description>24M OSC drive strenth</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMUGRF_OS_REG0</name>
          <description>os register</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OS_REG0</name>
              <description>os register</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMUGRF_OS_REG1</name>
          <description>os register</description>
          <addressOffset>0x304</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OS_REG1</name>
              <description>os register</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMUGRF_OS_REG2</name>
          <description>os register</description>
          <addressOffset>0x308</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OS_REG2</name>
              <description>os register</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMUGRF_OS_REG3</name>
          <description>os register</description>
          <addressOffset>0x30c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OS_REG3</name>
              <description>os register</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CCI500</name>
      <version>1.0</version>
      <groupname>CCI500</groupname>
      <baseAddress>0xffb00000</baseAddress>
      <registers>
        <register>
          <name>CCI500_SYS_CTRL</name>
          <description>Control Override Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DISABLE_CLOCK_GATING</name>
              <description>Disable regional clock gating
0: Regional clock gating operates in the
CCI-500
1: Disables regional clock gating in the
CCI-500</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SNOOP_FILTER_DISABLE</name>
              <description>Disable the snoop filter
0: Snoop filter operation is defined by the
power state input, PSTATE.
1: Disable snoop filter operation</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DVM_DISABLE</name>
              <description>DVM message disable
0: Send speculative fetches according to the
Speculation Control Register
1: Disable speculative fetches from all master
interfaces</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SNOOP_DISABLE</name>
              <description>snoop_disable control
0: Snoop masters according to the Snoop
Control Registers
1: Disable all snoops, but not DVM messages</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CCI500_SECURE_CTRL</name>
          <description>Secure Access Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DEBUG_MONITOR_SECURITY_OVERRIDE</name>
              <description>0: Enable Non-secure access to the PMU and
Interface Monitor Registers.
1: Disable Non-secure access to the PMU and
Interface Monitor Registers, unless overridden
by bit[0]</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NON_SECURE_OVERRIDE</name>
              <description>Non-secure register access override
0: Disable Non-secure access to CCI-400
registers
1: Enable Non-secure access to CCI-400
registers</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CCI500_STATUS</name>
          <description>Status Register</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SF_RAM_STATE_CHANGE_PENDING</name>
              <description>Snoop filter RAM power state change pending.
This bit reads back the PREQ    input.
0b0: No change pending, any previous
requests have been accepted or denied.
0b1: State change is pending and might be
accepted or denied</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SF_RAM_STATE_REQUEST</name>
              <description>This is the last requested power state of the
snoop filter RAMs Encoding as SF_RAM_state.</description>
              <bitRange>[7:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SF_RAM_STATE</name>
              <description>The snoop filter RAM power states are
0b000: Off.
0b001: Static snoop filter RAM retention.
0b010: Reserved.
0b011: Dynamic snoop filter RAM retention.
0b100: On.
0b101-0b111 Reserved</description>
              <bitRange>[4:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SF_RAM_INITIALIZATION</name>
              <description>Indicates when the snoop filter RAM is
initialized. Shareable requests are not
serviced during this period.
0: Snoop filter RAM initialization is complete.
1: Snoop filter RAM initialization is in
progress.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CHANGE_PENDING</name>
              <description>Indicates whether any changes to the Snoop
Control Registers or the Control Override
Register are pending in the CCI-500:
0: No change pending
1: Change pending</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CCI500_ERROR_STATUS</name>
          <description>Imprecise Error Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IMPRECISE_ERR_SLV6</name>
              <description>Imprecise error indicator for slave interface 6
0b0: No error from the time this bit was last
reset.
0b1: An error response has been received, but
not signaled precisely.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IMPRECISE_ERR_SLV5</name>
              <description>Imprecise error indicator for slave interface 5
0b0: No error from the time this bit was last
reset.
0b1: An error response has been received, but
not signaled precisely.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IMPRECISE_ERR_SLV4</name>
              <description>Imprecise error indicator for slave interface 4
0b0: No error from the time this bit was last
reset.
0b1: An error response has been received, but
not signaled precisely.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IMPRECISE_ERR_SLV3</name>
              <description>Imprecise error indicator for slave interface 3
0b0: No error from the time this bit was last
reset.
0b1: An error response has been received, but
not signaled precisely.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IMPRECISE_ERR_SLV2</name>
              <description>Imprecise error indicator for slave interface 2
0b0: No error from the time this bit was last
reset.
0b1: An error response has been received, but
not signaled precisely.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IMPRECISE_ERR_SLV1</name>
              <description>Imprecise error indicator for slave interface 1
0b0: No error from the time this bit was last
reset.
0b1: An error response has been received, but
not signaled precisely.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IMPRECISE_ERR_SLV0</name>
              <description>Imprecise error indicator for slave interface 0.
0b0: No error from the time this bit was last
reset.
0b1: An error response has been received, but
not signaled precisely.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IMPRECISE_ERR_MST5</name>
              <description>Imprecise error indicator for master interface
5
0:    No error from the time this bit was last
reset.
1:    An error response has been received, but
not signalled precisely.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IMPRECISE_ERR_MST4</name>
              <description>Imprecise error indicator for master interface
4
0:    No error from the time this bit was last
reset.
1:    An error response has been received, but
not signalled precisely.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IMPRECISE_ERR_MST3</name>
              <description>Imprecise error indicator for master interface
3
0:    No error from the time this bit was last
reset.
1:    An error response has been received, but
not signalled precisely.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IMPRECISE_ERR_MST2</name>
              <description>Imprecise error indicator for master interface
2
0:    No error from the time this bit was last
reset.
1:    An error response has been received, but
not signalled precisely.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IMPRECISE_ERR_MST1</name>
              <description>Imprecise error indicator for master interface
1
0:    No error from the time this bit was last
reset.
1:    An error response has been received, but
not signalled precisely.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IMPRECISE_ERR_MST0</name>
              <description>Imprecise error indicator for master interface
0:
0:    No error from the time this bit was last
reset.
1:    An error response has been received, but
not signalled precisely.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CCI500_PFMMON_CTRL</name>
          <description>Performance Monitor Control Register (PMCR)</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNTER_NUM</name>
              <description>Specifies the number of counters
implemented.</description>
              <bitRange>[15:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DP</name>
              <description>Disables cycle counter, CCNT, if non-invasive
debug is prohibited:
0b0    Count is not disabled when NIDEN input
is LOW.
0b1    Count is disabled when NIDEN input is
LOW.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EX</name>
              <description>Enable export of the events to the event bus,
EVNTBUS, for an external monitoring
block to trace events:
0b0    Do not export EVNTBUS.
0b1    Export EVNTBUS.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RST</name>
              <description>Performance counter reset:
0b0    No action.
0b1    Reset all performance counters to zero,
not including CCNT.
</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CEN</name>
              <description>Enable bit:
0b0    Disable all counters, including CCNT.
0b1    Enable all counters, including CCNT.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CCI500_INTERFACE_MONITOR_CTRL</name>
          <description>Snoop Control Register for slave interface x</description>
          <addressOffset>0x104</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ENABLE_INTERFACE_MONITORS</name>
              <description>0b0 Interface Monitor counters and flags are
set to 0.
0b1 Enable all Interface Monitors.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CCI500_SNOOP_CTRL_S0</name>
          <description>CCI500_SNOOP_CTRL_S0</description>
          <addressOffset>0x1000</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SUPPORT_DVMS</name>
              <description>Slave interface supports DVM messages. This
is overridden to 0x0 if you set the
Control Override Register bit[1]</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SUPPORT_SNOOPS</name>
              <description>Slave interface supports snoop requests. This
is overridden to 0x0 if you set the
Control Override Register bit[0]</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE_DVMS</name>
              <description>Enable issuing of DVM message requests from
this slave interface.
RAZ/WI for interfaces not supporting DVM
messages:
0b0: Disable DVM message requests.
0b1: Enable DVM message requests.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE_SNOOPS</name>
              <description>Enable issuing of snoop requests from this
slave interface.
RAZ/WI for interfaces not supporting snoops:
0b0: Disable snoop requests.
0b1: Enable snoop requests.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CCI500_SHAREABLE_OVERRIDE_S0</name>
          <description>Shareable Override Register</description>
          <addressOffset>0x1004</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DOMAIN_OVERRIDE</name>
              <description>Shareable override for slave interface:
0b00-0b01: Do not override AxDOMAIN
inputs.
0b10: Override AxDOMAIN    inputs to 0b00,
meaning that all
transactions are treated as non-shareable:
ReadOnce becomes ReadNoSnoop.
WriteUnique and WriteLineUnique become
WriteNoSnoop.
CleanShared, CleanInvalid, and
MakeInvalid transactions do not generate
snoops.
0b11 Override AxDOMAIN    inputs to 0b01,
meaning that all Normal
transactions are treated as shareable:
ReadNoSnoop becomes ReadOnce.
WriteNoSnoop becomes WriteUnique.
CleanShared, CleanInvalid, and MakeInvalid
transactions generate snoops</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CCI500_RD_CHAN_QOS_OVERRIDE_S0</name>
          <description>Read Channel QoS Value Override Register for slave interface x</description>
          <addressOffset>0x1100</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ARQOS_OVERRIDE</name>
              <description>ARQOS value override for the slave interface</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CCI500_WR_CHAN_QOS_OVERRIDE_S0</name>
          <description>Write Channel QoS Value Override slave interface x</description>
          <addressOffset>0x1104</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AWQOS_OVERRIDE</name>
              <description>AWQOS value override for the slave interface</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CCI500_MAX_OT_S0</name>
          <description>Maximum Outstanding Transactions Registers</description>
          <addressOffset>0x1110</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MAX_OT</name>
              <description>The maximum number of OTs for the
interface. This is a combined issuing limit. It
represents the maximum number of
transactions that the upstream master can
issue when the AR and AW channels are
considered as one issuing source.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CCI500_SNOOP_CTRL_S1</name>
          <description>CCI500_SNOOP_CTRL_S1</description>
          <addressOffset>0x2000</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SUPPORT_DVMS</name>
              <description>Slave interface supports DVM messages. This
is overridden to 0x0 if you set the
Control Override Register bit[1]</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SUPPORT_SNOOPS</name>
              <description>Slave interface supports snoop requests. This
is overridden to 0x0 if you set the
Control Override Register bit[0]</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE_DVMS</name>
              <description>Enable issuing of DVM message requests from
this slave interface.
RAZ/WI for interfaces not supporting DVM
messages:
0b0: Disable DVM message requests.
0b1: Enable DVM message requests.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE_SNOOPS</name>
              <description>Enable issuing of snoop requests from this
slave interface.
RAZ/WI for interfaces not supporting snoops:
0b0: Disable snoop requests.
0b1: Enable snoop requests.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CCI500_SHAREABLE_OVERRIDE_S1</name>
          <description>Shareable Override Register</description>
          <addressOffset>0x2004</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DOMAIN_OVERRIDE</name>
              <description>Shareable override for slave interface:
0b00-0b01: Do not override AxDOMAIN
inputs.
0b10: Override AxDOMAIN    inputs to 0b00,
meaning that all
transactions are treated as non-shareable:
ReadOnce becomes ReadNoSnoop.
WriteUnique and WriteLineUnique become
WriteNoSnoop.
CleanShared, CleanInvalid, and
MakeInvalid transactions do not generate
snoops.
0b11 Override AxDOMAIN    inputs to 0b01,
meaning that all Normal
transactions are treated as shareable:
ReadNoSnoop becomes ReadOnce.
WriteNoSnoop becomes WriteUnique.
CleanShared, CleanInvalid, and MakeInvalid
transactions generate snoops</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CCI500_RD_CHAN_QOS_OVERRIDE_S1</name>
          <description>Read Channel QoS Value Override Register for slave interface x</description>
          <addressOffset>0x2100</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ARQOS_OVERRIDE</name>
              <description>ARQOS value override for the slave interface</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CCI500_WR_CHAN_QOS_OVERRIDE_S1</name>
          <description>Write Channel QoS Value Override slave interface x</description>
          <addressOffset>0x2104</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AWQOS_OVERRIDE</name>
              <description>AWQOS value override for the slave interface</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CCI500_MAX_OT_S1</name>
          <description>Maximum Outstanding Transactions Registers</description>
          <addressOffset>0x2110</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MAX_OT</name>
              <description>The maximum number of OTs for the
interface. This is a combined issuing limit. It
represents the maximum number of
transactions that the upstream master can
issue when the AR and AW channels are
considered as one issuing source.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CCI500_SLAVE_INTERFACE_MONITOR_S0</name>
          <description>Slave Interface Monitor Registers</description>
          <addressOffset>0x90000</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OUTSTANDING_SNOOPS</name>
              <description>Number of outstanding snoop requests or
DVM messages. From request handshake to
response or snoop data for a hit.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTSTANDING_WRITES</name>
              <description>Number of outstanding write transactions.
From request handshake to response for ACE
Lite interfaces or WACK    for ACE interfaces.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTSTANDING_READS</name>
              <description>Number of outstanding read transactions.
From request
handshake to response or RACK for ACE
interfaces.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STALLED_CD_CHANNEL</name>
              <description>A transfer is stalled on the CD channel.
CDVALID    is HIGH.
CDREADY    is LOW.
ACE slave only.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STALLED_CR_CHANNEL</name>
              <description>A transfer is stalled on the CR channel.
CRVALID    is HIGH.
CRREADY    is LOW.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STALLED_AC_CHANNEL</name>
              <description>A transfer is stalled on the AC channel.
ACVALID    is HIGH.
ACREADY    is LOW.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STALLED_B_CHANNEL</name>
              <description>A transfer is stalled on the B channel. BVALID
is HIGH
BREADY    is LOW.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STALLED_W_CHANNEL</name>
              <description>A transfer is stalled on the W channel.
WVALID    is HIGH.
WREADY    is LOW.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STALLED_AW_CHANNEL</name>
              <description>A transfer is stalled on the AW channel.
AWVALID    is HIGH.
AWREADY    is LOW.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STALLED_R_CHANNEL</name>
              <description>A transfer is stalled on the R channel.
RVALID    is HIGH.
RREADY    is LOW.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STALLED_AR_CHANNEL</name>
              <description>A transfer is stalled on the AR
channel.ARVALID    is HIGH. ARREADY    is
LOW.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CCI500_SLAVE_INTERFACE_MONITOR_S1</name>
          <description>Slave Interface Monitor Registers</description>
          <addressOffset>0x90004</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OUTSTANDING_SNOOPS</name>
              <description>Number of outstanding snoop requests or
DVM messages. From request handshake to
response or snoop data for a hit.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTSTANDING_WRITES</name>
              <description>Number of outstanding write transactions.
From request handshake to response for ACE
Lite interfaces or WACK    for ACE interfaces.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTSTANDING_READS</name>
              <description>Number of outstanding read transactions.
From request
handshake to response or RACK for ACE
interfaces.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STALLED_CD_CHANNEL</name>
              <description>A transfer is stalled on the CD channel.
CDVALID    is HIGH.
CDREADY    is LOW.
ACE slave only.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STALLED_CR_CHANNEL</name>
              <description>A transfer is stalled on the CR channel.
CRVALID    is HIGH.
CRREADY    is LOW.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STALLED_AC_CHANNEL</name>
              <description>A transfer is stalled on the AC channel.
ACVALID    is HIGH.
ACREADY    is LOW.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STALLED_B_CHANNEL</name>
              <description>A transfer is stalled on the B channel. BVALID
is HIGH
BREADY    is LOW.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STALLED_W_CHANNEL</name>
              <description>A transfer is stalled on the W channel.
WVALID    is HIGH.
WREADY    is LOW.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STALLED_AW_CHANNEL</name>
              <description>A transfer is stalled on the AW channel.
AWVALID    is HIGH.
AWREADY    is LOW.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STALLED_R_CHANNEL</name>
              <description>A transfer is stalled on the R channel.
RVALID    is HIGH.
RREADY    is LOW.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STALLED_AR_CHANNEL</name>
              <description>A transfer is stalled on the AR
channel.ARVALID    is HIGH. ARREADY    is
LOW.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CCI500_MASTER_INTERFACE_MONITOR_M0</name>
          <description>Master Interface Monitor Registers</description>
          <addressOffset>0x90100</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OUTSTANDING_WRITES</name>
              <description>Number of outstanding write transactions.
From request handshake to response.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTSTANDING_READS</name>
              <description>Number of outstanding read transactions.
From request handshake to response.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STALLED_B_CHANNEL</name>
              <description>A transfer is stalled on the B channel. BVALID
is HIGH BREADY    is LOW.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STALLED_W_CHANNEL</name>
              <description>A transfer is stalled on the W channel.
WVALID    is HIGH.
WREADY    is LOW.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STALLED_AW_CHANNEL</name>
              <description>A transfer is stalled on the AW channel.
AWVALID    is HIGH.
AWREADY    is LOW.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STALLED_R_CHANNEL</name>
              <description>A transfer is stalled on the R channel.
RVALID    is HIGH.
RREADY    is LOW.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STALLED_AR_CHANNEL</name>
              <description>A transfer is stalled on the AR
channel.ARVALID    is HIGH. ARREADY    is
LOW</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CCI500_MASTER_INTERFACE_MONITOR_M1</name>
          <description>Master Interface Monitor Registers</description>
          <addressOffset>0x90104</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OUTSTANDING_WRITES</name>
              <description>Number of outstanding write transactions.
From request handshake to response.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTSTANDING_READS</name>
              <description>Number of outstanding read transactions.
From request handshake to response.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STALLED_B_CHANNEL</name>
              <description>A transfer is stalled on the B channel. BVALID
is HIGH BREADY    is LOW.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STALLED_W_CHANNEL</name>
              <description>A transfer is stalled on the W channel.
WVALID    is HIGH.
WREADY    is LOW.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STALLED_AW_CHANNEL</name>
              <description>A transfer is stalled on the AW channel.
AWVALID    is HIGH.
AWREADY    is LOW.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STALLED_R_CHANNEL</name>
              <description>A transfer is stalled on the R channel.
RVALID    is HIGH.
RREADY    is LOW.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STALLED_AR_CHANNEL</name>
              <description>A transfer is stalled on the AR
channel.ARVALID    is HIGH. ARREADY    is
LOW
NFO
ROL
OBS</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GMAC</name>
      <version>1.0</version>
      <groupname>GMAC</groupname>
      <baseAddress>0xfe300000</baseAddress>
      <registers>
        <register>
          <name>GMAC_MAC_CONF</name>
          <description>MAC Configuration Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TC</name>
              <description>Transmit Configuration in RGMII
When set, this bit enables the transmission of duplex mode, link
speed, and link up/down information to the PHY in the RGMII
ports. When this bit is reset, no such information is driven to the
PHY.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WD</name>
              <description>Watchdog Disable
When this bit is set, the GMAC disables the watchdog timer on
the receiver, and can receive frames of up to 16,384 bytes.
When this bit is reset, the GMAC allows no more than 2,048 bytes
(10,240 if JE is set high) of the frame being received and cuts off
any bytes received after that.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>JD</name>
              <description>Jabber Disable
When this bit is set, the GMAC disables the jabber timer on the
transmitter, and can transfer frames of up to 16,384 bytes.
When this bit is reset, the GMAC cuts off the transmitter if the
application sends out more than 2,048 bytes of data (10,240 if JE
is set high) during transmission.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BE</name>
              <description>Frame Burst Enable
When this bit is set, the GMAC allows frame bursting during
transmission in GMII Half-Duplex mode.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IFG</name>
              <description>Inter-Frame Gap
These bits control the minimum IFG between frames during
transmission.
3'b000: 96 bit times
3'b001: 88 bit times
3'b010: 80 bit times
...
3'b111: 40 bit times</description>
              <bitRange>[19:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DCRS</name>
              <description>Disable Carrier Sense During Transmission
When set high, this bit makes the MAC transmitter ignore the
(G)MII CRS signal during frame transmission in Half-Duplex
mode. This request results in no errors generated due to Loss of
Carrier or No Carrier during such transmission. When this bit is
low, the MAC transmitter generates such errors due to Carrier
Sense and will even abort the transmissions.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PS</name>
              <description>Port Select
Selects between GMII and MII:
1'b0: GMII (1000 Mbps)
1'b1: MII (10/100 Mbps)</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FES</name>
              <description>Speed
Indicates the speed in Fast Ethernet (MII) mode:
1'b0: 10 Mbps
1'b1: 100 Mbps</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DO</name>
              <description>Disable Receive Own
When this bit is set, the GMAC disables the reception of frames
when the gmii_txen_o is asserted in Half-Duplex mode.
When this bit is reset, the GMAC receives all packets that are
given by the PHY while transmitting.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LM</name>
              <description>Loopback Mode
When this bit is set, the GMAC operates in loopback mode at
GMII/MII. The (G)MII Receive clock input (clk_rx_i) is required
for the loopback to work properly, as the Transmit clock is not
looped-back internally.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DM</name>
              <description>Duplex Mode
When this bit is set, the GMAC operates in a Full-Duplex mode
where it can transmit and receive simultaneously. This bit is RO
with default value of 1'b1 in Full-Duplex-only configuration.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IPC</name>
              <description>Checksum Offload
When this bit is set, the GMAC calculates the 16-bit one's
complement of the one's complement sum of all received
Ethernet frame payloads. It also checks whether the IPv4 Header
checksum (assumed to be bytes 25-26 or 29-30 (VLAN-tagged)
of the received Ethernet frame) is correct for the received frame
and gives the status in the receive status word. The GMAC core
also appends the 16-bit checksum calculated for the IP header
datagram payload (bytes after the IPv4 header) and appends it
to the Ethernet frame transferred to the application (when Type 2
COE is deselected).
When this bit is reset, this function is disabled.
When Type 2 COE is selected, this bit, when set, enables IPv4
checksum checking for received frame payloads TCP/UDP/ICMP
headers. When this bit is reset, the COE function in the receiver
is disabled and the corresponding PCE and IP HCE status bits are
always cleared.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DR</name>
              <description>Disable Retry
When this bit is set, the GMAC will attempt only 1 transmission.
When a collision occurs on the GMII/MII, the GMAC will ignore
the current frame transmission and report a Frame Abort with
excessive collision error in the transmit frame status.
When this bit is reset, the GMAC will attempt retries based on the
settings of BL.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LUD</name>
              <description>Link Up/Down
Indicates whether the link is up or down during the transmission
of configuration in RGMII interface:
1'b0: Link Down
1'b1: Link Up</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACS</name>
              <description>Automatic Pad/CRC Stripping
When this bit is set, the GMAC strips the Pad/FCS field on
incoming frames only if the length's field value is less than or
equal to 1,500 bytes. All received frames with length field greater
than or equal to 1,501 bytes are passed to the application
without stripping the Pad/FCS field.
When this bit is reset, the GMAC will pass all incoming frames to
the Host unmodified.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BL</name>
              <description>Back-Off Limit
The Back-Off limit determines the random integer number (r) of
slot time delays (4,096 bit times for 1000 Mbps and 512 bit times
for 10/100 Mbps) the GMAC waits before rescheduling a
transmission attempt during retries after a collision. This bit is
applicable only to Half-Duplex mode and is reserved (RO) in Full-
Duplex-only configuration.
2'b00: k = min (n, 10)
2'b01: k = min (n, 8)
2'b10: k = min (n, 4)
2'b11: k = min (n, 1),
Where n = retransmission attempt. The random integer r takes
the value in the range 0 =    r &lt; 2^k</description>
              <bitRange>[6:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DC</name>
              <description>Deferral Check
When this bit is set, the deferral check function is enabled in the
GMAC. The GMAC will issue a Frame Abort status, along with the
excessive deferral error bit set in the transmit frame status when
the transmission state machine is deferred for more than 24,288
bit times in 10/100-Mbps mode. If the Core is configured for
1000 Mbps operation, the threshold for deferral is 155,680 bits
times. Deferral begins when the transmitter is ready to transmit,
but is prevented because of an active CRS (carrier sense) signal
on the GMII/MII. Defer time is not cumulative. If the transmitter
defers for 10,000 bit times, then transmits, collides, backs off,
and then has to defer again after completion of back-off, the
deferral timer resets to 0 and restarts.
When this bit is reset, the deferral check function is disabled and
the GMAC defers until the CRS signal goes inactive.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TE</name>
              <description>Transmitter Enable
When this bit is set, the transmission state machine of the GMAC
is enabled for transmission on the GMII/MII. When this bit is
reset, the GMAC transmit state machine is disabled after the
completion of the transmission of the current frame, and will not
transmit any further frames.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RE</name>
              <description>Receiver Enable
When this bit is set, the receiver state machine of the GMAC is
enabled for receiving frames from the GMII/MII. When this bit is
reset, the GMAC receive state machine is disabled after the
completion of the reception of the current frame, and will not
receive any further frames from the GMII/MII.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_MAC_FRM_FILT</name>
          <description>MAC Frame Filter</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RA</name>
              <description>Receive All
When this bit is set, the GMAC Receiver module passes to the
Application all frames received irrespective of whether they pass
the address filter. The result of the SA/DA filtering is updated
(pass or fail) in the corresponding bits in the Receive Status
Word. When this bit is reset, the Receiver module passes to the
Application only those frames that pass the SA/DA address filter.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HPF</name>
              <description>Hash or Perfect Filter
When set, this bit configures the address filter to pass a frame if
it matches either the perfect filtering or the hash filtering as set
by HMC or HUC bits. When low and if the HUC/HMC bit is set, the
frame is passed only if it matches the Hash filter.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SAF</name>
              <description>Source Address Filter Enable
The GMAC core compares the SA field of the received frames with
the values programmed in the enabled SA registers. If the
comparison matches, then the SAMatch bit of RxStatus Word is
set high. When this bit is set high and the SA filter fails, the
GMAC drops the frame.
When this bit is reset, then the GMAC Core forwards the received
frame to the application and with the updated SA Match bit of the
RxStatus depending on the SA address comparison.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SAIF</name>
              <description>SA Inverse Filtering
When this bit is set, the Address Check block operates in inverse
filtering mode for the SA address comparison. The frames whose
SA matches the SA registers will be marked as failing the SA
Address filter.
When this bit is reset, frames whose SA does not match the SA
registers will be marked as failing the SA Address filter.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCF</name>
              <description>Pass Control Frames
These bits control the forwarding of all control frames (including
unicast and multicast PAUSE frames). Note that the processing of
PAUSE control frames depends only on RFE of Register
GMAC_FLOW_CTRL[2].
2'b00: GMAC filters all control frames from reaching the
application.
2'b01: GMAC forwards all control frames except PAUSE control
frames to application even if they fail the Address filter.
2'b10: GMAC forwards all control frames to application even if
they fail the Address Filter.
2'b11: GMAC forwards control frames that pass the Address
Filter.</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DBF</name>
              <description>Disable Broadcast Frames
When this bit is set, the AFM module filters all incoming
broadcast frames.
When this bit is reset, the AFM module passes all received
broadcast frames.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PM</name>
              <description>Pass All Multicast
When set, this bit indicates that all received frames with a
multicast destination address (first bit in the destination address
field is '1') are passed.
When reset, filtering of multicast frame depends on HMC bit.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DAIF</name>
              <description>DA Inverse Filtering
When this bit is set, the Address Check block operates in inverse
filtering mode for the DA address comparison for both unicast
and multicast frames.
When reset, normal filtering of frames is performed.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HMC</name>
              <description>Hash Multicast
When set, MAC performs destination address filtering of received
multicast frames according to the hash table.
When reset, the MAC performs a perfect destination address
filtering for multicast frames, that is, it compares the DA field
with the values programmed in DA registers.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HUC</name>
              <description>Hash Unicast
When set, MAC performs destination address filtering of unicast
frames according to the hash table.
When reset, the MAC performs a perfect destination address
filtering for unicast frames, that is, it compares the DA field with
the values programmed in DA registers.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PR</name>
              <description>Promiscuous Mode
When this bit is set, the Address Filter module passes all
incoming frames regardless of its destination or source address.
The SA/DA Filter Fails status bits of the Receive Status Word will
always be cleared when PR is set.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_HASH_TAB_HI</name>
          <description>Hash Table High Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HTH</name>
              <description>Hash Table High
This field contains the upper 32 bits of Hash table</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_HASH_TAB_LO</name>
          <description>Hash Table Low Register</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HTL</name>
              <description>Hash Table Low
This field contains the lower 32 bits of Hash table</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_GMII_ADDR</name>
          <description>GMII Address Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PA</name>
              <description>Physical Layer Address
This field tells which of the 32 possible PHY devices are being
accessed</description>
              <bitRange>[15:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GR</name>
              <description>GMII Register
These bits select the desired GMII register in the selected PHY
device</description>
              <bitRange>[10:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CR</name>
              <description>APB Clock Range
The APB Clock Range selection determines the frequency of the
MDC clock as per the pclk_gmac frequency used in your design.
The suggested range of pclk_gmac frequency applicable for each
value below (when Bit[5] = 0) ensures that the MDC clock is
approximately between the frequency range 1.0 MHz - 2.5 MHz.
0000              60-100 MHz            pclk_gmac/42
0001              100-150 MHz          pclk_gmac/62
0010              20-35 MHz              pclk_gmac/16
0011              35-60 MHz              pclk_gmac/26
0100              150-250 MHz        pclk_gmac/102
0101              250-300 MHz        pclk_gmac/124
0110, 0111      Reserved
When bit 5 is set, you can achieve MDC clock of frequency higher
than the IEEE802.3 specified frequency limit of 2.5 MHz and
program a clock divider of lower value. For example, when
pclk_gmac is of frequency 100 MHz and you program these bits
as "1010", then the resultant MDC clock will be of 12.5 MHz
which is outside the limit of IEEE 802.3 specified range. Please
program the values given below only if the interfacing chips
supports faster MDC clocks.
1000                    pclk_gmac/4
1001                    pclk_gmac/6
1010                    pclk_gmac/8
1011                    pclk_gmac/10
1100                    pclk_gmac/12
1101                    pclk_gmac/14
1110                    pclk_gmac/16
1111                    pclk_gmac/18</description>
              <bitRange>[5:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GW</name>
              <description>GMII Write
When set, this bit tells the PHY that this will be a Write operation
using register GMAC_GMII_DATA. If this bit is not set, this will be
a Read operation, placing the data in register GMAC_GMII_DATA.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GB</name>
              <description>GMII Busy
This bit should read a logic 0 before writing to Register
GMII_ADDR and Register GMII_DATA. This bit must also be set to
0 during a Write to Register GMII_ADDR. During a PHY register
access, this bit will be set to 1'b1 by the Application to indicate
that a Read or Write access is in progress. Register GMII_DATA
(GMII Data) should be kept valid until this bit is cleared by the
GMAC during a PHY Write operation. The Register GMII_DATA is
invalid until this bit is cleared by the GMAC during a PHY Read
operation. The Register GMII_ADDR (GMII Address) should not
be written to until this bit is cleared.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_GMII_DATA</name>
          <description>GMII Data Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GD</name>
              <description>GMII Data
This contains the 16-bit data value read from the PHY after a
Management Read operation or the 16-bit data value to be
written to the PHY before a Management Write operation.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_FLOW_CTRL</name>
          <description>Flow Control Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PT</name>
              <description>Pause Time
This field holds the value to be used in the Pause Time field in the
transmit control frame. If the Pause Time bits is configured to be
double-synchronized to the (G)MII clock domain, then
consecutive writes to this register should be performed only after
at least 4 clock cycles in the destination clock domain.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DZPQ</name>
              <description>Disable Zero-Quanta Pause
When set, this bit disables the automatic generation of Zero-
Quanta Pause Control frames on the de-assertion of the flow-
control signal from the FIFO layer (MTL or external sideband flow
control signal sbd_flowctrl_i/mti_flowctrl_i).
When this bit is reset, normal operation with automatic Zero-
Quanta Pause Control frame generation is enabled.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PLT</name>
              <description>Pause Low Threshold
This field configures the threshold of the PAUSE timer at which
the input flow control signal mti_flowctrl_i (or sbd_flowctrl_i) is
checked for automatic retransmission of PAUSE Frame. The
threshold values should be always less than the Pause Time
configured in Bits[31:16]. For example, if PT = 100H (256 slot-
times), and PLT = 01, then a second PAUSE frame is
automatically transmitted if the mti_flowctrl_i signal is asserted
at 228 (256-28) slot-times after the first PAUSE frame is
transmitted.
00            Pause time minus 4 slot times
01            Pause time minus 28 slot times
10            Pause time minus 144 slot times
11            Pause time minus 256 slot times
Slot time is defined as time taken to transmit 512 bits (64 bytes)
on the GMII/MII interface.</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UP</name>
              <description>Unicast Pause Frame Detect
When this bit is set, the GMAC will detect the Pause frames with
the station's unicast address specified in MAC Address0 High
Register and MAC Address0 Low Register, in addition to the
detecting Pause frames with the unique multicast address. When
this bit is reset, the GMAC will detect only a Pause frame with the
unique multicast address specified in the 802.3x standard.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RFE</name>
              <description>Receive Flow Control Enable
When this bit is set, the GMAC will decode the received Pause
frame and disable its transmitter for a specified (Pause Time)
time. When this bit is reset, the decode function of the Pause
frame is disabled.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TFE</name>
              <description>Transmit Flow Control Enable
In Full-Duplex mode, when this bit is set, the GMAC enables the
flow control operation to transmit Pause frames. When this bit is
reset, the flow control operation in the GMAC is disabled, and the
GMAC will not transmit any Pause frames.
In Half-Duplex mode, when this bit is set, the GMAC enables the
back-pressure operation. When this bit is reset, the backpressure
feature is disabled.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FCB_BPA</name>
              <description>Flow Control Busy/Backpressure Activate
This bit initiates a Pause Control frame in Full-Duplex mode and
activates the backpressure function in Half-Duplex mode if TFE
bit is set.
In Full-Duplex mode, this bit should be read as 1'b0 before
writing to the register GMAC_FLOW_CTRL. To initiate a pause
control frame, the application must set this bit to 1'b1. During a
transfer of the control frame, this bit will continue to be set to
signify that a frame transmission is in progress. After the
completion of Pause control frame transmission, the GMAC will
reset this bit to 1'b0. The register GMAC_FLOW_CTRL should not
be written to until this bit is cleared.
In Half-Duplex mode, when this bit is set (and TFE is set), then
backpressure is asserted by the GMAC Core. During
backpressure, when the GMAC receives a new frame, the
transmitter starts sending a JAM pattern resulting in a collision.
This control register bit is logically OR'ed with the mti_flowctrl_i
input signal for the backpressure function.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_VLAN_TAG</name>
          <description>VLAN Tag Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ETV</name>
              <description>Enable 12-Bit VLAN Tag Comparison
When this bit is set, a 12-bit VLAN identifier, rather than the
complete 16-bit VLAN tag, is used for comparison and filtering.
Bits[11:0] of the VLAN tag are compared with the corresponding
field in the received VLAN-tagged frame.
When this bit is reset, all 16 bits of the received VLAN frame's
fifteenth and sixteenth bytes are used for comparison.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VL</name>
              <description>VLAN Tag Identifier for Receive Frames
This contains the 802.1Q VLAN tag to identify VLAN frames, and
is compared to the fifteenth and sixteenth bytes of the frames
being received for VLAN frames. Bits[15:13] are the User Priority,
Bit[12] is the Canonical Format Indicator (CFI) and bits[11:0] are
the VLAN tag's VLAN Identifier (VID) field. When the ETV bit is
set, only the VID (Bits[11:0]) is used for comparison.
If VL (VL[11:0] if ETV is set) is all zeros, the GMAC does not
check the fifteenth and sixteenth bytes for VLAN tag comparison,
and declares all frames with a Type field value of 0x8100 to be
VLAN frames.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_DEBUG</name>
          <description>Debug register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TFIFO3</name>
              <description>When high, it indicates that the MTL TxStatus FIFO is full and
hence the MTL will not be accepting any more frames for
transmission.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TFIFO2</name>
              <description>When high, it indicates that the MTL TxFIFO is not empty and has
some data left for transmission.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TFIFO1</name>
              <description>When high, it indicates that the MTL TxFIFO Write Controller is
active and transferring data to the TxFIFO.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TFIFOSTA</name>
              <description>This indicates the state of the TxFIFO read Controller:
2'b00: IDLE state
2'b01: READ state (transferring data to MAC transmitter)
2'b10: Waiting for TxStatus from MAC transmitter
2'b11: Writing the received TxStatus or flushing the TxFIFO</description>
              <bitRange>[21:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PAUSE</name>
              <description>When high, it indicates that the MAC transmitter is in PAUSE
condition (in full-duplex only) and hence will not schedule any
frame for transmission</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TSAT</name>
              <description>This indicates the state of the MAC Transmit Frame Controller
module:
2'b00: IDLE
2'b01: Waiting for Status of previous frame or IFG/backoff period
to be over
2'b10: Generating and transmitting a PAUSE control frame (in full
duplex mode)
2'b11: Transferring input frame for transmission</description>
              <bitRange>[18:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TACT</name>
              <description>When high, it indicates that the MAC GMII/MII transmit protocol
engine is actively transmitting data and not in IDLE state.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RFIFO</name>
              <description>This gives the status of the RxFIFO Fill-level:
2'b00: RxFIFO Empty
2'b01: RxFIFO fill-level below flow-control de-activate threshold
2'b10: RxFIFO fill-level above flow-control activate threshold
2'b11: RxFIFO Full</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RFIFORD</name>
              <description>It gives the state of the RxFIFO read Controller:
2'b00: IDLE state
2'b01: Reading frame data
2'b10: Reading frame status (or time-stamp)
2'b11: Flushing the frame data and Status</description>
              <bitRange>[6:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RFIFOWR</name>
              <description>When high, it indicates that the MTL RxFIFO Write Controller is
active and transferring a received frame to the FIFO.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACT</name>
              <description>When high, it indicates the active state of the small FIFO Read
and Write controllers respectively of the MAC receive Frame
Controller module</description>
              <bitRange>[2:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RDB</name>
              <description>When high, it indicates that the MAC GMII/MII receive protocol
engine is actively receiving data and not in IDLE state.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_PMT_CTRL_STA</name>
          <description>PMT Control and Status Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WFFRPR</name>
              <description>Wake-Up Frame Filter Register Pointer Reset
When set, resets the Remote Wake-up Frame Filter register
pointer to 3'b000. It is automatically cleared after 1 clock cycle.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>GU</name>
              <description>Global Unicast
When set, enables any unicast packet filtered by the GMAC (DAF)
address recognition to be a wake-up frame.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WFR</name>
              <description>Wake-Up Frame Received
When set, this bit indicates the power management event was
generated due to reception of a wake-up frame. This bit is
cleared by a read into this register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>MPR</name>
              <description>Magic Packet Received
When set, this bit indicates the power management event was
generated by the reception of a Magic Packet. This bit is cleared
by a read into this register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>WFE</name>
              <description>Wake-Up Frame Enable
When set, enables generation of a power management event due
to wake-up frame reception.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MPE</name>
              <description>Magic Packet Enable
When set, enables generation of a power management event due
to Magic Packet reception.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD</name>
              <description>Power Down
When set, all received frames will be dropped. This bit is cleared
automatically when a magic packet or Wake-Up frame is
received, and Power-Down mode is disabled. Frames received
after this bit is cleared are forwarded to the application. This bit
must only be set when either the Magic Packet Enable or Wake-
Up Frame Enable bit is set high.</description>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
              <modifiedWriteValues>clear</modifiedWriteValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_INT_STATUS</name>
          <description>Interrupt Status Register</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MRCOIS</name>
              <description>MMC Receive Checksum Offload Interrupt Status
This bit is set high whenever an interrupt is generated in the MMC
Receive Checksum Offload Interrupt Register. This bit is cleared
when all the bits in this interrupt register are cleared.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MTIS</name>
              <description>MMC Transmit Interrupt Status
This bit is set high whenever an interrupt is generated in the MMC
Transmit Interrupt Register. This bit is cleared when all the bits in
this interrupt register are cleared. This bit is only valid when the
optional MMC module is selected during configuration.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MRIS</name>
              <description>MMC Receive Interrupt Status
This bit is set high whenever an interrupt is generated in the MMC
Receive Interrupt Register. This bit is cleared when all the bits in
this interrupt register are cleared. This bit is only valid when the
optional MMC module is selected during configuration.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MIS</name>
              <description>MMC Interrupt Status
This bit is set high whenever any of bits 7:5 is set high and
cleared only when all of these bits are low. This bit is valid only
when the optional MMC module is selected during configuration.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PIS</name>
              <description>PMT Interrupt Status
This bit is set whenever a Magic packet or Wake-on-LAN frame is
received in Power-Down mode). This bit is cleared when both
bits[6:5] are cleared due to a read operation to the register
GMAC_PMT_CTRL_STA.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RIS</name>
              <description>RGMII Interrupt Status
This bit is set due to any change in value of the Link Status of
RGMII interface. This bit is cleared when the user makes a read
operation the RGMII Status register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_INT_MASK</name>
          <description>Interrupt Mask Register</description>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PIM</name>
              <description>PMT Interrupt Mask
This bit when set, will disable the assertion of the interrupt signal
due to the setting of PMT Interrupt Status bit in Register
GMAC_INT_STATUS.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RIM</name>
              <description>RGMII Interrupt Mask
This bit when set, will disable the assertion of the interrupt signal
due to the setting of RGMII Interrupt Status bit in Register
GMAC_INT_STATUS.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_MAC_ADDR0_HI</name>
          <description>MAC Address0 High Register</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <resetValue>0xffff</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>A47_A32</name>
              <description>MAC Address0 [47:32]
This field contains the upper 16 bits (47:32) of the 6-byte first
MAC address. This is used by the MAC for filtering for received
frames and for inserting the MAC address in the Transmit Flow
Control (PAUSE) Frames.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_MAC_ADDR0_LO</name>
          <description>MAC Address0 Low Register</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <resetValue>0xffffffff</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>A31_A0</name>
              <description>MAC Address0 [31:0]
This field contains the lower 32 bits of the 6-byte first MAC
address. This is used by the MAC for filtering for received frames
and for inserting the MAC address in the Transmit Flow Control
(PAUSE) Frames.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_AN_CTRL</name>
          <description>AN Control Register</description>
          <addressOffset>0xc0</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ANE</name>
              <description>Auto-Negotiation Enable
When set, will enable the GMAC to perform auto-negotiation with
the link partner.
Clearing this bit will disable auto-negotiation.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RAN</name>
              <description>Restart Auto-Negotiation
When set, will cause auto-negotiation to restart if the ANE is set.
This bit is self-clearing after auto-negotiation starts. This bit
should be cleared for normal operation.</description>
              <bitRange>[9:9]</bitRange>
              <access>write-only</access>
              <modifiedWriteValues>clear</modifiedWriteValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_AN_STATUS</name>
          <description>AN Status Register</description>
          <addressOffset>0xc4</addressOffset>
          <size>32</size>
          <resetValue>0x8</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ANC</name>
              <description>Auto-Negotiation Complete
When set, this bit indicates that the auto-negotiation process is
completed.
This bit is cleared when auto-negotiation is reinitiated.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ANA</name>
              <description>Auto-Negotiation Ability
This bit is always high, because the GMAC supports auto-
negotiation.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>LS</name>
              <description>Link Status
When set, this bit indicates that the link is up. When cleared, this
bit indicates that the link is down.</description>
              <bitRange>[2:2]</bitRange>
              <access>write-only</access>
              <modifiedWriteValues>clear</modifiedWriteValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_AN_ADV</name>
          <description>Auto Negotiation Advertisement Register</description>
          <addressOffset>0xc8</addressOffset>
          <size>32</size>
          <resetValue>0x1e0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NP</name>
              <description>Next Page Support
This bit is tied to low, because the GMAC does not support the
next page.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RFE</name>
              <description>Remote Fault Encoding
These 2 bits provide a remote fault encoding, indicating to a link
partner that a fault or error condition has occurred.</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PSE</name>
              <description>Pause Encoding
These 2 bits provide an encoding for the PAUSE bits, indicating
that the GMAC is capable of configuring the PAUSE function as
defined in IEEE 802.3x.</description>
              <bitRange>[8:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HD</name>
              <description>Half-Duplex
This bit, when set high, indicates that the GMAC supports Half-
Duplex. This bit is tied to low (and RO) when the GMAC is
configured for Full-Duplex-only operation.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FD</name>
              <description>Full-Duplex
This bit, when set high, indicates that the GMAC supports Full-
Duplex.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_AN_LINK_PART_AB</name>
          <description>Auto Negotiation Link Partner Ability Register</description>
          <addressOffset>0xcc</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NP</name>
              <description>Next Page Support
When set, this bit indicates that more next page information is
available.
When cleared, this bit indicates that next page exchange is not
desired.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ACK</name>
              <description>Acknowledge
When set, this bit is used by the auto-negotiation function to
indicate that the link partner has successfully received the
GMAC's base page. When cleared, it indicates that a successful
receipt of the base page has not been achieved.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RFE</name>
              <description>Remote Fault Encoding
These 2 bits provide a remote fault encoding, indicating a fault or
error condition of the link partner.</description>
              <bitRange>[13:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PSE</name>
              <description>Pause Encoding
These 2 bits provide an encoding for the PAUSE bits, indicating
that the link partner's capability of configuring the PAUSE
function as defined in IEEE 802.3x.</description>
              <bitRange>[8:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>HD</name>
              <description>Half-Duplex
When set, this bit indicates that the link partner has the ability to
operate in Half-Duplex mode. When cleared, the link partner does
not have the ability to operate in Half-Duplex mode.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FD</name>
              <description>Full-Duplex
When set, this bit indicates that the link partner has the ability to
operate in Full-Duplex mode. When cleared, the link partner does
not have the ability to operate in Full-Duplex mode.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_AN_EXP</name>
          <description>Auto Negotiation Expansion Register</description>
          <addressOffset>0xd0</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NPA</name>
              <description>Next Page Ability
This bit is tied to low, because the GMAC does not support next
page function.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NPR</name>
              <description>New Page Received
When set, this bit indicates that a new page has been received by
the GMAC. This bit will be cleared when read.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_INTF_MODE_STA</name>
          <description>RGMII Status Register</description>
          <addressOffset>0xd8</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LST</name>
              <description>Link Status
Indicates whether the link is up (1'b1) or down (1'b0)</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>LSD</name>
              <description>Link Speed
Indicates the current speed of the link:
2'b00: 2.5 MHz
2'b01: 25 MHz
2'b10: 125 MHz</description>
              <bitRange>[2:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>LM</name>
              <description>Link Mode
Indicates the current mode of operation of the link:
1'b0: Half-Duplex mode
1'b1: Full-Duplex mode</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_MMC_CTRL</name>
          <description>MMC Control Register</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FHP</name>
              <description>Full-Half preset
When low and bit4 is set, all MMC counters get preset to almost-
half value. All octet counters get preset to 0x7FFF_F800 (half -
2K Bytes) and all frame-counters gets preset to 0x7FFF_FFF0
(half - 16)
When high and bit4 is set, all MMC counters get preset to almost-
full value. All octet counters get preset to 0xFFFF_F800 (full - 2K
Bytes) and all frame-counters gets preset to 0xFFFF_FFF0 (full -
16)</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CP</name>
              <description>Counters Preset
When set, all counters will be initialized or preset to almost full or
almost half as per Bit5 above. This bit will be cleared
automatically after 1 clock cycle. This bit along with bit5 is useful
for debugging and testing the assertion of interrupts due to MMC
counter becoming half-full or full.</description>
              <bitRange>[4:4]</bitRange>
              <access>write-only</access>
              <modifiedWriteValues>clear</modifiedWriteValues>
            </field>
            <field>
              <name>MCF</name>
              <description>MMC Counter Freeze
When set, this bit freezes all the MMC counters to their current
value. (None of the MMC counters are updated due to any
transmitted or received frame until this bit is reset to 0. If any
MMC counter is read with the Reset on Read bit set, then that
counter is also cleared in this mode.)</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ROR</name>
              <description>Reset on Read
When set, the MMC counters will be reset to zero after Read (self-
clearing after reset). The counters are cleared when the least
significant byte lane (bits[7:0]) is read.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CSR</name>
              <description>Counter Stop Rollover
When set, counter after reaching maximum value will not roll
over to zero</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CR</name>
              <description>Counters Reset
When set, all counters will be reset. This bit will be cleared
automatically after 1 clock cycle</description>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
              <modifiedWriteValues>clear</modifiedWriteValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_MMC_RX_INTR</name>
          <description>MMC Receive Interrupt Register</description>
          <addressOffset>0x104</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INT21</name>
              <description>The bit is set when the rxfifooverflow counter reaches half the
maximum value, and also when it reaches the maximum value.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT18</name>
              <description>The bit is set when the rxlengtherror counter reaches half the
maximum value, and also when it reaches the maximum value.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>INT5</name>
              <description>The bit is set when the rxcrcerror counter reaches half the
maximum value, and also when it reaches the maximum value.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT4</name>
              <description>The bit is set when the rxmulticastframes_g counter reaches half
the maximum value, and also when it reaches the maximum
value.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>INT2</name>
              <description>The bit is set when the rxoctetcount_g counter reaches half the
maximum value, and also when it reaches the maximum value.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>INT1</name>
              <description>The bit is set when the rxoctetcount_gb counter reaches half the
maximum value, and also when it reaches the maximum value.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>INT0</name>
              <description>The bit is set when the rxframecount_gb counter reaches half the
maximum value, and also when it reaches the maximum value.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_MMC_TX_INTR</name>
          <description>MMC Transmit Interrupt Register</description>
          <addressOffset>0x108</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INT21</name>
              <description>The bit is set when the txframecount_g counter reaches half the
maximum value, and also when it reaches the maximum value.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>INT20</name>
              <description>The bit is set when the txoctetcount_g counter reaches half the
maximum value, and also when it reaches the maximum value.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>INT19</name>
              <description>The bit is set when the txcarriererror counter reaches half the
maximum value, and also when it reaches the maximum value.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>INT13</name>
              <description>The bit is set when the txunderflowerror counter reaches half the
maximum value, and also when it reaches the maximum value.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>INT1</name>
              <description>The bit is set when the txframecount_gb counter reaches half the
maximum value, and also when it reaches the maximum value.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>INT0</name>
              <description>The bit is set when the txoctetcount_gb counter reaches half the
maximum value, and also when it reaches the maximum value.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_MMC_RX_INT_MSK</name>
          <description>MMC Receive Interrupt Mask Register</description>
          <addressOffset>0x10c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INT21</name>
              <description>Setting this bit masks the interrupt when the rxfifooverflow
counter reaches half the maximum value, and also when it
reaches the maximum value.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT18</name>
              <description>Setting this bit masks the interrupt when the rxlengtherror
counter reaches half the maximum value, and also when it
reaches the maximum value.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT5</name>
              <description>Setting this bit masks the interrupt when the rxcrcerror counter
reaches half the maximum value, and also when it reaches the
maximum value.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT4</name>
              <description>Setting this bit masks the interrupt when the
rxmulticastframes_g counter reaches half the maximum value,
and also when it reaches the maximum value.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT2</name>
              <description>Setting this bit masks the interrupt when the rxoctetcount_g
counter reaches half the maximum value, and also when it
reaches the maximum value.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT1</name>
              <description>Setting this bit masks the interrupt when the rxoctetcount_gb
counter reaches half the maximum value, and also when it
reaches the maximum value.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT0</name>
              <description>Setting this bit masks the interrupt when the rxframecount_gb
counter reaches half the maximum value, and also when it
reaches the maximum value.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_MMC_TX_INT_MSK</name>
          <description>MMC Transmit Interrupt Mask Register</description>
          <addressOffset>0x110</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INT21</name>
              <description>Setting this bit masks the interrupt when the txframecount_g
counter reaches half the maximum value, and also when it
reaches the maximum value.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT20</name>
              <description>Setting this bit masks the interrupt when the txoctetcount_g
counter reaches half the maximum value, and also when it
reaches the maximum value.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT19</name>
              <description>Setting this bit masks the interrupt when the txcarriererror
counter reaches half the maximum value, and also when it
reaches the maximum value.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT13</name>
              <description>Setting this bit masks the interrupt when the txunderflowerror
counter reaches half the maximum value, and also when it
reaches the maximum value.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT1</name>
              <description>Setting this bit masks the interrupt when the txframecount_gb
counter reaches half the maximum value, and also when it
reaches the maximum value.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT0</name>
              <description>Setting this bit masks the interrupt when the txoctetcount_gb
counter reaches half the maximum value, and also when it
reaches the maximum value.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_MMC_TXOCTETCNT_GB</name>
          <description>MMC TX OCTET Good and Bad Counter</description>
          <addressOffset>0x114</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXOCTETCOUNT_GB</name>
              <description>Number of bytes transmitted, exclusive of preamble and retried
bytes, in good and bad frames.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_MMC_TXFRMCNT_GB</name>
          <description>MMC TX Frame Good and Bad Counter</description>
          <addressOffset>0x118</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXFRAMECOUNT_GB</name>
              <description>Number of good and bad frames transmitted, exclusive of retried
frames.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_MMC_TXUNDFLWERR</name>
          <description>MMC TX Underflow Error</description>
          <addressOffset>0x148</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXUNDERFLOWERROR</name>
              <description>Number of frames aborted due to frame underflow error.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_MMC_TXCARERR</name>
          <description>MMC TX Carrier Error</description>
          <addressOffset>0x160</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXCARRIERERROR</name>
              <description>Number of frames aborted due to carrier sense error (no carrier
or loss of carrier).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_MMC_TXOCTETCNT_G</name>
          <description>MMC TX OCTET Good Counter</description>
          <addressOffset>0x164</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXOCTETCOUNT_G</name>
              <description>Number of bytes transmitted, exclusive of preamble, in good
frames only.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_MMC_TXFRMCNT_G</name>
          <description>MMC TX Frame Good Counter</description>
          <addressOffset>0x168</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXFRAMECOUNT_G</name>
              <description>Number of good frames transmitted.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_MMC_RXFRMCNT_GB</name>
          <description>MMC RX Frame Good and Bad Counter</description>
          <addressOffset>0x180</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXFRAMECOUNT_GB</name>
              <description>Number of good and bad frames received.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_MMC_RXOCTETCNT_GB</name>
          <description>MMC RX OCTET Good and Bad Counter</description>
          <addressOffset>0x184</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXOCTETCOUNT_GB</name>
              <description>Number of bytes received, exclusive of preamble, in good and
bad frames.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_MMC_RXOCTETCNT_G</name>
          <description>MMC RX OCTET Good Counter</description>
          <addressOffset>0x188</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXOCTETCOUNT_G</name>
              <description>Number of bytes received, exclusive of preamble, only in good
frames.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_MMC_RXMCFRMCNT_G</name>
          <description>MMC RX Multicast Frame Good Counter/MMC RX Mulitcast Frame Good Counter</description>
          <addressOffset>0x190</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXMULTICASTFRAMES_G</name>
              <description>Number of good multicast frames received.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_MMC_RXCRCERR</name>
          <description>MMC RX Carrier</description>
          <addressOffset>0x194</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXCRCERROR</name>
              <description>Number of frames received with CRC error.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_MMC_RXLENERR</name>
          <description>MMC RX Length Error</description>
          <addressOffset>0x1c8</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXLENGTHERROR</name>
              <description>Number of frames received with length error (Length type field
&#8800;frame size), for all frames with valid length field.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_MMC_RXFIFOOVRFLW</name>
          <description>MMC RX FIFO Overflow</description>
          <addressOffset>0x1d4</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXFIFOOVERFLOW</name>
              <description>Number of missed received frames due to FIFO overflow.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_MMC_IPC_INT_MSK</name>
          <description>MMC Receive Checksum Offload Interrupt Mask Register</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INT29</name>
              <description>Setting this bit masks the interrupt when the rxicmp_err_octets
counter reaches half the maximum value, and also when it
reaches the maximum value.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT27</name>
              <description>Setting this bit masks the interrupt when the rxtcp_err_octets
counter reaches half the maximum value, and also when it
reaches the maximum value.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT25</name>
              <description>Setting this bit masks the interrupt when the rxudp_err_octets
counter reaches half the maximum value, and also when it
reaches the maximum value.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT22</name>
              <description>Setting this bit masks the interrupt when the
rxipv6_hdrerr_octets counter reaches half the maximum value,
and also when it reaches the maximum value.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT17</name>
              <description>Setting this bit masks the interrupt when the
rxipv4_hdrerr_octets counter reaches half the maximum value,
and also when it reaches the maximum value.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT13</name>
              <description>Setting this bit masks the interrupt when the rxicmp_err_frms
counter reaches half the maximum value, and also when it
reaches the maximum value.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT11</name>
              <description>Setting this bit masks the interrupt when the rxtcp_err_frms
counter reaches half the maximum value, and also when it
reaches the maximum value.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT9</name>
              <description>Setting this bit masks the interrupt when the rxudp_err_frms
counter reaches half the maximum value, and also when it
reaches the maximum value.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT6</name>
              <description>Setting this bit masks the interrupt when the rxipv6_hdrerr_frms
counter reaches half the maximum value, and also when it
reaches the maximum value.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT5</name>
              <description>Setting this bit masks the interrupt when the rxipv6_gd_frms
counter reaches half the maximum value, and also when it
reaches the maximum value.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT1</name>
              <description>Setting this bit masks the interrupt when the rxipv4_hdrerr_frms
counter reaches half the maximum value, and also when it
reaches the maximum value.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT0</name>
              <description>Setting this bit masks the interrupt when the rxipv4_gd_frms
counter reaches half the maximum value, and also when it
reaches the maximum value.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_MMC_IPC_INTR</name>
          <description>MMC Receive Checksum Offload Interrupt Register</description>
          <addressOffset>0x208</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INT29</name>
              <description>The bit is set when the rxicmp_err_octets counter reaches half
the maximum value, and also when it reaches the maximum
value.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>INT27</name>
              <description>The bit is set when the rxtcp_err_octets counter reaches half the
maximum value, and also when it reaches the maximum value.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>INT25</name>
              <description>The bit is set when the rxudp_err_octets counter reaches half the
maximum value, and also when it reaches the maximum value.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>INT22</name>
              <description>The bit is set when the rxipv6_hdrerr_octets counter reaches half
the maximum value, and also when it reaches the maximum
value.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>INT17</name>
              <description>The bit is set when the rxipv4_hdrerr_octets counter reaches half
the maximum value, and also when it reaches the maximum
value.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>INT13</name>
              <description>The bit is set when the rxicmp_err_frms counter reaches half the
maximum value, and also when it reaches the maximum value.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>INT11</name>
              <description>The bit is set when the rxtcp_err_frms counter reaches half the
maximum value, and also when it reaches the maximum value.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>INT9</name>
              <description>The bit is set when the rxudp_err_frms counter reaches half the
maximum value, and also when it reaches the maximum value.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>INT6</name>
              <description>The bit is set when the rxipv6_hdrerr_frms counter reaches half
the maximum value, and also when it reaches the maximum
value.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>INT5</name>
              <description>The bit is set when the rxipv6_gd_frms counter reaches half the
maximum value, and also when it reaches the maximum value.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>INT1</name>
              <description>The bit is set when the rxipv4_hdrerr_frms counter reaches half
the maximum value, and also when it reaches the maximum
value.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>INT0</name>
              <description>The bit is set when the rxipv4_gd_frms counter reaches half the
maximum value, and also when it reaches the maximum value.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_MMC_RXIPV4GFRM</name>
          <description>MMC RX IPV4 Good Frame</description>
          <addressOffset>0x210</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXIPV4_GD_FRMS</name>
              <description>Number of good IPv4 datagrams received with the TCP, UDP, or
ICMP payload</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_MMC_RXIPV4HDERRFRM</name>
          <description>MMC RX IPV4 Head Error Frame</description>
          <addressOffset>0x214</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXIPV4_HDRERR_FRMS</name>
              <description>Number of IPv4 datagrams received with header (checksum,
length, or version mismatch) errors</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_MMC_RXIPV6GFRM</name>
          <description>MMC RX IPV6 Good Frame</description>
          <addressOffset>0x224</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXIPV6_GD_FRMS</name>
              <description>Number of good IPv6 datagrams received with TCP, UDP, or ICMP
payloads.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_MMC_RXIPV6HDERRFRM</name>
          <description>MMC RX IPV6 Head Error Frame</description>
          <addressOffset>0x228</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXIPV6_HDRERR_FRMS</name>
              <description>Number of IPv6 datagrams received with header errors (length or
version mismatch).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_MMC_RXUDPERRFRM</name>
          <description>MMC RX UDP Error Frame</description>
          <addressOffset>0x234</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXUDP_ERR_FRMS</name>
              <description>Number of good IP datagrams whose UDP payload has a
checksum error.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_MMC_RXTCPERRFRM</name>
          <description>MMC RX TCP Error Frame</description>
          <addressOffset>0x23c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXTCP_ERR_FRMS</name>
              <description>Number of good IP datagrams whose TCP payload has a
checksum error.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_MMC_RXICMPERRFRM</name>
          <description>MMC RX ICMP Error Frame</description>
          <addressOffset>0x244</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXICMP_ERR_FRMS</name>
              <description>Number of good IP datagrams whose ICMP payload has a
checksum error.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_MMC_RXIPV4HDERROCT</name>
          <description>MMC RX OCTET IPV4 Head Error</description>
          <addressOffset>0x254</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXIPV4_HDRERR_OCTETS</name>
              <description>Number of bytes received in IPv4 datagrams with header errors
(checksum, length, version mismatch). The value in the Length
field of IPv4 header is used to update this counter.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_MMC_RXIPV6HDERROCT</name>
          <description>MMC RX OCTET IPV6 Head Error</description>
          <addressOffset>0x268</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXIPV6_HDRERR_OCTETS</name>
              <description>Number of bytes received in IPv6 datagrams with header errors
(length, version mismatch). The value in the IPv6 header's
Length field is used to update this counter.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_MMC_RXUDPERROCT</name>
          <description>MMC RX OCTET UDP Error</description>
          <addressOffset>0x274</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXUDP_ERR_OCTETS</name>
              <description>Number of bytes received in a UDP segment that had checksum
errors.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_MMC_RXTCPERROCT</name>
          <description>MMC RX OCTET TCP Error</description>
          <addressOffset>0x27c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXTCP_ERR_OCTETS</name>
              <description>Number of bytes received in a TCP segment with checksum
errors.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_MMC_RXICMPERROCT</name>
          <description>MMC RX OCTET ICMP Error</description>
          <addressOffset>0x284</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXICMP_ERR_OCTETS</name>
              <description>Number of bytes received in an ICMP segment with checksum
errors.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_BUS_MODE</name>
          <description>Bus Mode Register</description>
          <addressOffset>0x1000</addressOffset>
          <size>32</size>
          <resetValue>0x20101</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AAL</name>
              <description>Address-Aligned Beats
When this bit is set high and the FB bit equals 1, the AXI
interface generates all bursts aligned to the start address LS bits.
If the FB bit equals 0, the first burst (accessing the data buffer's
start address) is not aligned, but subsequent bursts are aligned
to the address.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PBL_MODE</name>
              <description>8xPBL Mode
When set high, this bit multiplies the PBL value programmed (bits
[22:17] and bits [13:8]) eight times. Thus the DMA will transfer
data in to a maximum of 8, 16, 32, 64, 128, and 256 beats
depending on the PBL value.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>USP</name>
              <description>Use Separate PBL
When set high, it configures the RxDMA to use the value
configured in bits [22:17] as PBL while the PBL value in bits
[13:8] is applicable to TxDMA operations only. When reset to low,
the PBL value in bits [13:8] is applicable for both DMA engines.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RPBL</name>
              <description>RxDMA PBL
These bits indicate the maximum number of beats to be
transferred in one RxDMA transaction. This will be the maximum
value that is used in a single block Read/Write. The RxDMA will
always attempt to burst as specified in RPBL each time it starts a
Burst transfer on the host bus. RPBL can be programmed with
permissible values of 1, 2, 4, 8, 16, and 32. Any other value will
result in undefined behavior. These bits are valid and applicable
only when USP is set high.</description>
              <bitRange>[22:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FB</name>
              <description>Fixed Burst
This bit controls whether the AXI Master interface performs fixed
burst transfers or not. When set, the AHB will use only SINGLE,
INCR4, INCR8 or INCR16 during start of normal burst transfers.
When reset, the AXI will use SINGLE and INCR burst transfer
operations.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PBL</name>
              <description>Programmable Burst Length
These bits indicate the maximum number of beats to be
transferred in one DMA transaction. This will be the maximum
value that is used in a single block Read/Write.
The DMA will always attempt to burst as specified in PBL each
time it starts a Burst transfer on the host bus. PBL can be
programmed with permissible values of 1, 2, 4, 8, 16, and 32.
Any other value will result in undefined behavior. When USP is
set high, this PBL value is applicable for TxDMA transactions only.
The PBL values have the following limitations.
The maximum number of beats (PBL) possible is limited by the
size of the Tx FIFO and Rx FIFO in the MTL layer and the data bus
width on the DMA. The FIFO has a constraint that the maximum
beat supported is half the depth of the FIFO, except when
specified (as given below). For different data bus widths and FIFO
sizes, the valid PBL range (including x8 mode) is provided in the
following table. If the PBL is common for both transmit and
receive DMA, the minimum Rx FIFO and Tx FIFO depths must be
considered. Do not program out-of-range PBL values, because
the system may not behave properly.
For TxFIFO, valid PBL range in full duplex mode and duplex mode
is 128 or less.
For RxFIFO, valid PBL range in full duplex mode is all.</description>
              <bitRange>[13:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSL</name>
              <description>Descriptor Skip Length
This bit specifies the number of dword to skip between two
unchained descriptors. The address skipping starts from the end
of current descriptor to the start of next descriptor. When DSL
value equals zero, then the descriptor table is taken as
contiguous by the DMA, in Ring mode.</description>
              <bitRange>[6:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWR</name>
              <description>Software Reset
When this bit is set, the MAC DMA Controller resets all GMAC
Subsystem internal registers and logic. It is cleared automatically
after the reset operation has completed in all of the core clock
domains. Read a 0 value in this bit before re-programming any
register of the core.
Note: The reset operation is completed only when all the resets in
all the active clock domains are de-asserted. Hence it is essential
that all the PHY inputs clocks (applicable for the selected PHY
interface) are present for software reset completion.</description>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
              <modifiedWriteValues>clear</modifiedWriteValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_TX_POLL_DEMAND</name>
          <description>Transmit Poll Demand Register</description>
          <addressOffset>0x1004</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TPD</name>
              <description>Transmit Poll Demand
When these bits are written with any value, the DMA reads the
current descriptor pointed to by Register
GMAC_CUR_HOST_TX_DESC. If that descriptor is not available
(owned by Host), transmission returns to the Suspend state and
DMA Register GMAC_STATUS[2] is asserted. If the descriptor is
available, transmission resumes.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_RX_POLL_DEMAND</name>
          <description>Receive Poll Demand Register</description>
          <addressOffset>0x1008</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RPD</name>
              <description>Receive Poll Demand
When these bits are written with any value, the DMA reads the
current descriptor pointed to by Register
GMAC_CUR_HOST_RX_DESC. If that descriptor is not available
(owned by Host), reception returns to the Suspended state and
Register GMAC_STATUS[7] is not asserted. If the descriptor is
available, the Receive DMA returns to active state.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_RX_DESC_LIST_ADDR</name>
          <description>Receive Descriptor List Address Register</description>
          <addressOffset>0x100c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SRL</name>
              <description>Start of Receive List
This field contains the base address of the First Descriptor in the
Receive Descriptor list. The LSB bits [1/2/3:0] for 32/64/128-bit
bus width) will be ignored and taken as all-zero by the DMA
internally. Hence these LSB bits are Read Only.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_TX_DESC_LIST_ADDR</name>
          <description>Transmit Descriptor List Address Register</description>
          <addressOffset>0x1010</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>STL</name>
              <description>Start of Transmit List
This field contains the base address of the First Descriptor in the
Transmit Descriptor list. The LSB bits [1/2/3:0] for 32/64/128-bit
bus width) will be ignored and taken as all-zero by the DMA
internally. Hence these LSB bits are Read Only.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_STATUS</name>
          <description>Status Register</description>
          <addressOffset>0x1014</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPI</name>
              <description>GMAC PMT Interrupt
This bit indicates an interrupt event in the GMAC core's PMT
module. The software must read the corresponding registers in
the GMAC core to get the exact cause of interrupt and clear its
source to reset this bit to 1'b0. The interrupt signal from the
GMAC subsystem (sbd_intr_o) is high when this bit is high.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GMI</name>
              <description>GMAC MMC Interrupt
This bit reflects an interrupt event in the MMC module of the
GMAC core. The software must read the corresponding registers
in the GMAC core to get the exact cause of interrupt and clear the
source of interrupt to make this bit as 1'b0. The interrupt signal
from the GMAC subsystem (sbd_intr_o) is high when this bit is
high.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GLI</name>
              <description>GMAC Line interface Interrupt
This bit reflects an interrupt event in the GMAC Core's PCS or
RGMII interface block. The software must read the corresponding
registers in the GMAC core to get the exact cause of interrupt and
clear the source of interrupt to make this bit as 1'b0. The
interrupt signal from the GMAC subsystem (sbd_intr_o) is high
when this bit is high.</description>
              <bitRange>[26:26]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EB</name>
              <description>Error Bits
These bits indicate the type of error that caused a Bus Error
(e.g., error response on the AXI interface). Valid only with Fatal
Bus Error bit (Register GMAC_STATUS[13]) set. This field does
not generate an interrupt.
Bit 23: 1'b1 Error during data transfer by TxDMA
1'b0 Error during data transfer by RxDMA
Bit 24: 1'b1 Error during read transfer
1'b0 Error during write transfer
Bit 25: 1'b1 Error during descriptor access
1'b0 Error during data buffer access</description>
              <bitRange>[25:23]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TS</name>
              <description>Transmit Process State
These bits indicate the Transmit DMA FSM state. This field does
not generate an interrupt.
3'b000: Stopped; Reset or Stop Transmit Command issued.
3'b001: Running; Fetching Transmit Transfer Descriptor.
3'b010: Running; Waiting for status.
3'b011: Running; Reading Data from host memory buffer and
queuing it to transmit buffer (Tx FIFO).
3'b100: TIME_STAMP write state.
3'b101: Reserved for future use.
3'b110: Suspended; Transmit Descriptor Unavailable or Transmit
Buffer Underflow.
3'b111: Running; Closing Transmit Descriptor.</description>
              <bitRange>[22:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RS</name>
              <description>Receive Process State
These bits indicate the Receive DMA FSM state. This field does
not generate an interrupt.
3'b000: Stopped: Reset or Stop Receive Command issued.
3'b001: Running: Fetching Receive Transfer Descriptor.
3'b010: Reserved for future use.
3'b011: Running: Waiting for receive packet.
3'b100: Suspended: Receive Descriptor Unavailable.
3'b101: Running: Closing Receive Descriptor.
3'b110: TIME_STAMP write state.
3'b111: Running: Transferring the receive packet data from
receive buffer to host memory.</description>
              <bitRange>[19:17]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NIS</name>
              <description>Normal Interrupt Summary
Normal Interrupt Summary bit value is the logical OR of the
following when the corresponding interrupt bits are enabled in
Register OP_MODE:
Register GMAC_STATUS[0]: Transmit Interrupt
Register GMAC_STATUS[2]: Transmit Buffer Unavailable
Register GMAC_STATUS[6]: Receive Interrupt
Register GMAC_STATUS[14]: Early Receive Interrupt
Only unmasked bits affect the Normal Interrupt Summary bit.
This is a sticky bit and must be cleared (by writing a 1 to this bit)
each time a corresponding bit that causes NIS to be set is
cleared.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>AIS</name>
              <description>Abnormal Interrupt Summary
Abnormal Interrupt Summary bit value is the logical OR of the
following when the corresponding interrupt bits are enabled in
Register OP_MODE:
Register GMAC_STATUS[1]: Transmit Process Stopped
Register GMAC_STATUS[3]: Transmit Jabber Timeout
Register GMAC_STATUS[4]: Receive FIFO Overflow
Register GMAC_STATUS[5]: Transmit Underflow
Register GMAC_STATUS[7]: Receive Buffer Unavailable
Register GMAC_STATUS[8]: Receive Process Stopped
Register GMAC_STATUS[9]: Receive Watchdog Timeout
Register GMAC_STATUS[10]: Early Transmit Interrupt
Register GMAC_STATUS[13]: Fatal Bus Error
Only unmasked bits affect the Abnormal Interrupt Summary bit.
This is a sticky bit and must be cleared each time a
corresponding bit that causes AIS to be set is cleared.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>ERI</name>
              <description>Early Receive Interrupt
This bit indicates that the DMA had filled the first data buffer of
the packet. Receive Interrupt Register GMAC_STATUS[6]
automatically clears this bit.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>FBI</name>
              <description>Fatal Bus Error Interrupt
This bit indicates that a bus error occurred, as detailed in
[25:23]. When this bit is set, the corresponding DMA engine
disables all its bus accesses.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>ETI</name>
              <description>Early Transmit Interrupt
This bit indicates that the frame to be transmitted was fully
transferred to the MTL Transmit FIFO.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>RWT</name>
              <description>Receive Watchdog Timeout
This bit is asserted when a frame with a length greater than
2,048 bytes is received.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>RPS</name>
              <description>Receive Process Stopped
This bit is asserted when the Receive Process enters the Stopped
state.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>RU</name>
              <description>Receive Buffer Unavailable
This bit indicates that the Next Descriptor in the Receive List is
owned by the host and cannot be acquired by the DMA. Receive
Process is suspended. To resume processing Receive descriptors,
the host should change the ownership of the descriptor and issue
a Receive Poll Demand command. If no Receive Poll Demand is
issued, Receive Process resumes when the next recognized
incoming frame is received. Register GMAC_STATUS[7] is set
only when the previous Receive Descriptor was owned by the
DMA.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>RI</name>
              <description>Receive Interrupt
This bit indicates the completion of frame reception. Specific
frame status information has been posted in the descriptor.
Reception remains in the Running state.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>UNF</name>
              <description>Transmit Underflow
This bit indicates that the Transmit Buffer had an Underflow
during frame transmission. Transmission is suspended and an
Underflow Error TDES0[1] is set.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>OVF</name>
              <description>Receive Overflow
This bit indicates that the Receive Buffer had an Overflow during
frame reception. If the partial frame is transferred to application,
the overflow status is set in RDES0[11].</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>TJT</name>
              <description>Transmit Jabber Timeout
This bit indicates that the Transmit Jabber Timer expired,
meaning that the transmitter had been excessively active. The
transmission process is aborted and placed in the Stopped state.
This causes the Transmit Jabber Timeout TDES0[14] flag to
assert.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>TU</name>
              <description>Transmit Buffer Unavailable
This bit indicates that the Next Descriptor in the Transmit List is
owned by the host and cannot be acquired by the DMA.
Transmission is suspended. Bits[22:20] explain the Transmit
Process state transitions. To resume processing transmit
descriptors, the host should change the ownership of the bit of
the descriptor and then issue a Transmit Poll Demand command.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>TPS</name>
              <description>Transmit Process Stopped
This bit is set when the transmission is stopped.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>TI</name>
              <description>Transmit Interrupt
This bit indicates that frame transmission is finished and
TDES1[31] is set in the First Descriptor.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_OP_MODE</name>
          <description>Operation Mode Register</description>
          <addressOffset>0x1018</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DT</name>
              <description>Disable Dropping of TCP/IP Checksum Error Frames
When this bit is set, the core does not drop frames that only have
errors detected by the Receive Checksum Offload engine. Such
frames do not have any errors (including FCS error) in the
Ethernet frame received by the MAC but have errors in the
encapsulated payload only. When this bit is reset, all error frames
are dropped if the FEF bit is reset.</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSF</name>
              <description>Receive Store and Forward
When this bit is set, the MTL only reads a frame from the Rx FIFO
after the complete frame has been written to it, ignoring RTC
bits. When this bit is reset, the Rx FIFO operates in Cut-Through
mode, subject to the threshold specified by the RTC bits.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DFF</name>
              <description>Disable Flushing of Received Frames
When this bit is set, the RxDMA does not flush any frames due to
the unavailability of receive descriptors/buffers as it does
normally when this bit is reset.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TSF</name>
              <description>Transmit Store and Forward
When this bit is set, transmission starts when a full frame resides
in the MTL Transmit FIFO. When this bit is set, the TTC values
specified in Register GMAC_OP_MODE[16:14] are ignored. This
bit should be changed only when transmission is stopped.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FTF</name>
              <description>Flush Transmit FIFO
When this bit is set, the transmit FIFO controller logic is reset to
its default values and thus all data in the Tx FIFO is lost/flushed.
This bit is cleared internally when the flushing operation is
completed fully. The Operation Mode register should not be
written to until this bit is cleared. The data which is already
accepted by the MAC transmitter will not be flushed. It will be
scheduled for transmission and will result in underflow and runt
frame transmission.
Note: The flush operation completes only after emptying the
TxFIFO of its contents and all the pending Transmit Status of the
transmitted frames are accepted by the host. In order to
complete this flush operation, the PHY transmit clock (clk_tx_i) is
required to be active.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>TTC</name>
              <description>Transmit Threshold Control
These three bits control the threshold level of the MTL Transmit
FIFO. Transmission starts when the frame size within the MTL
Transmit FIFO is larger than the threshold. In addition, full
frames with a length less than the threshold are also transmitted.
These bits are used only when the TSF bit (Bit 21) is reset.
3'b000: 64
3'b001: 128
3'b010: 192
3'b011: 256
3'b100: 40
3'b101: 32
3'b110: 24
3'b111: 16</description>
              <bitRange>[16:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ST</name>
              <description>Start/Stop Transmission Command
When this bit is set, transmission is placed in the Running state,
and the DMA checks the Transmit List at the current position for a
frame to be transmitted. Descriptor acquisition is attempted
either from the current position in the list, which is the Transmit
List Base Address set by Register GMAC_TX_DESC_LIST_ADDR,
or from the position retained when transmission was stopped
previously. If the current descriptor is not owned by the DMA,
transmission enters the Suspended state and Transmit Buffer
Unavailable (Register GMAC_STATUS[2]) is set. The Start
Transmission command is effective only when transmission is
stopped. If the command is issued before setting DMA Register
TX_DESC_LIST_ADDR, then the DMA behavior is unpredictable.
When this bit is reset, the transmission process is placed in the
Stopped state after completing the transmission of the current
frame. The Next Descriptor position in the Transmit List is saved,
and becomes the current position when transmission is restarted.
The stop transmission command is effective only the transmission
of the current frame is complete or when the transmission is in
the Suspended state.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RFD</name>
              <description>Threshold for deactivating flow control (in both HD and FD)
These bits control the threshold (Fill-level of Rx FIFO) at which
the flow-control is de-asserted after activation.
2'b00: Full minus 1 KB
2'b01: Full minus 2 KB
2'b10: Full minus 3 KB
2'b11: Full minus 4 KB
Note that the de-assertion is effective only after flow control is
asserted.</description>
              <bitRange>[12:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RFA</name>
              <description>Threshold for activating flow control (in both HD and FD)
These bits control the threshold (Fill level of Rx FIFO) at which
flow control is activated.
2'b00: Full minus 1 KB
2'b01: Full minus 2 KB
2'b10: Full minus 3 KB
2'b11: Full minus 4 KB
Note that the above only applies to Rx FIFOs of 4 KB or more
when the EFC bit is set high.</description>
              <bitRange>[10:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EFC</name>
              <description>Enable HW flow control
When this bit is set, the flow control signal operation based on
fill-level of Rx FIFO is enabled. When reset, the flow control
operation is disabled.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FEF</name>
              <description>Forward Error Frames
When this bit is reset, the Rx FIFO drops frames with error status
(CRC error, collision error, GMII_ER, giant frame, watchdog
timeout, overflow). However, if the frame's start byte (write)
pointer is already transferred to the read controller side (in
Threshold mode), then the frames are not dropped.
When FEF is set, all frames except runt error frames are
forwarded to the DMA. But when RxFIFO overflows when a partial
frame is written, then such frames are dropped even when FEF is
set.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FUF</name>
              <description>Forward Undersized Good Frames
When set, the Rx FIFO will forward Undersized frames (frames
with no Error and length less than 64 bytes) including pad-bytes
and CRC).
When reset, the Rx FIFO will drop all frames of less than 64
bytes, unless it is already transferred due to lower value of
Receive Threshold (e.g., RTC = 01).</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RTC</name>
              <description>Receive Threshold Control
These two bits control the threshold level of the MTL Receive
FIFO. Transfer (request) to DMA starts when the frame size
within the MTL Receive FIFO is larger than the threshold. In
addition, full frames with a length less than the threshold are
transferred automatically. Note that value of 11 is not applicable
if the configured Receive FIFO size is 128 bytes. These bits are
valid only when the RSF bit is zero, and are ignored when the
RSF bit is set to 1.
2'b00: 64
2'b01: 32
2'b10: 96
2'b11: 128</description>
              <bitRange>[4:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OSF</name>
              <description>Operate on Second Frame
When this bit is set, this bit instructs the DMA to process a
second frame of Transmit data even before status for first frame
is obtained.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SR</name>
              <description>Start/Stop Receive
When this bit is set, the Receive process is placed in the Running
state. The DMA attempts to acquire the descriptor from the
Receive list and processes incoming frames. Descriptor
acquisition is attempted from the current position in the list,
which is the address set by register GMAC_RX_DESC_LIST_ADDR
or the position retained when the Receive process was previously
stopped. If no descriptor is owned by the DMA, reception is
suspended and Receive Buffer Unavailable (Register
GMAC_STATUS[7]) is set. The Start Receive command is effective
only when reception has stopped. If the command was issued
before setting register GMAC_RX_DESC_LIST_ADDR, DMA
behavior is unpredictable.
When this bit is cleared, RxDMA operation is stopped after the
transfer of the current frame. The next descriptor position in the
Receive list is saved and becomes the current position after the
Receive process is restarted. The Stop Receive command is
effective only when the Receive process is in either the Running
(waiting for receive packet) or in the Suspended state.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_INT_ENA</name>
          <description>Interrupt Enable Register</description>
          <addressOffset>0x101c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NIE</name>
              <description>Normal Interrupt Summary Enable
When this bit is set, a normal interrupt is enabled. When this bit
is reset, a normal interrupt is disabled. This bit enables the
following bits:
Register GMAC_STATUS[0]: Transmit Interrupt
Register GMAC_STATUS[2]: Transmit Buffer Unavailable
Register GMAC_STATUS[6]: Receive Interrupt
Register GMAC_STATUS[14]: Early Receive Interrupt</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AIE</name>
              <description>Abnormal Interrupt Summary Enable
When this bit is set, an Abnormal Interrupt is enabled. When this
bit is reset, an Abnormal Interrupt is disabled. This bit enables
the following bits
Register GMAC_STATUS[1]: Transmit Process Stopped
Register GMAC_STATUS[3]: Transmit Jabber Timeout
Register GMAC_STATUS[4]: Receive Overflow
Register GMAC_STATUS[5]: Transmit Underflow
Register GMAC_STATUS[7]: Receive Buffer Unavailable
Register GMAC_STATUS[8]: Receive Process Stopped
Register GMAC_STATUS[9]: Receive Watchdog Timeout
Register GMAC_STATUS[10]: Early Transmit Interrupt
Register GMAC_STATUS[13]: Fatal Bus Error</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERE</name>
              <description>Early Receive Interrupt Enable
When this bit is set with Normal Interrupt Summary Enable (BIT
16), Early Receive Interrupt is enabled. When this bit is reset,
Early Receive Interrupt is disabled.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FBE</name>
              <description>Fatal Bus Error Enable
When this bit is set with Abnormal Interrupt Summary Enable
(BIT 15), the Fatal Bus Error Interrupt is enabled. When this bit is
reset, Fatal Bus Error Enable Interrupt is disabled.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ETE</name>
              <description>Early Transmit Interrupt Enable
When this bit is set with an Abnormal Interrupt Summary Enable
(BIT 15), Early Transmit Interrupt is enabled. When this bit is
reset, Early Transmit Interrupt is disabled.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RWE</name>
              <description>Receive Watchdog Timeout Enable
When this bit is set with Abnormal Interrupt Summary Enable
(BIT 15), the Receive Watchdog Timeout Interrupt is enabled.
When this bit is reset, Receive
Watchdog Timeout Interrupt is disabled.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSE</name>
              <description>Receive Stopped Enable
When this bit is set with Abnormal Interrupt Summary Enable
(BIT 15), Receive Stopped Interrupt is enabled. When this bit is
reset, Receive Stopped Interrupt is disabled.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RUE</name>
              <description>Receive Buffer Unavailable Enable
When this bit is set with Abnormal Interrupt Summary Enable
(BIT 15), Receive Buffer Unavailable Interrupt is enabled. When
this bit is reset, the Receive Buffer Unavailable Interrupt is
disabled</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RIE</name>
              <description>Receive Interrupt Enable
When this bit is set with Normal Interrupt Summary Enable (BIT
16), Receive Interrupt is enabled. When this bit is reset, Receive
Interrupt is disabled.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNE</name>
              <description>Underflow Interrupt Enable
When this bit is set with Abnormal Interrupt Summary Enable
(BIT 15), Transmit Underflow Interrupt is enabled. When this bit
is reset, Underflow Interrupt is disabled.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVE</name>
              <description>Overflow Interrupt Enable
When this bit is set with Abnormal Interrupt Summary Enable
(BIT 15), Receive Overflow Interrupt is enabled. When this bit is
reset, Overflow Interrupt is disabled</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TJE</name>
              <description>Transmit Jabber Timeout Enable
When this bit is set with Abnormal Interrupt Summary Enable
(BIT 15), Transmit Jabber Timeout Interrupt is enabled. When
this bit is reset, Transmit Jabber Timeout Interrupt is disabled.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TUE</name>
              <description>Transmit Buffer Unavailable Enable
When this bit is set with Normal Interrupt Summary Enable (BIT
16), Transmit Buffer Unavailable Interrupt is enabled. When this
bit is reset, Transmit Buffer Unavailable Interrupt is disabled.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TSE</name>
              <description>Transmit Stopped Enable
When this bit is set with Abnormal Interrupt Summary Enable
(BIT 15), Transmission Stopped Interrupt is enabled. When this
bit is reset, Transmission Stopped Interrupt is disabled.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TIE</name>
              <description>Transmit Interrupt Enable
When this bit is set with Normal Interrupt Summary Enable (BIT
16), Transmit Interrupt is enabled. When this bit is reset,
Transmit Interrupt is disabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_OVERFLOW_CNT</name>
          <description>Missed Frame and Buffer Overflow Counter Register</description>
          <addressOffset>0x1020</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FIFO_OVERFLOW_BIT</name>
              <description>Overflow bit for FIFO Overflow Counter</description>
              <bitRange>[28:28]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>FRAME_MISS_NUMBER</name>
              <description>Indicates the number of frames missed by the application
This counter is incremented each time the MTL asserts the
sideband signal mtl_rxoverflow_o. The counter is cleared when
this register is read with mci_be_i[2] at 1'b1.</description>
              <bitRange>[27:17]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>MISS_FRAME_OVERFLOW_BIT</name>
              <description>Overflow bit for Missed Frame Counter</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>FRAME_MISS_NUMBER_2</name>
              <description>Indicates the number of frames missed by the controller due to
the Host Receive Buffer being unavailable. This counter is
incremented each time the DMA discards an incoming frame. The
counter is cleared when this register is read with mci_be_i[0] at
1'b1.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_REC_INT_WDT_TIMER</name>
          <description>Receive Interrupt Watchdog Timer Register</description>
          <addressOffset>0x1024</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RIWT</name>
              <description>RI Watchdog Timer count
Indicates the number of system clock cycles multiplied by 256 for
which the watchdog timer is set. The watchdog timer gets
triggered with the programmed value after the RxDMA completes
the transfer of a frame for which the    RI status bit is not set due
to the setting in the corresponding descriptor RDES1[31]. When
the watch-dog timer runs out, the RI bit is set and the timer is
stopped. The watchdog timer is reset when RI bit is set high due
to automatic setting of RI as per RDES1[31] of any received
frame.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_AXI_BUS_MODE</name>
          <description>AXI Bus Mode Register</description>
          <addressOffset>0x1028</addressOffset>
          <size>32</size>
          <resetValue>0x110001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EN_LPI</name>
              <description>Enable LPI (Low Power Interface)
When set to 1, enable the LPI (Low Power Interface) supported
by the GMAC and accepts the LPI request from the AXI System
Clock controller.
When set to 0, disables the Low Power Mode and always denies
the LPI request from the AXI System Clock controller.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNLCK_ON_MGK_RWK</name>
              <description>Unlock    on Magic Packet or Remote Wake Up
When set to 1, enables it to request coming out of Low Power
mode only when Magic Packet or Remote Wake Up Packet is
received.
When set to 0, enables it requests to come out of Low Power
mode when any frame is received.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WR_OSR_LMT</name>
              <description>AXI Maximum Write Out Standing Request Limit
This value limits the maximum outstanding request on the AXI
write interface.
Maximum outstanding requests = WR_OSR_LMT+1</description>
              <bitRange>[21:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RD_OSR_LMT</name>
              <description>AXI Maximum Read Out Standing Request Limit
This value limits the maximum outstanding request on the AXI
read interface.
Maximum outstanding requests = RD_OSR_LMT+1</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AXI_AAL</name>
              <description>Address-Aligned Beats
This bit is read-only bit and reflects the AAL bit (register
GMAC_BUS_MODE[25]).
When this bit set to 1, it performs address-aligned burst transfers
on both read and write channels.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BLEN16</name>
              <description>AXI Burst Length 16
When this bit is set to 1, or when UNDEF is set to 1, it is allowed
to select a burst length of 16.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLEN8</name>
              <description>AXI Burst Length 8
When this bit is set to 1, or when UNDEF is set to 1, it is allowed
to select a burst length of 8.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLEN4</name>
              <description>AXI Burst Length 4
When this bit is set to 1, or when UNDEF is set to 1, it is allowed
to select a burst length of 4.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDEF</name>
              <description>AXI Undefined Burst Length
This bit is read-only bit and indicates the complement (invert)
value of FB bit in register GMAC_BUS_MODE[16].
When this bit is set to 1, it is allowed to perform any burst length
equal to or below the maximum allowed burst length as
programmed in bits[7:1];
When this bit is set to 0, it is allowed to perform only fixed burst
lengths as indicated by BLEN256/128/64/32/16/8/4, or a burst
length of 1.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_AXI_STATUS</name>
          <description>AXI Status Register</description>
          <addressOffset>0x102c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RD_CH_STA</name>
              <description>When high, it indicates that AXI Master's read channel is active
and transferring data.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WR_CH_STA</name>
              <description>When high, it indicates that AXI Master's write channel is active
and transferring data.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_CUR_HOST_TX_DESC</name>
          <description>Current Host Transmit Descriptor Register</description>
          <addressOffset>0x1048</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HTDAP</name>
              <description>Host Transmit Descriptor Address Pointer
Cleared on Reset. Pointer updated by DMA during operation.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_CUR_HOST_RX_DESC</name>
          <description>Current Host Receive Descriptor Register</description>
          <addressOffset>0x104c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HRDAP</name>
              <description>Host Receive Descriptor Address Pointer
Cleared on Reset. Pointer updated by DMA during operation.
HTBAP
Host Transmit Buffer Address Pointer
Cleared on Reset. Pointer updated by DMA during operation.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GMAC_CUR_HOST_TX_BUF_ADDR</name>
          <description>Current Host Transmit Buffer Address Register</description>
          <addressOffset>0x1050</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>GMAC_CUR_HOST_RX_BUF_ADDR</name>
          <description>Current Host Receive Buffer Address Register/Current Host Receive Buffer Adderss Register</description>
          <addressOffset>0x1054</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HRBAP</name>
              <description>Host Receive Buffer Address Pointer
Cleared on Reset. Pointer updated by DMA during operation.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>I2C0</name>
      <version>1.0</version>
      <groupname>RKI2C</groupname>
      <baseAddress>0xff3c0000</baseAddress>
      <registers>
        <register>
          <name>RKI2C_CON</name>
          <description>control register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VERSION</name>
              <description>rki2c version
version information</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STOP_SETUP</name>
              <description>staop setup config
TSU;sto = (stop_setup + 1) * T(SCL_HIGH) + Tclk_i2c</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>START_SETUP</name>
              <description>start setup config
TSU;sta = (start_setup + 1) * T(SCL_HIGH) + Tclk_i2c
THD;sta = (start_setup + 2) * T(SCL_HIGH) - Tclk_i2c</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_UPD_ST</name>
              <description>SDA update point config
Used to config sda change state when scl is low, used to adjust
setup/hold time
4'bn:Thold = (n + 1) * Tclk_i2c
Note: 0 &lt;= n &lt;= 5</description>
              <bitRange>[10:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACT2NAK</name>
              <description>operation when NAK handshake is received
1'b0: ignored
1'b1: stop transaction</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACK</name>
              <description>last byte acknowledge control in master receive mode
1'b0: ACK
1'b1: NAK</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STOP</name>
              <description>stop enable
stop enable, when this bit is written to 1, I2C will generate stop
signal.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>START</name>
              <description>start enable
start enable, when this bit is written to 1, I2C will generate start
signal.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_MODE</name>
              <description>i2c mode select
2'b00: transmit only
2'b01: transmit address (device + register address) --&gt; restart -
-&gt; transmit address -&gt; receive only
2'b10: receive only
2'b11: transmit address (device + register address, write/read bit
is 1) --&gt; restart --&gt; transmit address (device address) --&gt;
receive data</description>
              <bitRange>[2:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_EN</name>
              <description>i2c module enable
1'b0:not enable
1'b1:enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RKI2C_CLKDIV</name>
          <description>clock divider register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x1</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLKDIVH</name>
              <description>scl high level clock count
T(SCL_HIGH) = Tclk_i2c * (CLKDIVH + 1) * 8</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKDIVL</name>
              <description>scl low level clock count
T(SCL_LOW) = Tclk_i2c * (CLKDIVL + 1) * 8</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RKI2C_MRXADDR</name>
          <description>the slave address accessed    for master rx mode</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDHVLD</name>
              <description>address high byte valid
1'b0:invalid
1'b1:valid</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDMVLD</name>
              <description>address middle byte valid
1'b0:invalid
1'b1:valid</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDLVLD</name>
              <description>address low byte valid
1'b0:invalid
1'b1:valid</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SADDR</name>
              <description>master address register
the lowest bit indicate write or read
24 bits address register</description>
              <bitRange>[23:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RKI2C_MRXRADDR</name>
          <description>the slave register address accessed    for master rx mode</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SRADDHVLD</name>
              <description>address high byte valid
1'b0:invalid
1'b1:valid</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SRADDMVLD</name>
              <description>address middle byte valid
1'b0:invalid
1'b1:valid</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SRADDLVLD</name>
              <description>address low byte valid
1'b0:invalid
1'b1:valid</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SRADDR</name>
              <description>slave register address accessed
24 bits register address</description>
              <bitRange>[23:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RKI2C_MTXCNT</name>
          <description>master transmit count</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MTXCNT</name>
              <description>master transmit count
6 bits counter</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RKI2C_MRXCNT</name>
          <description>master rx count</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MRXCNT</name>
              <description>master rx count
6 bits counter</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RKI2C_IEN</name>
          <description>interrupt enable register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SLAVEHDSCLEN</name>
              <description>slave hold scl interrupt enable
1'b0:disable
1'b1:enable</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NAKRCVIEN</name>
              <description>NAK handshake received interrupt enable
1'b0:disable
1'b1:enable</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STOPIEN</name>
              <description>stop operation finished interrupt enable
1'b0:disable
1'b1:enable</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STARTIEN</name>
              <description>start operation finished interrupt enable
1'b0:disable
1'b1:enable</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MBRFIEN</name>
              <description>MRXCNT data received finished interrupt enable
1'b0:disable
1'b1:enable</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MBTFIEN</name>
              <description>MTXCNT data transfer finished interrupt enable
1'b0:disable
1'b1:enable</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BRFIEN</name>
              <description>byte rx finished interrupt enable
1'b0:disable
1'b1:enable</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BTFIEN</name>
              <description>byte tx finished interrupt enable
1'b0:disable
1'b1:enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RKI2C_IPD</name>
          <description>interrupt pending register</description>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SLAVEHDSCLIPD</name>
              <description>slave hold scl interrupt pending bit
1'b0:no interrupt available
1'b1:slave hold scl interrupt appear, write 1 to clear</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NAKRCVIPD</name>
              <description>NAK handshake received interrupt pending bit
1'b0:no interrupt available
1'b1:NAK handshake received interrupt appear, write 1 to clear</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>STOPIPD</name>
              <description>stop operation finished interrupt pending bit
1'b0:no interrupt available
1'b1:stop operation finished interrupt appear, write 1 to clear</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>STARTIPD</name>
              <description>start operation finished interrupt pending bit
1'b0:no interrupt available
1'b1:start operation finished interrupt appear, write 1 to clear</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>MBRFIPD</name>
              <description>MRXCNT data received finished interrupt pending bit
1'b0:no interrupt available
1'b1:MRXCNT data received finished interrupt appear, write 1 to
clear</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>MBTFIPD</name>
              <description>MTXCNT data transfer finished interrupt pending bit
1'b0:no interrupt available
1'b1:MTXCNT data transfer finished interrupt appear, write 1 to
clear</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>BRFIPD</name>
              <description>byte rx finished interrupt pending bit
1'b0:no interrupt available
1'b1:byte rx finished interrupt appear, write 1 to clear</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>BTFIPD</name>
              <description>byte tx finished interrupt pending bit
1'b0:no interrupt available
1'b1:byte tx finished interrupt appear, write 1 to clear</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RKI2C_FCNT</name>
          <description>finished count</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FCNT</name>
              <description>finished count
the count of data which has been transmitted or received
for debug purpose</description>
              <bitRange>[5:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RKI2C_SCL_OE_DB</name>
          <description>slave hold debounce configure register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x20</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCL_OE_DB</name>
              <description>slave hold scl debounce
cycles for debounce (unit: Tclk_i2c)</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RKI2C_TXDATA%s</name>
          <description>I2C tx data register n</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <dim>8</dim>
          <dimIndex>0-7</dimIndex>
          <dimIncrement>4</dimIncrement>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RKI2C_TXDATA</name>
              <description>32-byte data to transmit</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RKI2C_RXDATA%s</name>
          <description>I2C rx data register n</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <dim>8</dim>
          <dimIndex>0-7</dimIndex>
          <dimIncrement>4</dimIncrement>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RKI2C_RXDATA</name>
              <description>32-byte received data</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RKI2C_ST</name>
          <description>status debug register</description>
          <addressOffset>0x220</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCL_ST</name>
              <description>scl status
1'b0: scl status low
1'b0: scl status high</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SDA_ST</name>
              <description>sda status
1'b0: sda status low
1'b0: sda status high
receive &#65311;</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="I2C0">
      <name>I2C1</name>
      <version>1.0</version>
      <groupname>RKI2C</groupname>
      <baseAddress>0xff110000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="I2C0">
      <name>I2C2</name>
      <version>1.0</version>
      <groupname>RKI2C</groupname>
      <baseAddress>0xff120000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="I2C0">
      <name>I2C3</name>
      <version>1.0</version>
      <groupname>RKI2C</groupname>
      <baseAddress>0xff130000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="I2C0">
      <name>I2C4</name>
      <version>1.0</version>
      <groupname>RKI2C</groupname>
      <baseAddress>0xff3d0000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="I2C0">
      <name>I2C5</name>
      <version>1.0</version>
      <groupname>RKI2C</groupname>
      <baseAddress>0xff140000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="I2C0">
      <name>I2C6</name>
      <version>1.0</version>
      <groupname>RKI2C</groupname>
      <baseAddress>0xff150000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="I2C0">
      <name>I2C7</name>
      <version>1.0</version>
      <groupname>RKI2C</groupname>
      <baseAddress>0xff160000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="I2C0">
      <name>I2C8</name>
      <version>1.0</version>
      <groupname>RKI2C</groupname>
      <baseAddress>0xff3e0000</baseAddress>
    </peripheral>
    <peripheral>
      <name>SPDIF</name>
      <version>1.0</version>
      <groupname>SPDIF</groupname>
      <baseAddress>0xff870000</baseAddress>
      <registers>
        <register>
          <name>SPDIF_CFGR</name>
          <description>Transfer Configuration Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MCD</name>
              <description>mclk divider
Fmclk/Fsdo
This parameter can be calculated by Fmclk/(Fs*128).
Fs=the sample frequency be wanted</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCMTYPE</name>
              <description>PCM type
0: linear PCM
1: non-linear PCM</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLR</name>
              <description>mclk domain logic clear
Write 1 to clear mclk domain logic. Read return zero.</description>
              <bitRange>[7:7]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CSE</name>
              <description>Channel status enable
0: disable
1: enable
The bit should be set to 1 when the channel conveys non-linear
PCM</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UDE</name>
              <description>User data enable
0: disable
1: enable</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VFE</name>
              <description>Validity flag enable
0: disable
1: enable</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADJ</name>
              <description>audio data justified
0: Right justified
1: Left justified</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HWT</name>
              <description>Halfword word transform enable
0: disable
1: enable
It is valid only when the valid data width is 16bit.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VDW</name>
              <description>Valid data width
00: 16bit
01: 20bit
10: 24bit
11: reserved
The valid data width is 16bit only for non-linear PCM</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPDIF_SDBLR</name>
          <description>Sample Date Buffer Level Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SDBLR</name>
              <description>Sample Date Buffer Level Register
Contains the number of valid data entries in the sample data
buffer.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPDIF_DMACR</name>
          <description>DMA Control Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TDE</name>
              <description>Transmit DMA Enable
0: Transmit DMA disabled
1: Transmit DMA enabled</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TDL</name>
              <description>Transmit Data Level
This bit field controls the level at which a DMA request is made by
the transmit logic. It is equal to the watermark level; that is, the
dma_tx_req signal is generated when the number of valid data
entries in the Sample Date Buffer is equal to or below this field
value</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPDIF_INTCR</name>
          <description>Interrupt Control Register</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>UDTIC</name>
              <description>User Data Interrupt Clear
Write '1' to clear the user data interrupt.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>BTTIC</name>
              <description>Block/Data burst transfer finish interrupt clear
Write 1 to clear the interrupt.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>SDBT</name>
              <description>Sample Date Buffer Threshold
Sample Date Buffer Threshold for empty interrupt</description>
              <bitRange>[9:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDBEIE</name>
              <description>Sample Date Buffer empty interrupt enable
0: disable
1: enable</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BTTIE</name>
              <description>Block transfer/repetition period end interrupt enable
When enabled, an interrupt will be asserted when the block
transfer is finished if the channel conveys linear PCM or when the
repetition period is reached if the channel conveys non-linear
PCM.
0: disable
1: enable</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UDTIE</name>
              <description>User Data Interrupt
0: disable
1: enable
If enabled, an interrupt will be asserted when the content of the
user data register is fed into the corresponding shadow register</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPDIF_INTSR</name>
          <description>Interrupt Status Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SDBEIS</name>
              <description>Sample Date Buffer empty interrupt status
0: inactive
1: active</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BTTIS</name>
              <description>Block/Data burst transfer interrupt status
0: inactive
1: active</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UDTIS</name>
              <description>User Data Interrupt Status
0: inactive
1: active</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPDIF_XFER</name>
          <description>Transfer Start Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>XFER</name>
              <description>Transfer Start Register
Transfer Start Register</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPDIF_SMPDR</name>
          <description>Sample Data Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SMPDR</name>
              <description>Sample Data Register
Sample Data Register
VLDFR_SUB_1
Validity Flag Subframe 1
Validity Flag Register 0
VLDFR_SUB_0
Validity Flag Subframe 0
Validity Flag for Subframe 0
USR_SUB_1
User Data Subframe 1
User Data Bit for Subframe 1
USR_SUB_0
User Data Subframe 0
User Data Bit for Subframe 0
CHNSR_SUB_1
Channel Status Subframe 1
Channel Status Bit for Subframe 1
CHNSR_SUB_0
Channel Status Subframe 0
Channel Status Bit for Subframe 0</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPDIF_VLDFRn</name>
          <description>Validity Flag Register n</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>SPDIF_USRDRn</name>
          <description>User Data Register n</description>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>SPDIF_CHNSRn</name>
          <description>Channel Status Register n</description>
          <addressOffset>0xc0</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>SPDIF_BURTSINFO</name>
          <description>Channel Burst Info Register</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PD</name>
              <description>pd
Preamble Pd for non-linear pcm, indicating the length of burst
payload in unit of bytes or bits.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BSNUM</name>
              <description>Bitstream Number
This field indicates the bitstream number. Usually the bitstream
number is 0.</description>
              <bitRange>[15:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATAINFO</name>
              <description>Data-type-dependent info
This field gives the data-type-dependent info</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERRFLAG</name>
              <description>Error Flag
0: indicates a valid burst-payload
1: indicates that the burst-payload may contain errors</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATATYPE</name>
              <description>Data type
0000000: null data
0000001: AC-3 data
0000011: Pause data
0000100: MPEG-1 layer 1 data
0000101: MPEG-1 layer 2 or 3 data or MPEG-2 without extension
0000110: MPEG-2 data with extension
0000111: MPEG-2 AAC
0001000: MPEG-2, layer-1 low sampling frequency
0001001: MPEG-2, layer-2 low sampling frequency
0001010: MPEG-2, layer-3 low sampling frequency
0001011: DTS type I
0001100: DTS type II
0001101: DTS type III
0001110: ATRAC
0001111: ATRAC 2/3
0010000: ATRAC-X
0010001: DTS type IV
0010010: WMA professional type I
0110010: WMA professional type II
1010010: WMA professional type III
1110010: WMA professional type IV
0010011: MPEG-2 AAC low sampling frequency
0110011: MPEG-2 AAC low sampling frequency
1010011: MPEG-2 AAC low sampling frequency
1110011: MPEG-2 AAC low sampling frequency
0010100: MPEG-4 AAC
0110100: MPEG-4 AAC
1010100: MPEG-4 AAC
1110100: MPEG-4 AAC
0010101: Enhanced AC-3
0010110: MAT
others: reserved</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPDIF_REPETTION</name>
          <description>Channel Repetition Register</description>
          <addressOffset>0x104</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REPETTION</name>
              <description>Repetition
This define the repetition period when the channel conveys non-
linear PCM</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPDIF_BURTSINFO_SHD</name>
          <description>Shadow Channel Burst Info Register</description>
          <addressOffset>0x108</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PD</name>
              <description>pd
Preamble Pd for non-linear pcm, indicating the length of burst
payload in unit of bytes or bits.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BSNUM</name>
              <description>Bitstream Number
This field indicates the bitstream number. Usually the birstream
number is 0.</description>
              <bitRange>[15:13]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DATAINFO</name>
              <description>Data-type-dependent info
This field gives the data-type-dependent info</description>
              <bitRange>[12:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ERRFLAG</name>
              <description>Error Flag
0: indicates a valid burst-payload
1: indicates that the burst-payload may contain errors</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DATATYPE</name>
              <description>Data type
0000000: null data
0000001: AC-3 data
0000011: Pause data
0000100: MPEG-1 layer 1 data
0000101: MPEG-1 layer 2 or 3 data or MPEG-2 without extension
0000110: MPEG-2 data with extension
0000111: MPEG-2 AAC
0001000: MPEG-2, layer-1 low sampling frequency
0001001: MPEG-2, layer-2 low sampling frequency
0001010: MPEG-2, layer-3 low sampling frequency
0001011: DTS type I
0001100: DTS type II
0001101: DTS type III
0001110: ATRAC
0001111: ATRAC 2/3
0010000: ATRAC-X
0010001: DTS type IV
0010010: WMA professional type I
0110010: WMA professional type II
1010010: WMA professional type III
1110010: WMA professional type IV
0010011: MPEG-2 AAC low sampling frequency
0110011: MPEG-2 AAC low sampling frequency
1010011: MPEG-2 AAC low sampling frequency
1110011: MPEG-2 AAC low sampling frequency
0010100: MPEG-4 AAC
0110100: MPEG-4 AAC
1010100: MPEG-4 AAC
1110100: MPEG-4 AAC
0010101: Enhanced AC-3
0010110: MAT
others: reserved</description>
              <bitRange>[6:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPDIF_REPETTION_SHD</name>
          <description>Shadow Channel Repetition Register</description>
          <addressOffset>0x10c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REPETTION</name>
              <description>Repetition
This register provides the repetition of the bitstream when
channel conveys non-linear PCM. In the design, it defines the
length between Pa of the two consecutive data-burst. For the
same audio format, the definition is different. Please convert the
actual repetition in order to comply with the design.
USR_SUB_1
User Data Subframe 1
User Data Bit for Subframe 1
USR_SUB_0
User Data Subframe 0
User Data Bit for Subframe 0
Table 14-2 Interface Between SPDIF and HDMI</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPDIF_USRDR_SHDn</name>
          <description>Shadow User Data Register n</description>
          <addressOffset>0x190</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PMUCRU</name>
      <version>1.0</version>
      <groupname>PMUCRU</groupname>
      <baseAddress>0xff750000</baseAddress>
      <registers>
        <register>
          <name>PMUCRU_PPLL_CON0</name>
          <description>PPLL configuration register0</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0xa9</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>FBDIV</name>
              <description>Feedback Divide Value
Valid divider settings are:
[16, 3200] in integer mode
[20, 320] in fractional mode
Tips: no plus one operation</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMUCRU_PPLL_CON1</name>
          <description>PPLL configuration register1</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x1203</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>POSTDIV2</name>
              <description>Second Post Divide Value
(1-7)</description>
              <bitRange>[14:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POSTDIV1</name>
              <description>First Post Divide Value
(1-7)</description>
              <bitRange>[10:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REFDIV</name>
              <description>Reference Clock Divide Value
(1-63)</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMUCRU_PPLL_CON2</name>
          <description>PPLL configuration register2</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x31f</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PLL_LOCK</name>
              <description>PLL lock status
1'b0: unlock
1'b1: lock</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FRACDIV</name>
              <description>Fractional part of feedback divide
(fraction = FRAC/2^24)</description>
              <bitRange>[23:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMUCRU_PPLL_CON3</name>
          <description>PPLL configuration register3</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x8</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PLL_WORK_MODE</name>
              <description>PLL work mode select
2'b00: Slow mode, clock from external 24MHz/26MHz OSC
(default)
2'b01: Normal mode, clock from PLL output
2'b10: Deep slow mode, clock from external 32.768kHz</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FOUT4PHASEPD</name>
              <description>Power down 4-phase clocks and 2X, 3X, 4X clocks
1'b0: no power down
1'b1: power down</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FOUTVCOPD</name>
              <description>Power down buffered VCO clock
1'b0: no power down
1'b1: power down</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FOUTPOSTDIVPD</name>
              <description>Power down all outputs except for buffered VCO clock
1'b0: no power down
1'b1: power down</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSMPD</name>
              <description>PLL saturation behavior enable
1'b0: no power down
1'b1: power down
DSMPD = 1'b1 ( modulator is disabled, "integer mode")</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DACPD</name>
              <description>Power down quantization noise cancellation DAC
1'b0: no power down
1'b1: power down</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BYPASS</name>
              <description>PLL Bypass.    FREF bypasses PLL to FOUTPOSTDIV
1'b0: no bypass
1'b1: bypass</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POWER_DOWN</name>
              <description>Global power down
1'b0: no power down
1'b1: power down</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMUCRU_PPLL_CON4</name>
          <description>PPLL configuration register4</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x7</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>SSMOD_SPREAD</name>
              <description>spread amplitude
% = 0.1 * SPREAD[4:0]</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSMOD_DIVVAL</name>
              <description>Divider required to set the modulation frequency
Divider required to set the modulation frequency</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSMOD_DOWNSPREAD</name>
              <description>Selects center spread or downs pread
1'b0: center spread
1'b1: down spread</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSMOD_RESET</name>
              <description>Reset modulator state
1'b0: no reset
1'b1: reset</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSMOD_DISABLE_SSCG</name>
              <description>Bypass SSMOD by module
1'b0: no bypass
1'b1: bypass</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSMOD_BP</name>
              <description>Bypass SSMOD by integration
1'b0: no bypass
1'b1: bypass</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMUCRU_PPLL_CON5</name>
          <description>PPLL configuration register5</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x7f00</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>SSMOD_EXT_MAXADDR</name>
              <description>External wave table data inputs
(0-255)</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSMOD_SEL_EXT_WAVE</name>
              <description>select external wave
1'b0: no select ext_wave
1'b1: select ext_wave</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMUCRU_CLKSEL_CON0</name>
          <description>Internal clock select and divide register0</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <resetValue>0x706</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CM0S_CLK_PLL_SEL</name>
              <description>cm0s_clk divider control register
1'b0:PPLL
1'b1:xin_24m</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CM0S_DIV_CON</name>
              <description>cm0s clock source select control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMU_PCLK_DIV_CON</name>
              <description>pmu_pclk divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMUCRU_CLKSEL_CON1</name>
          <description>Internal clock select and divide register1</description>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <resetValue>0x1986</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CLK_TIMER_SEL</name>
              <description>clk_timer source select control register
1'b0:xin_24m
1'b1:clk_32k</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_WIFI_SEL</name>
              <description>clk_wifi source select control register
1'b0:clk_wifi_divout
1'b1:clk_wifi_frac</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_WIFI_PLL_SEL</name>
              <description>clk_wifi_pll source select control register
1'b0:PPLL
1'b1:xin_24m</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_WIFI_DIV_CON</name>
              <description>clk_wifi divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_SPI3_PLL_SEL</name>
              <description>clk_spi3_pll source select control register
1'b0:xin_24m
1'b1:PPLL</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_SPI3_DIV_CON</name>
              <description>clk_spi3 divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMUCRU_CLKSEL_CON2</name>
          <description>Internal clock select and divide register2</description>
          <addressOffset>0x88</addressOffset>
          <size>32</size>
          <resetValue>0x303</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>I2C8_DIV_CON</name>
              <description>i2c8 divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[14:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C0_DIV_CON</name>
              <description>i2c0 divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMUCRU_CLKSEL_CON3</name>
          <description>Internal clock select and divide register3</description>
          <addressOffset>0x8c</addressOffset>
          <size>32</size>
          <resetValue>0x3</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>I2C4_DIV_CON</name>
              <description>i2c4 divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMUCRU_CLKSEL_CON4</name>
          <description>Internal clock select and divide register4</description>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <resetValue>0x2dc</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CLK_32K_SUSPEND_SEL</name>
              <description>clk_32k_suspend source select control register
1'b0:test clock out
1'b1:32k from pmu 24m div</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_32K_SUSPEND_DIV_CON</name>
              <description>clk_32k_suspend divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMUCRU_CLKSEL_CON5</name>
          <description>Internal clock select and divide register5</description>
          <addressOffset>0x94</addressOffset>
          <size>32</size>
          <resetValue>0x200</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CLK_UART_PLL_SEL</name>
              <description>clk_uart_pll source select control register
1'b0:xin_24m
1'b1:PPLL</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART4_CLK_SEL</name>
              <description>uart4_clk source select control register
2'b00:clk_uart4_divout
2'b01:clk_uart4_frac
2'b10:xin_24m</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART4_DIV_CON</name>
              <description>uart4 divider control register
clk=clk_src/(div_con+1)</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMUCRU_CLKFRAC_CON0</name>
          <description>Internal clock select and divide register6</description>
          <addressOffset>0x98</addressOffset>
          <size>32</size>
          <resetValue>0xbb8ea60</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>UART4_FRAC_DIV_CON</name>
              <description>uart4_frac divider control register
Fout = Fsrc*numerator/denominator
High 16-bit for numerator
Low 16-bit for denominator</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMUCRU_CLKFRAC_CON1</name>
          <description>Internal clock select and divide register7</description>
          <addressOffset>0x9c</addressOffset>
          <size>32</size>
          <resetValue>0xbb8ea60</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WIFI_FRAC_DIV_CON</name>
              <description>wifi_frac divider control register
Fout = Fsrc*numerator/denominator
High 16-bit for numerator
Low 16-bit for denominator</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMUCRU_CLKGATE_CON0</name>
          <description>Internal clock gating register0</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CLK_I2C8_SRC_EN</name>
              <description>clk_i2c8_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_I2C4_SRC_EN</name>
              <description>clk_i2c4_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_I2C0_SRC_EN</name>
              <description>clk_i2c0_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_WIFI_EN</name>
              <description>clk_wifi clock disable bit
When HIGH, disable clock</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_PVTM_PMU_EN</name>
              <description>clk_pvtm_pmu clock disable bit
When HIGH, disable clock</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_UART4_FRAC_SRC_EN</name>
              <description>clk_uart4_frac_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_UART4_SRC_EN</name>
              <description>clk_uart4_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_TIMER1_EN</name>
              <description>clk_timer1 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_TIMER0_EN</name>
              <description>clk_timer0 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_SPI3_SRC_EN</name>
              <description>clk_spi3_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FCLK_CM0S_PMU_PPLL_SRC_EN</name>
              <description>fclk_cm0s_pmu_ppll_src clock disable bit
When HIGH, disable clock</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMUCRU_CLKGATE_CON1</name>
          <description>Internal clock gating register1</description>
          <addressOffset>0x104</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PCLK_WDT_M0_PMU_EN</name>
              <description>pclk_wdt_m0_pmu clock disable bit
When HIGH, disable clock</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_UARTM0_EN</name>
              <description>pclk_uartm0 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_MAILBOX_PMU_EN</name>
              <description>pclk_mailbox_pmu clock disable bit
When HIGH, disable clock</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_TIMER_PMU_EN</name>
              <description>pclk_timer_pmu clock disable bit
When HIGH, disable clock</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_SPI3_EN</name>
              <description>pclk_spi3 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_RKPWM_PMU_EN</name>
              <description>pclk_rkpwm_pmu clock disable bit
When HIGH, disable clock</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_I2C8_EN</name>
              <description>pclk_i2c8 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_I2C4_EN</name>
              <description>pclk_i2c4 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_I2C0_EN</name>
              <description>pclk_i2c0 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_NOC_PMU_EN</name>
              <description>pclk_noc_pmu clock disable bit
When HIGH, disable clock
Suggest always on</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_SGRF_EN</name>
              <description>pclk_sgrf clock disable bit
When HIGH, disable clock
Suggest always on</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_GPIO1_EN</name>
              <description>pclk_gpio1 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_GPIO0_EN</name>
              <description>pclk_gpio0 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_INTMEM1_EN</name>
              <description>pclk_intmem1 clock disable bit
When HIGH, disable clock</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_PMUGRF_EN</name>
              <description>pclk_pmugrf clock disable bit
When HIGH, disable clock
Suggest always on</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLK_PMU_EN</name>
              <description>pclk_pmu clock disable bit
When HIGH, disable clock</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMUCRU_CLKGATE_CON2</name>
          <description>Internal clock gating register2</description>
          <addressOffset>0x108</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>HCLK_NOC_PMU_EN</name>
              <description>hclk_noc_pmu clock disable bit
When HIGH, disable clock
Suggest always on</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DCLK_CM0S_EN</name>
              <description>dclk_cm0s clock disable bit
When HIGH, disable clock</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HCLK_CM0S_EN</name>
              <description>hclk_cm0s clock disable bit
When HIGH, disable clock</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCLK_CM0S_EN</name>
              <description>sclk_cm0s clock disable bit
When HIGH, disable clock</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FCLK_CM0S_EN</name>
              <description>fclk_cm0s clock disable bit
When HIGH, disable clock</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMUCRU_SOFTRST_CON0</name>
          <description>Internal software reset control register0</description>
          <addressOffset>0x110</addressOffset>
          <size>32</size>
          <resetValue>0x24</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PRESETN_WDT_PMU_REQ</name>
              <description>presetn_wdt_pmu request bit
When HIGH, reset relative logic</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_UART_M0_PMU_REQ</name>
              <description>resetn_uart_m0_pmu request bit
When HIGH, reset relative logic</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_UART_M0_PMU_REQ</name>
              <description>presetn_uart_m0_pmu request bit
When HIGH, reset relative logic</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_TIMER_PMU_1_REQ</name>
              <description>resetn_timer_pmu_1 request bit
When HIGH, reset relative logic</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_TIMER_PMU_0_REQ</name>
              <description>resetn_timer_pmu_0 request bit
When HIGH, reset relative logic</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_TIMER_PMU_0_1_REQ</name>
              <description>presetn_timer_pmu_0_1 request bit
When HIGH, reset relative logic</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_SPI3_REQ</name>
              <description>resetn_spi3 request bit
When HIGH, reset relative logic</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_SPI3_REQ</name>
              <description>presetn_spi3 request bit
When HIGH, reset relative logic</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PORESETN_CM0S_PMU_REQ</name>
              <description>poresetn_cm0s_pmu request bit
When HIGH, reset relative logic</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DBGRESETN_CM0S_PMU_REQ</name>
              <description>dbgresetn_cm0s_pmu request bit
When HIGH, reset relative logic</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HRESETN_CM0S_NOC_PMU_REQ</name>
              <description>hresetn_cm0s_noc_pmu request bit
When HIGH, reset relative logic</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HRESETN_CM0S_PMU_REQ</name>
              <description>hresetn_cm0s_pmu request bit
When HIGH, reset relative logic</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_INTMEM_PMU_REQ</name>
              <description>presetn_intmem_pmu request bit
When HIGH, reset relative logic</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_NOC_PMU_REQ</name>
              <description>presetn_noc_pmu request bit
When HIGH, reset relative logic</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMUCRU_SOFTRST_CON1</name>
          <description>Internal software reset control register1</description>
          <addressOffset>0x114</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>RESETN_I2C8_REQ</name>
              <description>resetn_i2c8 request bit
When HIGH, reset relative logic</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_I2C4_REQ</name>
              <description>resetn_i2c4 request bit
When HIGH, reset relative logic</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_I2C0_REQ</name>
              <description>resetn_i2c0 request bit
When HIGH, reset relative logic</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_PVTM_PMU_REQ</name>
              <description>resetn_pvtm_pmu request bit
When HIGH, reset relative logic</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_INTR_ARB_REQ</name>
              <description>presetn_intr_arb request bit
When HIGH, reset relative logic</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_CRU_PMU_REQ</name>
              <description>presetn_cru_pmu request bit
When HIGH, reset relative logic</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_GPIO1_REQ</name>
              <description>presetn_gpio1 request bit
When HIGH, reset relative logic</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_GPIO0_REQ</name>
              <description>presetn_gpio0 request bit
When HIGH, reset relative logic</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_SGRF_REQ</name>
              <description>presetn_sgrf request bit
When HIGH, reset relative logic</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_PMUGRF_REQ</name>
              <description>presetn_pmugrf request bit
When HIGH, reset relative logic</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_RKPWM_PMU_REQ</name>
              <description>presetn_rkpwm_pmu request bit
When HIGH, reset relative logic</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_MAILBOX_PMU_REQ</name>
              <description>presetn_mailbox_pmu request bit
When HIGH, reset relative logic</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_I2C8_REQ</name>
              <description>presetn_i2c8 request bit
When HIGH, reset relative logic</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_I2C4_REQ</name>
              <description>presetn_i2c4 request bit
When HIGH, reset relative logic</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_I2C0_REQ</name>
              <description>presetn_i2c0 request bit
When HIGH, reset relative logic</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMUCRU_RSTNHOLD_CON0</name>
          <description>Internal reset hold control register0</description>
          <addressOffset>0x120</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PRESETN_WDT_PMU_HOLD</name>
              <description>presetn_wdt_pmu_hold control bit
When HIGH, reset hold, can't be reset by any reset source</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_UART_M0_PMU_HOLD</name>
              <description>resetn_uart_m0_pmu_hold control bit
When HIGH, reset hold, can't be reset by any reset source</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_UART_M0_PMU_HOLD</name>
              <description>presetn_uart_m0_pmu_hold control bit
When HIGH, reset hold, can't be reset by any reset source</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_TIMER_PMU_1_HOLD</name>
              <description>resetn_timer_pmu_1_hold control bit
When HIGH, reset hold, can't be reset by any reset source</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_TIMER_PMU_0_HOLD</name>
              <description>resetn_timer_pmu_0_hold control bit
When HIGH, reset hold, can't be reset by any reset source</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_TIMER_PMU_0_1_HOLD</name>
              <description>presetn_timer_pmu_0_1_hold control bit
When HIGH, reset hold, can't be reset by any reset source</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_SPI3_HOLD</name>
              <description>resetn_spi3_hold control bit
When HIGH, reset hold, can't be reset by any reset source</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_SPI3_HOLD</name>
              <description>presetn_spi3_hold control bit
When HIGH, reset hold, can't be reset by any reset source</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PORESETN_CM0S_PMU_HOLD</name>
              <description>poresetn_cm0s_pmu_hold control bit
When HIGH, reset hold, can't be reset by any reset source</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DBGRESETN_CM0S_PMU_HOLD</name>
              <description>dbgresetn_cm0s_pmu_hold control bit
When HIGH, reset hold, can't be reset by any reset source</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HRESETN_CM0S_NOC_PMU_HOLD</name>
              <description>hresetn_cm0s_noc_pmu_hold control bit
When HIGH, reset hold, can't be reset by any reset source</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HRESETN_CM0S_PMU_HOLD</name>
              <description>hresetn_cm0s_pmu_hold control bit
When HIGH, reset hold, can't be reset by any reset source</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_INTMEM_PMU_HOLD</name>
              <description>presetn_intmem_pmu_hold control bit
When HIGH, reset hold, can't be reset by any reset source</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_NOC_PMU_HOLD</name>
              <description>presetn_noc_pmu_hold control bit
When HIGH, reset hold, can't be reset by any reset source</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMUCRU_RSTNHOLD_CON1</name>
          <description>Internal reset hold control register1</description>
          <addressOffset>0x124</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>write mask bits
When every bit HIGH, enable the writing corresponding bit
When every bit LOW, don't care the writing corresponding bit</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>RESETN_I2C8_HOLD</name>
              <description>resetn_i2c8_hold control bit
When HIGH, reset hold, can't be reset by any reset source</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_I2C4_HOLD</name>
              <description>resetn_i2c4_hold control bit
When HIGH, reset hold, can't be reset by any reset source</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_I2C0_HOLD</name>
              <description>resetn_i2c0_hold control bit
When HIGH, reset hold, can't be reset by any reset source</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESETN_PVTM_PMU_HOLD</name>
              <description>resetn_pvtm_pmu_hold control bit
When HIGH, reset hold, can't be reset by any reset source</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_INTR_ARB_HOLD</name>
              <description>presetn_intr_arb_hold control bit
When HIGH, reset hold, can't be reset by any reset source</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_CRU_PMU_HOLD</name>
              <description>presetn_cru_pmu_hold control bit
When HIGH, reset hold, can't be reset by any reset source</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_GPIO1_HOLD</name>
              <description>presetn_gpio1_hold control bit
When HIGH, reset hold, can't be reset by any reset source</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_GPIO0_HOLD</name>
              <description>presetn_gpio0_hold control bit
When HIGH, reset hold, can't be reset by any reset source</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_SGRF_HOLD</name>
              <description>presetn_sgrf_hold control bit
When HIGH, reset hold, can't be reset by any reset source</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_PMUGRF_HOLD</name>
              <description>presetn_pmugrf_hold control bit
When HIGH, reset hold, can't be reset by any reset source</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_RKPWM_PMU_HOLD</name>
              <description>presetn_rkpwm_pmu_hold control bit
When HIGH, reset hold, can't be reset by any reset source</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_MAILBOX_PMU_HOLD</name>
              <description>presetn_mailbox_pmu_hold control bit
When HIGH, reset hold, can't be reset by any reset source</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_I2C8_HOLD</name>
              <description>presetn_i2c8_hold control bit
When HIGH, reset hold, can't be reset by any reset source</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_I2C4_HOLD</name>
              <description>presetn_i2c4_hold control bit
When HIGH, reset hold, can't be reset by any reset source</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESETN_I2C0_HOLD</name>
              <description>presetn_i2c0_hold control bit
When HIGH, reset hold, can't be reset by any reset source</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMUCRU_GATEDIS_CON0</name>
          <description>Internal gate disable control register0</description>
          <addressOffset>0x130</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLK_SDIOAUDIO_GATING_DIS</name>
              <description>clk_sdioaudio gate disable bit
When HIGH, gate disable, open all clocks power domain idle
request needed</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_SD_GATING_DIS</name>
              <description>clk_sd gate disable bit
When HIGH, gate disable, open all clocks power domain idle
request needed</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_GIC_GATING_DIS</name>
              <description>clk_gic gate disable bit
When HIGH, gate disable, open all clocks power domain idle
request needed</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_GPU_GATING_DIS</name>
              <description>clk_gpu gate disable bit
When HIGH, gate disable, open all clocks power domain idle
request needed</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_PERILP_GATING_DIS</name>
              <description>clk_perilp gate disable bit
When HIGH, gate disable, open all clocks power domain idle
request needed</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_PERIHP_GATING_DIS</name>
              <description>clk_perihp gate disable bit
When HIGH, gate disable, open all clocks power domain idle
request needed</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_VCODEC_GATING_DIS</name>
              <description>clk_vcodec gate disable bit
When HIGH, gate disable, open all clocks power domain idle
request needed</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_VDU_GATING_DIS</name>
              <description>clk_vdu gate disable bit
When HIGH, gate disable, open all clocks power domain idle
request needed</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_RGA_GATING_DIS</name>
              <description>clk_rga gate disable bit
When HIGH, gate disable, open all clocks power domain idle
request needed</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_IEP_GATING_DIS</name>
              <description>clk_iep gate disable bit
When HIGH, gate disable, open all clocks power domain idle
request needed</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_VOPB_GATING_DIS</name>
              <description>clk_vopb gate disable bit
When HIGH, gate disable, open all clocks power domain idle
request needed</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_VOPL_GATING_DIS</name>
              <description>clk_vopl gate disable bit
When HIGH, gate disable, open all clocks power domain idle
request needed</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_ISP0_GATING_DIS</name>
              <description>clk_isp0 gate disable bit
When HIGH, gate disable, open all clocks power domain idle
request needed</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_ISP1_GATING_DIS</name>
              <description>clk_isp1 gate disable bit
When HIGH, gate disable, open all clocks power domain idle
request needed</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_HDCP_GATING_DIS</name>
              <description>clk_hdcp gate disable bit
When HIGH, gate disable, open all clocks power domain idle
request needed</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_USB3_GATING_DIS</name>
              <description>clk_usb3 gate disable bit
When HIGH, gate disable, open all clocks power domain idle
request needed</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_PERILPM0_GATING_DIS</name>
              <description>clk_perilpm0 gate disable bit
When HIGH, gate disable, open all clocks power domain idle
request needed</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_CENTER_GATING_DIS</name>
              <description>clk_center gate disable bit
When HIGH, gate disable, open all clocks power domain idle
request needed</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_CCIM0_GATING_DIS</name>
              <description>clk_ccim0 gate disable bit
When HIGH, gate disable, open all clocks power domain idle
request needed</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_CCIM1_GATING_DIS</name>
              <description>clk_ccim1 gate disable bit
When HIGH, gate disable, open all clocks power domain idle
request needed</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_VIO_GATING_DIS</name>
              <description>clk_vio gate disable bit
When HIGH, gate disable, open all clocks power domain idle
request needed</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_MSCH0_GATING_DIS</name>
              <description>clk_msch0 gate disable bit
When HIGH, gate disable, open all clocks power domain idle
request needed</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_MSCH1_GATING_DIS</name>
              <description>clk_msch1 gate disable bit
When HIGH, gate disable, open all clocks power domain idle
request needed</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_ALIVE_GATING_DIS</name>
              <description>clk_alive gate disable bit
When HIGH, gate disable, open all clocks power domain idle
request needed</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_PMU_GATING_DIS</name>
              <description>clk_pmu gate disable bit
When HIGH, gate disable, open all clocks power domain idle
request needed</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_EDP_GATING_DIS</name>
              <description>clk_edp gate disable bit
When HIGH, gate disable, open all clocks power domain idle
request needed</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_GMAC_GATING_DIS</name>
              <description>clk_gmac gate disable bit
When HIGH, gate disable, open all clocks power domain idle
request needed</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_EMMC_GATING_DIS</name>
              <description>clk_emmc gate disable bit
When HIGH, gate disable, open all clocks power domain idle
request needed</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_CENTER1_GATING_DIS</name>
              <description>clk_center1 gate disable bit
When HIGH, gate disable, open all clocks power domain idle
request needed</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_PMUM0_GATING_DIS</name>
              <description>clk_pmum0 gate disable bit
When HIGH, gate disable, open all clocks power domain idle
request needed</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>TSADC</name>
      <version>1.0</version>
      <groupname>TSADC</groupname>
      <baseAddress>0xff260000</baseAddress>
      <registers>
        <register>
          <name>TSADC_USER_CON</name>
          <description>The control register of A/D Converter.</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x208</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADC_STATUS</name>
              <description>ADC status (EOC)
0: ADC stop
1: Conversion in progress</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INTER_PD_SOC</name>
              <description>interleave between power down and start of conversion</description>
              <bitRange>[11:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>START</name>
              <description>When software write 1 to this bit , start_of_conversion will be
assert.
This bit will be cleared after TSADC access finishing.
When TSADC_USER_CON[4] = 1'b1 take effect.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>START_MODE</name>
              <description>start mode.
0: tsadc controller will asert    start_of_conversion after
"inter_pd_soc" cycles.
1: the start_of_conversion will be controlled by
TSADC_USER_CON[5].</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_POWER_CTRL</name>
              <description>ADC power down control bit
0: ADC power down
1: ADC power up and reset</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_INPUT_SRC_SEL</name>
              <description>ADC input source selection(CH_SEL[2:0]).
000 : Input source 0 (SARADC_AIN[0])
001 : Input source 1 (SARADC_AIN[1])
Others : Reserved</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TSADC_AUTO_CON</name>
          <description>TSADC auto mode control register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LAST_TSHUT_2CRU</name>
              <description>last_tshut_2cru for cru first/second reset
TSHUT status.
This bit will set to 1 when tshut is valid, and only be cleared when
application write 1 to it.
This bit will not be cleared by system reset.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LAST_TSHUT_2GPIO</name>
              <description>last_tshut_2gpio for hardware reset
TSHUT status.
This bit will set to 1 when tshut is valid, and only be cleared when
application write 1 to it.
This bit will not be cleared by system reset.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE_DLY_SEL</name>
              <description>0: AUTO_PERIOD is used
1: AUTO_PERIOD_HT is used</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>AUTO_STATUS</name>
              <description>0: auto mode stop;
1: auto mode in progress.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SRC1_LT_EN</name>
              <description>0: do not care low temperature of source 0
1: enable the low temperature monitor of source 0</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SRC0_LT_EN</name>
              <description>0: do not care low temperature of source 0
1: enable the low temperature monitor of source 0</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TSHUT_PROLARITY</name>
              <description>0: low active
1: high active</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SRC1_EN</name>
              <description>0: do not care the temperature of source 1
1: if the temperature of source 0 is too high , TSHUT will be valid</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SRC0_EN</name>
              <description>0: do not care the temperature of source 0
1: if the temperature of source 0 is too high , TSHUT will be valid</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TSADC_Q_SEL</name>
              <description>temperature coefficient
1'b0:use tsadc_q as output(positive temperature coefficient)
1'b1:use(1024 - tsadc_q) as output (negative temperature
coefficient)
RK3399 is negative temprature coefficient, so please set this bit as
1'b1</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTO_EN</name>
              <description>0: TSADC controller works at user-define mode
1: TSADC controller works at auto mode</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TSADC_INT_EN</name>
          <description>TSADC_INT_EN</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EOC_INT_EN</name>
              <description>eoc_Interrupt enable.
eoc_interrupt enable in user defined mode
0: disable
1: enable</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LT_INTEN_SRC1</name>
              <description>low temperature interrupt enable for src1
0: disable
1: enable</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LT_INTEN_SRC0</name>
              <description>low temperature interrupt enable for src0
0: disable
1: enable</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TSHUT_2CRU_EN_SRC1</name>
              <description>0: TSHUT output to cru disabled.    TSHUT output will always keep
low .
1: TSHUT output works.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TSHUT_2CRU_EN_SRC0</name>
              <description>0: TSHUT output to cru disabled.    TSHUT output will always keep
low .
1: TSHUT output works.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TSHUT_2GPIO_EN_SRC1</name>
              <description>0: TSHUT output to gpio disabled.    TSHUT output will always keep
low .
1: TSHUT output works.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TSHUT_2GPIO_EN_SRC0</name>
              <description>0: TSHUT output to gpio disabled.    TSHUT output will always keep
low .
1: TSHUT output works.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HT_INTEN_SRC1</name>
              <description>high temperature interrupt enable for src1
0: disable
1: enable</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HT_INTEN_SRC0</name>
              <description>high temperature interrupt enable for src0
0: disable
1: enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TSADC_INT_PD</name>
          <description>TSADC_INT_PD</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EOC_INT_PD</name>
              <description>Interrupt status.
This bit will be set to 1 when end-of-conversion.
Set 0 to clear the interrupt.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LT_IRQ_SRC1</name>
              <description>When TSADC output is lower than COMP_INT_LOW, this bit will be
valid, which means temperature is low, and the application should
in charge of this.
write 1 to it , this bit will be cleared.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LT_IRQ_SRC0</name>
              <description>When TSADC output is lower than COMP_INT_LOW, this bit will be
valid, which means temperature is low, and the application should
in charge of this.
write 1 to it , this bit will be cleared.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TSHUT_O_SRC1</name>
              <description>TSHUT output status
When TSADC output is bigger than COMP_SHUT, this bit will be
valid, which means temperature is VERY high, and the application
should in charge of this.
write 1 to it , this bit will be cleared.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TSHUT_O_SRC0</name>
              <description>TSHUT output status
When TSADC output is bigger than COMP_SHUT, this bit will be
valid, which means temperature is VERY high, and the application
should in charge of this.
write 1 to it , this bit will be cleared.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HT_IRQ_SRC1</name>
              <description>When TSADC output is bigger than COMP_INT, this bit will be valid,
which means temperature is high, and the application should in
charge of this.
write 1 to it , this bit will be cleared.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HT_IRQ_SRC0</name>
              <description>When TSADC output is bigger than COMP_INT, this bit will be valid,
which means temperature is high, and the application should in
charge of this.
write 1 to it , this bit will be cleared.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TSADC_DATA0</name>
          <description>This register contains the data after A/D Conversion.</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADC_DATA</name>
              <description>A/D value of the channel 0 last conversion (DOUT[9:0]).
</description>
              <bitRange>[11:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TSADC_DATA1</name>
          <description>This register contains the data after A/D Conversion.</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADC_DATA</name>
              <description>A/D value of the channel 0 last conversion (DOUT[9:0]).
</description>
              <bitRange>[11:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TSADC_COMP0_INT</name>
          <description>TSADC high temperature level for source 0</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TSADC_COMP_SRC0</name>
              <description>TSADC high temperature level.
TSADC output is bigger than tsadc_comp,    means the temperature
is high.
TSADC_INT will be valid.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TSADC_COMP1_INT</name>
          <description>TSADC high temperature level for source 1</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TSADC_COMP_SRC1</name>
              <description>TSADC high temperature level.
TSADC output is bigger than tsadc_comp,    means the temperature
is high.
TSADC_INT will be valid.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TSADC_COMP0_SHUT</name>
          <description>TSADC high temperature level for source 0</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TSADC_COMP_SRC0</name>
              <description>TSADC high temperature level.
TSADC output is bigger than tsadc_comp,    means the temperature
is too high.
TSHUT will be valid.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TSADC_COMP1_SHUT</name>
          <description>TSADC high temperature level for source 1</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TSADC_COMP_SRC1</name>
              <description>TSADC high temperature level.
TSADC output is bigger than tsadc_comp,    means the temperature
is too high.
TSHUT will be valid.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TSADC_HIGHT_INT_DEBOUNCE</name>
          <description>high temperature debounce</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <resetValue>0x3</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DEBOUNCE</name>
              <description>TSADC controller will only generate interrupt or TSHUT when
temperature is higher than COMP_INT for "debounce" times.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TSADC_HIGHT_TSHUT_DEBOUNCE</name>
          <description>high temperature debounce</description>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <resetValue>0x3</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DEBOUNCE</name>
              <description>TSADC controller will only generate interrupt or TSHUT when
temperature is higher than    COMP_SHUT for "debounce" times.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TSADC_AUTO_PERIOD</name>
          <description>TSADC auto access period</description>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <resetValue>0x10000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AUTO_PERIOD</name>
              <description>when auto mode is enabled, this register controls the interleave
between every two accessing of TSADC.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TSADC_AUTO_PERIOD_HT</name>
          <description>TSADC auto access period when temperature is high</description>
          <addressOffset>0x6c</addressOffset>
          <size>32</size>
          <resetValue>0x10000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AUTO_PERIOD</name>
              <description>This register controls the interleave between every two accessing
of TSADC after the temperature is higher than COMP_SHUT or
COMP_INT</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TSADC_COMP0_LOW_INT</name>
          <description>TSADC low temperature level for source 0</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TSADC_COMP_SRC0</name>
              <description>TSADC low temperature level.
TSADC output is lower than tsadc_comp,    means the temperature
is low.
TSADC_LOW_INT will be valid.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TSADC_COMP1_LOW_INT</name>
          <description>TSADC low temperature level for source 1</description>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TSADC_COMP_SRC1</name>
              <description>TSADC low temperature level.
TSADC output is lower than tsadc_comp,    means the temperature
is low.
TSADC_LOW_INT will be valid.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>ISP0_MMU0</name>
      <version>1.0</version>
      <groupname>MMU</groupname>
      <baseAddress>0xff914000</baseAddress>
      <registers>
        <register>
          <name>MMU_DTE_ADDR</name>
          <description>MMU current page table address</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MMU_DTE_ADDR</name>
              <description>page table address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MMU_STATUS</name>
          <description>MMU status register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x18</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MMU_PAGE_FAULT_BUS_ID</name>
              <description>Index of master responsible for the last page
fault</description>
              <bitRange>[10:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MMU_PAGE_FAULT_IS_WRITE</name>
              <description>The direction of access for last page fault:
0: read
1:write</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MMU_REPLAY_BUFFER_EMPTY</name>
              <description>1&#65306;The MMU replay buffer is empty.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MMU_IDLE</name>
              <description>the MMu is idle when accesses are being
translated and there are no unfinished
translated access. The MMU_IDLE signal only
reports idle when the MMU processor is idle
and accesses are active on the external bus.
Note: the MMU can be idle in page fault mode.
1: MMU is idle</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MMU_STALL_ACTIVE</name>
              <description>MMU stall mode currently enabled. The mode
is enabled by command.
1: MMU is in stall active status</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MMU_PAGE_FAULT_ACTIVE</name>
              <description>MMU page fault mode currently enabled.The
mode is enabled by command
1: page fault is active</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MMU_PAGING_ENABLED</name>
              <description>0: paging is disabled
1: Paging is enabled</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MMU_CMD</name>
          <description>MMU command register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MMU_CMD</name>
              <description>0: MMU_ENABLE_PAGING. enable paging.
1: MMU_DISABLE_PAGING. disable paging.
2: MMU_ENABLE_STALL. turn on stall mode.
3: MMU_DISABLE_STALL. turn off stall mode.
4: MMU_ZAP_CACHE.    zap the entire page
table cache.
5: MMU_PAGE_FAULT_DONE. leave page fault
mode.
6: MMU_FORCE_RESET. reset the mmu.
The MMU_ENABLE_STALL command can
always be issued. Other commands are
ignored unless the MMU is idle or stalled.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MMU_PAGE_FAULT_ADDR</name>
          <description>MMU logic address of last page fault register</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MMU_PAGE_FAULT_ADDR</name>
              <description>address of last page fault</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MMU_ZAP_ONE_LINE</name>
          <description>MMU zap cache line register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MMU_ZAP_ONE_LINE</name>
              <description>address to be invalidated from the page table
cache.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MMU_INT_RAWSTAT</name>
          <description>MMU raw interrupt status register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>READ_BUS_ERROR</name>
              <description>read bus error</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PAGE_FAULT</name>
              <description>page fault</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MMU_INT_CLEAR</name>
          <description>MMU interrupt clear register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>READ_BUS_ERROR_CLEAR</name>
              <description>read bus error interrupt clear. write 1 to this
register can clear read bus error interrupt.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PAGE_FAULT_CLEAR</name>
              <description>page fault interrupt clear, write 1 to this
register can clear page fault interrupt.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MMU_INT_MASK</name>
          <description>MMU interrupt mask register</description>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>READ_BUS_ERROR_INT_EN</name>
              <description>read bus error interrupt enable</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PAGE_FAULT_INT_EN</name>
              <description>page fault interrupt enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MMU_INT_STATUS</name>
          <description>MMU interrupt status register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>READ_BUS_ERROR</name>
              <description>read bus error interrupt</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PAGE_FAULT</name>
              <description>page fault interrupt</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MMU_AUTO_GATING</name>
          <description>clock atuo gating register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MMU_ATUO_GATING</name>
              <description>mmu clock auto gating
when it is 1, the mmu will auto gating itself</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="ISP0_MMU0">
      <name>ISP0_MMU1</name>
      <version>1.0</version>
      <groupname>MMU</groupname>
      <baseAddress>0xff915000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="ISP0_MMU0">
      <name>ISP1_MMU0</name>
      <version>1.0</version>
      <groupname>MMU</groupname>
      <baseAddress>0xff924000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="ISP0_MMU0">
      <name>ISP1_MMU1</name>
      <version>1.0</version>
      <groupname>MMU</groupname>
      <baseAddress>0xff925000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="ISP0_MMU0">
      <name>VOPL_MMU</name>
      <version>1.0</version>
      <groupname>MMU</groupname>
      <baseAddress>0xff8f0300</baseAddress>
    </peripheral>
    <peripheral derivedFrom="ISP0_MMU0">
      <name>VOPB_MMU</name>
      <version>1.0</version>
      <groupname>MMU</groupname>
      <baseAddress>0xff900300</baseAddress>
    </peripheral>
    <peripheral derivedFrom="ISP0_MMU0">
      <name>IEP_MMU</name>
      <version>1.0</version>
      <groupname>MMU</groupname>
      <baseAddress>0xff670800</baseAddress>
    </peripheral>
    <peripheral derivedFrom="ISP0_MMU0">
      <name>HDCP_MMU</name>
      <version>1.0</version>
      <groupname>MMU</groupname>
      <baseAddress>0xff930000</baseAddress>
    </peripheral>
    <peripheral>
      <name>DDRMON</name>
      <version>1.0</version>
      <groupname>DDRMON</groupname>
      <baseAddress>0xff630000</baseAddress>
      <registers>
        <register>
          <name>DDRMON_IP_VERSION</name>
          <description>DDR Monitor IP Version</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>DDRMON_CTRL</name>
          <description>DDR Monitor Control Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x8</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0 can be written by softwar .
When bit 16=0, bit 0 cannot be written by software;
When bit 17=1, bit 1 can be written by software.
When bit 17=0, bit 1 cannot be written by software;
......
When bit 31=1, bit 15 can be written by software.
When bit 31=0, bit 15 cannot be written by software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LPDDR4_EN</name>
              <description>LPDDR4 Mode Enable
1'b1: enable
1'b0: disable</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HARDWARE_EN</name>
              <description>Hardware Mode Enable
1'b1: enable
1'b0: disable</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LPDDR3_EN</name>
              <description>LPDDR3 Mode Monitor Enable
1'b1: enable
1'b0: disable</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SOFTWARE_EN</name>
              <description>Software Mode Enable
1'b1: enable
1'b0: disable</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMER_CNT_EN</name>
              <description>DFI Timer Count Enable
1'b1: enable
1'b0: disable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DDRMON_INT_STATUS</name>
          <description>Interrupt Status</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH1_RD_ADDR_HIT</name>
              <description>This is the interrupt status of channel 1 read address hit the setting
range</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CH1_WR_ADDR_HIT</name>
              <description>This is the interrupt status of channel 1 write address hit the setting
range</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CH0_RD_ADDR_HIT</name>
              <description>This is the interrupt status of channel 0 read address hit the setting
range</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CH0_WR_ADDR_HIT</name>
              <description>This is the interrupt status of channel 0 write address hit the setting
range</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CH1_OVER_INT</name>
              <description>This is the interrupt status of DDR read and write burst number
more than high threshold in channel 0</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CH1_BELOW_INT</name>
              <description>This is the interrupt status of DDR read and write burst number less
than low threshold in channel 0</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CH0_OVER_INT</name>
              <description>This is the interrupt status of DDR read and write burst number
more than high threshold in channel 0</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CH0_BELOW_INT</name>
              <description>This is the interrupt status of DDR read and write burst number less
than low threshold in channel 0</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DDRMON_INT_MASK</name>
          <description>Interrupt mask control</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INT_MASK</name>
              <description>Interrupt mask control, when bit set to 1'b1, the corresponding
interrupt will disable</description>
              <bitRange>[8:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DDRMON_TIMER_COUNT</name>
          <description>The DFI Timer Threshold</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIMER_COUNT</name>
              <description>The DFI timer threshold, the statistics of DDR access only be done
when timer counter is less then this threshold in hardware mode</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DDRMON_FLOOR_NUMBER</name>
          <description>The Low Threshold in the Comparison of DDR Access</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FLOOR_NUMBER</name>
              <description>The low threshold in the comparison of DDR access</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DDRMON_TOP_NUMBER</name>
          <description>The High Threshold in the Comparison of DDR Access</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TOP_NUMBER</name>
              <description>The high threshold in the comparison of DDR access</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DDRMON_CH0_DFI_ACT_NUM</name>
          <description>Channel 0 DFI Active Command Number</description>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH0_DFI_ACT_NUM</name>
              <description>DFI active command number in the statistics range of the channel
0</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DDRMON_CH0_DFI_WR_NUM</name>
          <description>Channel 0 DFI write Command Number</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH0_DFI_WR_NUM</name>
              <description>DFI write command number in the statistics range of the channel 0</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DDRMON_CH0_DFI_RD_NUM</name>
          <description>Channel 0 DFI read Command Number</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH0_DFI_RD_NUM</name>
              <description>DFI read command number in the statistics range of the channel 0</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DDRMON_CH0_COUNT_NUM</name>
          <description>Channel 0 Timer Count Number</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH0_DFI_COUNT_NUM</name>
              <description>Timer count number in the statistics range of the channel 0, the
value should be divided by 2 as actual timer count.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DDRMON_CH0_DFI_ACCESS_NUM</name>
          <description>Channel 0 DFI Read and Write Command Number</description>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH0_DFI_ACCESS_NUM</name>
              <description>DFI read and write command number in the statistics range of the
channel 0</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DDRMON_CH1_DFI_ACT_NUM</name>
          <description>Channel 1 DFI Active Command Number</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH1_DFI_ACT_NUM</name>
              <description>DFI active command number in the statistics range of the channel
1</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DDRMON_CH1_DFI_WR_NUM</name>
          <description>Channel 1 DFI write Command Number</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH1_DFI_WR_NUM</name>
              <description>DFI write command number in the statistics range of the channel 1</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DDRMON_CH1_DFI_RD_NUM</name>
          <description>Channel 1 DFI read Command Number</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH1_DFI_RD_NUM</name>
              <description>DFI read command number in the statistics range of the channel 1</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DDRMON_CH1_COUNT_NUM</name>
          <description>Channel 1 Timer Count Number</description>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH1_DFI_COUNT_NUM</name>
              <description>Timer count number in the statistics range of the channel 1, the
value should be divided by 2 as actual timer count.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DDRMON_CH1_DFI_ACCESS_NUM</name>
          <description>Channel 1 DFI Read and Write Command Number</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH1_DFI_ACCESS_NUM</name>
              <description>DFI read and write command number in the statistics range of the
channel 1</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DDRMON_DDR_IF_CTRL</name>
          <description>DDR interface Control Register</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_ENABLE</name>
              <description>bit0~15 write enable
When bit 16=1, bit 0 can be written by software.
When bit 16=0, bit 0 cannot be written by software;
When bit 17=1, bit 1 can be written by software.
When bit 17=0, bit 1 cannot be written by software;
......
When bit 31=1, bit 15 can be written by software.
When bit 31=0, bit 15 cannot be written by software;</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_MON_EN</name>
              <description>DDR interface and DFI monitor enable
1'b1: enable
1'b0: disable</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CH1_DIRECTION</name>
              <description>Write or read monitor in channel 1 for command statistics
1'b1: read
1'b0: write</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CH0_DIRECTION</name>
              <description>Write or read monitor in channel 0 for command statistics
1'b1: read
1'b0: write</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DDRMON_CH0_WR_START_ADDR</name>
          <description>Channel 0 Write Start Address</description>
          <addressOffset>0x20c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH0_WR_START_ADDR</name>
              <description>Channel 0 write start address for address comparison</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DDRMON_CH0_WR_END_ADDR</name>
          <description>Channel 0 Write End Address</description>
          <addressOffset>0x210</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH0_WR_END_ADDR</name>
              <description>Channel 0 write end address for address comparison</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DDRMON_CH0_RD_START_ADDR</name>
          <description>Channel 0 Read Start Address</description>
          <addressOffset>0x214</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH0_RD_START_ADDR</name>
              <description>Channel 0 read start address for address comparison</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DDRMON_CH0_RD_END_ADDR</name>
          <description>Channel 0 Read End Address</description>
          <addressOffset>0x218</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH0_RD_END_ADDR</name>
              <description>Channel 0 read end address for address comparison</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DDRMON_CH1_WR_START_ADDR</name>
          <description>Channel 1 Write Start Address</description>
          <addressOffset>0x224</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH1_WR_START_ADDR</name>
              <description>Channel 1 write start address for address comparison</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DDRMON_CH1_WR_END_ADDR</name>
          <description>Channel 1 Write End Address</description>
          <addressOffset>0x228</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH1_WR_END_ADDR</name>
              <description>Channel 1 write end address for address comparison</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DDRMON_CH1_RD_START_ADDR</name>
          <description>Channel 1 Read Start Address</description>
          <addressOffset>0x22c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH1_RD_START_ADDR</name>
              <description>Channel 1 read start address for address comparison</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DDRMON_CH1_RD_END_ADDR</name>
          <description>Channel 1 Read End Address</description>
          <addressOffset>0x230</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH1_RD_END_ADDR</name>
              <description>Channel 1 read end address for address comparison</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DDRMON_CH0_DDR_FIFO0_ADDR</name>
          <description>DDR Channel 0 Controller Interface Address FIFO0</description>
          <addressOffset>0x240</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH0_DDR_FIFO0_ADDR</name>
              <description>Channel 0 DDR controller interface address FIFO0</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DDRMON_CH0_DDR_FIFO1_ADDR</name>
          <description>DDR Channel 0 Controller Interface Address FIFO1</description>
          <addressOffset>0x248</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH0_DDR_FIFO1_ADDR</name>
              <description>Channel 0 DDR controller interface address FIFO1</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DDRMON_CH0_DDR_FIFO2_ADDR</name>
          <description>DDR Channel 0 Controller Interface Address FIFO2</description>
          <addressOffset>0x250</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH0_DDR_FIFO2_ADDR</name>
              <description>Channel 0 DDR controller interface address FIFO2</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DDRMON_CH0_DDR_FIFO3_ADDR</name>
          <description>DDR Channel 0 Controller Interface Address FIFO3</description>
          <addressOffset>0x258</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH0_DDR_FIFO3_ADDR</name>
              <description>Channel 0 DDR controller interface address FIFO3</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DDRMON_CH1_DDR_FIFO0_ADDR</name>
          <description>DDR Channel 1 Controller Interface Address FIFO0</description>
          <addressOffset>0x260</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH1_DDR_FIFO0_ADDR</name>
              <description>Channel 1 DDR controller interface address FIFO0</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DDRMON_CH1_DDR_FIFO1_ADDR</name>
          <description>DDR Channel 1 Controller Interface Address FIFO1</description>
          <addressOffset>0x268</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH1_DDR_FIFO1_ADDR</name>
              <description>Channel 1 DDR controller interface address FIFO1</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DDRMON_CH1_DDR_FIFO2_ADDR</name>
          <description>DDR Channel 1 Controller Interface Address FIFO2</description>
          <addressOffset>0x270</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH1_DDR_FIFO2_ADDR</name>
              <description>Channel 1 DDR controller interface address FIFO2</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DDRMON_CH1_DDR_FIFO3_ADDR</name>
          <description>DDR Channel 1 Controller Interface Address FIFO3</description>
          <addressOffset>0x278</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH1_DDR_FIFO3_ADDR</name>
              <description>Channel 1 DDR controller interface address FIFO3</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>I2S0</name>
      <version>1.0</version>
      <groupname>I2S</groupname>
      <baseAddress>0xff880000</baseAddress>
      <registers>
        <register>
          <name>I2S_TXCR</name>
          <description>transmit operation control register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0xf</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RCNT</name>
              <description>right justified counter
(Can be written only when XFER[0] bit is 0.)
Only valid in I2S Right justified format and slave tx mode is
selected.
Start to transmit data RCNT sclk cycles after left channel valid.</description>
              <bitRange>[22:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TCSR</name>
              <description>TX Channel select register
2'b00:two channel
2'b01:four channel
2'b10:six channel
2'b11:eight channel</description>
              <bitRange>[16:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HWT</name>
              <description>Halfword word transform
(Can be written only when XFER[0] bit is 0.)
Only valid when VDW select 16bit data.
0:32 bit data valid from AHB/APB bus. Low 16 bit for left channel
and high 16 bit for right channel.
1:low 16bit data valid from AHB/APB bus, high 16 bit data
invalid.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SJM</name>
              <description>Store justified mode
SJM
Store justified mode
(Can be written only when XFER[1] bit is 0.)
16bit~31bit DATA stored in 32 bits width fifo.
This bit is invalid if VDW select 16bit data and HWT select 0,
Because every fifo unit contain two 16bit data and 32 bit space is
full, it is impossible to choose justified mode.
0:right justified
1:left justified</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FBM</name>
              <description>First Bit Mode
(Can be written only when XFER[0] bit is 0.)
0:MSB
1:LSB</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IBM</name>
              <description>I2S bus mode
(Can be written only when XFER[0] bit is 0.)
0:I2S normal
1:I2S Left justified
2:I2S Right justified
3:reserved</description>
              <bitRange>[10:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PBM</name>
              <description>PCM bus mode
(Can be written only when XFER[0] bit is 0.)
0:PCM no delay mode
1:PCM delay 1 mode
2:PCM delay 2 mode
3:PCM delay 3 mode</description>
              <bitRange>[8:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TFS</name>
              <description>Transfer format select
(Can be written only when XFER[0] bit is 0.)
0: I2S format
1: PCM format</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VDW</name>
              <description>Valid Data width
(Can be written only when XFER[0] bit is 0.)
0~14:reserved
15:16bit
16:17bit
17:18bit
18:19bit
&#8230;&#8230;
n:(n+1)bit
&#8230;&#8230;
28:29bit
29:30bit
30:31bit
31:32bit</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_RXCR</name>
          <description>receive operation control register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0xf</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RCSR</name>
              <description>RX Channel select register
2'b00:two channel
2'b01:four channel
2'b10:six channel
2'b11:eight channel</description>
              <bitRange>[16:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HWT</name>
              <description>Halfword word transform
(Can be written only when XFER[1] bit is 0.)
Only valid when VDW select 16bit data.
0:32 bit data valid to AHB/APB bus. Low 16 bit for left channel
and high 16 bit for right channel.
1:low 16bit data valid to AHB/APB bus, high 16 bit data invalid.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SJM</name>
              <description>Store justified mode
(Can be written only when XFER[1] bit is 0.)
16bit~31bit DATA stored in 32 bits width fifo.
If VDW select 16bit data, this bit is valid only when HWT select
0.Because if HWT is 1, every fifo unit contain two 16bit data and
32 bit space is full, it is impossible to choose justified mode.
0:right justified
1:left justified</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FBM</name>
              <description>First Bit Mode
(Can be written only when XFER[1] bit is 0.)
0:MSB
1:LSB</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IBM</name>
              <description>I2S bus mode
(Can be written only when XFER[1] bit is 0.)
0:I2S normal
1:I2S Left justified
2:I2S Right justified
3:reserved</description>
              <bitRange>[10:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PBM</name>
              <description>PCM bus mode
(Can be written only when XFER[1] bit is 0.)
0:PCM no delay mode
1:PCM delay 1 mode
2:PCM delay 2 mode
3:PCM delay 3 mode</description>
              <bitRange>[8:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TFS</name>
              <description>Transfer format select
(Can be written only when XFER[1] bit is 0.)
0:i2s
1:pcm</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VDW</name>
              <description>Valid Data width
(Can be written only when XFER[1] bit is 0.)
0~14:reserved
15:16bit
16:17bit
17:18bit
18:19bit
&#8230;&#8230;
n:(n+1)bit
&#8230;&#8230;
28:29bit
29:30bit
30:31bit
31:32bit</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_CKR</name>
          <description>clock generation register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x71f1f</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TRCM</name>
              <description>Tx and Rx Common Use
2'b00/2'b11:tx_lrck/rx_lrck are used as synchronous signal for
TX /RX respectively.
2'b01:only tx_lrck is used as synchronous signal for TX and RX.
2'b10:only rx_lrck is used as synchronous signal for TX and RX.</description>
              <bitRange>[29:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MSS</name>
              <description>Master/slave mode select
(Can be written only when XFER[1] or XFER[0] bit is 0.)
0:master mode(sclk output)
1:slave mode(sclk input)</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CKP</name>
              <description>Sclk polarity
(Can be written only when XFER[1] or XFER[0] bit is 0.)
0: sample data at posedge sclk and drive data at negedge sclk
1: sample data at negedge sclk and drive data at posedge sclk</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RLP</name>
              <description>Receive lrck polarity
(Can be written only when XFER[1] or XFER[0] bit is 0.)
0:normal polarity
(I2S normal: low for left channel, high for right channel
I2S left/right just: high for left channel, low for right channel
PCM start signal: high valid)
1:oppsite polarity
(I2S normal: high for left channel, low for right channel
I2S left/right just: low for left channel, high for right channel
PCM start signal: low valid)</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TLP</name>
              <description>Transmit lrck polarity
(Can be written only when XFER[1] or XFER[0] bit is 0.)
0:normal polarity
(I2S normal: low for left channel, high for right channel
I2S left/right just: high for left channel, low for right channel
PCM start signal: high valid)
1:oppsite polarity
(I2S normal: high for left channel, low for right channel
I2S left/right just: low for left channel, high for right channel
PCM start signal: low valid)</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MDIV</name>
              <description>mclk divider
(Can be written only when XFER[1] or XFER[0] bit is 0.)
Serial Clock Divider = Fmclk / Ftxsclk-1.(mclk frequecy / txsclk
frequecy-1)
0      :Fmclk=Ftxsclk;
1      :Fmclk=2*Ftxsclk;
2,3    :Fmclk=4*Ftxsclk;
4,5    :Fmclk=6*Ftxsclk;
&#8230;&#8230;
2n,2n+1:Fmclk=(2n+2)*Ftxsclk;
&#8230;&#8230;
60,61:Fmclk=62*Ftxsclk;
62,63:Fmclk=64*Ftxsclk;
&#8230;&#8230;
252,253:Fmclk=254*Ftxsclk;
254,255:Fmclk=256*Ftxsclk;</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSD</name>
              <description>Receive sclk divider
(Can be written only when XFER[1] or XFER[0] bit is 0.)
Receive sclk divider= Fsclk/Frxlrck
0~30:reserved
31:    32fs
32:    33fs
33:    34fs
34:    35fs
&#8230;&#8230;
n:    (n+1)fs
&#8230;&#8230;
253:      254fs
254:      255fs
255:      256fs</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TSD</name>
              <description>Transmit sclk divider
(Can be written only when XFER[1] or XFER[0] bit is 0.)
Transmit sclk divider=Ftxsclk/Ftxlrck
0~30:reserved
31:    32fs
32:    33fs
33:    34fs
34:    35fs
&#8230;&#8230;
n:    (n+1)fs
&#8230;&#8230;
253:      254fs
254:      255fs
255:      256fs</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_TXFIFOLR</name>
          <description>TX FIFO level register</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TFL3</name>
              <description>Transmit FIFO3 Level
Contains the number of valid data entries in the transmit FIFO3.</description>
              <bitRange>[23:18]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TFL2</name>
              <description>Transmit FIFO2 Level
Contains the number of valid data entries in the transmit FIFO2.</description>
              <bitRange>[17:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TFL1</name>
              <description>Transmit FIFO1 Level
Contains the number of valid data entries in the transmit FIFO1.</description>
              <bitRange>[11:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TFL0</name>
              <description>Transmit FIFO0 Level
Contains the number of valid data entries in the transmit FIFO0.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_DMACR</name>
          <description>DMA control register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x1f0000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDE</name>
              <description>Receive DMA Enable
0 : Receive DMA disabled
1 : Receive DMA enabled</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RDL</name>
              <description>Receive Data Level
This bit field controls the level at which a DMA request is made
by the receive logic. The watermark level = DMARDL+1; that is,
dma_rx_req is generated when the number of valid data entries
in the receive FIFO (RXFIFO0 if RCSR=00;RXFIFO1 if
RCSR=01,RXFIFO2 if RCSR=10,RXFIFO3 if RCSR=11)is equal to
or above this field value + 1.</description>
              <bitRange>[20:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TDE</name>
              <description>Transmit DMA Enable
0 : Transmit DMA disabled
1 : Transmit DMA enabled</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TDL</name>
              <description>Transmit Data Level
This bit field controls the level at which a DMA request is made by
the transmit logic. It is equal to the watermark level; that is, the
dma_tx_req signal is generated when the number of valid data
entries in the TXFIFO(TXFIFO0 if TCSR=00;TXFIFO1 if
TCSR=01,TXFIFO2 if TCSR=10,TXFIFO3 if TCSR=11)is equal to
or below this field value.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_INTCR</name>
          <description>interrupt control register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RFT</name>
              <description>Receive FIFO Threshold
When the number of receive FIFO entries    (RXFIFO0 if RCSR=00;
RXFIFO1 if RCSR=01, RXFIFO2 if RCSR=10, RXFIFO3 if
RCSR=11) is more than or equal to this threshold plus 1, the
receive FIFO full interrupt is triggered.</description>
              <bitRange>[24:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RXOIC</name>
              <description>RX overrun interrupt clear
Write 1 to clear RX overrun interrupt.</description>
              <bitRange>[18:18]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>RXOIE</name>
              <description>RX overrun interrupt enable
0:disable
1:enable</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RXFIE</name>
              <description>RX full interrupt enable
0:disable
1:enable</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TFT</name>
              <description>Transmit FIFO Threshold
When the number of transmit FIFO (TXFIFO0 if TCSR=00;
TXFIFO1 if TCSR=01, TXFIFO2 if TCSR=10, TXFIFO3 if TCSR=11)
entries is less than or equal to this threshold, the transmit FIFO
empty interrupt is triggered.</description>
              <bitRange>[8:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TXUIC</name>
              <description>TX underrun interrupt clear
Write 1 to clear TX underrun interrupt.</description>
              <bitRange>[2:2]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>TXUIE</name>
              <description>TX underrun interrupt enable
0:disable
1:enable</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TXEIE</name>
              <description>TX empty interrupt enable
0:disable
1:enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_INTSR</name>
          <description>interrupt status register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXOI</name>
              <description>RX overrun interrupt
0:inactive
1:active</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RXFI</name>
              <description>RX full interrupt
0:inactive
1:active</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TXUI</name>
              <description>TX underrun interrupt
0:inactive
1:active</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TXEI</name>
              <description>TX empty interrupt
0:inactive
1:active</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_XFER</name>
          <description>Transfer Start Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXS</name>
              <description>RX Transfer start bit
0:stop RX transfer.
1:start RX transfer</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TXS</name>
              <description>TX Transfer start bit
0:stop TX transfer.
1:start TX transfer</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_CLR</name>
          <description>SCLK domain logic clear Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXC</name>
              <description>RX logic clear
This is a self cleared bit. Write 1 to clear all receive logic.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TXC</name>
              <description>TX logic clear
This is a self cleared bit. Write 1 to clear all transmit logic.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_TXDR</name>
          <description>Transmit FIFO Data Register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXDR</name>
              <description>Transmit FIFO Data Register
When it is written to, data are moved into the transmit FIFO.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_RXDR</name>
          <description>Receive FIFO Data Register</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXDR</name>
              <description>Receive FIFO Data Register
When the register is read, data in the receive FIFO is accessed.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_RXFIFOLR</name>
          <description>RX FIFO level register</description>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RFL3</name>
              <description>Receive FIFO3 Level
Contains the number of valid data entries in the receive FIFO3.</description>
              <bitRange>[23:18]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RFL2</name>
              <description>Receive FIFO2 Level
Contains the number of valid data entries in the receive FIFO2.</description>
              <bitRange>[17:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RFL1</name>
              <description>Receive FIFO1 Level
Contains the number of valid data entries in the receive FIFO1.</description>
              <bitRange>[11:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RFL0</name>
              <description>Receive FIFO0 Level
Contains the number of valid data entries in the receive FIFO0.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="I2S0">
      <name>I2S1</name>
      <version>1.0</version>
      <groupname>I2S</groupname>
      <baseAddress>0xff890000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="I2S0">
      <name>I2S2</name>
      <version>1.0</version>
      <groupname>I2S</groupname>
      <baseAddress>0xff8a0000</baseAddress>
    </peripheral>
    <peripheral>
      <name>SDMMC</name>
      <version>1.0</version>
      <groupname>SDMMC</groupname>
      <baseAddress>0xfe320000</baseAddress>
      <registers>
        <register>
          <name>SDMMC_CTRL</name>
          <description>Control register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x1000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>USE_INTERNAL_DMAC</name>
              <description>Present only for the Internal DMAC configuration; else, it is
reserved.
0: The host performs data transfers through the slave interface
1: Internal DMAC used for data transfe</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CEATA_DEVICE_INTERRUPT_STATUS</name>
              <description>0: Interrupts not enabled in CE-ATA device (nIEN = 1 in ATA
control register)
1: Interrupts are enabled in CE-ATA device (nIEN = 0 in ATA
control register)
Software should appropriately write to this bit after power-on
reset or any other reset to CE-ATA device. After reset, usually
CE-ATA device interrupt is disabled (nIEN = 1). If the host
enables CE-ATA device interrupt, then software should set this
bit.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SEND_AUTO_STOP_CCSD</name>
              <description>0: Clear bit if Mobile Storage Host Controller does not reset the
bit.
1: Send internally generated STOP after sending CCSD to CE-ATA
device.
NOTE: Always set send_auto_stop_ccsd and send_ccsd bits
together send_auto_stop_ccsd should not be set independent of
send_ccsd.
When set, Mobile Storage Host Controller automatically sends
internally- generated STOP command (CMD12) to CE-ATA device.
After sending internally-generated STOP command, Auto
Command Done (ACD) in RINTSTS is set and generates interrupt
to host if Auto Command Done interrupt is not masked. After
sending the CCSD, Mobile Storage Host Controller automatically
clears send_auto_stop_ccsd bit.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SEND_CCSD</name>
              <description>0: Clear bit if Mobile Storage Host Controller does not reset the
bit.
1: Send Command Completion Signal Disable (CCSD) to CE-ATA
device
When set, Mobile Storage Host Controller sends CCSD to CE-ATA
device. Software sets this bit only if current command is
expecting CCS (that is, RW_BLK) and interrupts are enabled in
CE-ATA device. Once the CCSD pattern is sent to device, Mobile
Storage Host Controller automatically clears send_ccsd bit. It also
sets Command Done (CD) bit in RINTSTS register and generates
interrupt to host if Command Done interrupt is not masked.
NOTE: Once send_ccsd bit is set, it takes two card clock cycles to
drive the CCSD on the CMD line. Due to this, during the boundary
conditions it may happen that CCSD is sent to the CE-ATA device,
even if the device signalled CCS</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ABORT_READ_DATA</name>
              <description>0: no change
1: after suspend command is issued during read-transfer,
software polls card to find when suspend happened. Once
suspend occurs, software sets bit to reset data state-machine,
which is waiting for next block of data. Bit automatically clears
once data state machine resets to idle.
Used in SDIO card suspend sequence.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SEND_IRQ_RESPONSE</name>
              <description>0: no change
1: send auto IRQ response
Bit automatically clears once response is sent.
To wait for MMC card interrupts, host issues CMD40, and SDMMC
Controller waits for interrupt response from MMC card(s). In
meantime, if host wants SDMMC Controller to exit waiting for
interrupt state, it can set this bit, at which time SDMMC
Controller command state-machine sends CMD40 response on
bus and returns to idle state.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>READ_WAIT</name>
              <description>0: clear read wait
1: assert read wait
For sending read-wait to SDIO cards</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_ENABLE</name>
              <description>0: disable DMA transfer mode
1: enable DMA transfer mode
Even when DMA mode is enabled, host can still push/pop data
into or from FIFO; this should not happen during the normal
operation. If there is simultaneous FIFO access from host/DMA,
the data coherency is lost. Also, there is no arbitration inside
SDMMC Controller to prioritize simultaneous host/DMA access.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT_ENABLE</name>
              <description>Global interrupt enable/disable bit:
0: disable interrupts
1: enable interrupts
The int port is 1 only when this bit is 1 and one or more
unmasked interrupts are set.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_RESET</name>
              <description>0: no change
1: reset internal DMA interface control logic
To reset DMA interface, firmware should set bit to 1. This bit is
auto-cleared after two AHB clocks.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>FIFO_RESET</name>
              <description>0: no change
1: reset to data FIFO To reset FIFO pointers
To reset FIFO, firmware should set bit to 1. This bit is auto-
cleared after completion of reset operation</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>CONTROLLER_RESET</name>
              <description>0: no change
1: reset SDMMC controller
To reset controller, firmware should set bit to 1. This bit is auto-
cleared after two AHB and two cclk_in clock cycles.
This resets:
a. BIU/CIU interface
b. CIU and state machines
c. abort_read_data, send_irq_response, and read_wait bits of
Control register
d. start_cmd bit of Command register
Does not affect any registers or DMA interface, or FIFO or host
interrupts</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_PWREN</name>
          <description>Power-enable register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>POWER_ENABLE</name>
              <description>Power on/off switch for the card.
Once power is turned on, firmware should wait for
regulator/switch ramp-up time before trying to initialize card.
0: power off
1: power on
Bit values output to card_power_en port.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_CLKDIV</name>
          <description>Clock-divider register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLK_DIVIDER0</name>
              <description>Clock divider-0 value. Clock division is 2*n.
For example, value of 0 means divide by 2*0 = 0 (no division,
bypass), value of 1 means divide by 2*1 = 2, value of "ff"means
divide by 2*255 = 510, and so on</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_CLKSRC</name>
          <description>SD clock source register</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLK_SOURCE</name>
              <description>Clock divider source for up to 16 SD cards supported. Each card
has two bits assigned to it. For example, bits[1:0] assigned for
card-0, which maps and internally routes clock divider[3:0]
outputs to cclk_out[15:0] pins, depending on bit value.
00: Clock divider 0
The cclk_out is always from clock divider 0, and this register is
not implemented.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_CLKENA</name>
          <description>Clock-enable register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CCLK_LOW_POWER</name>
              <description>Low-power control for SD card clock and MMC card clock
supported.
0: non-low-power mode
1: low-power mode; stop clock when card in IDLE (should be
normally set to only MMC and SD memory cards; for SDIO cards,
if interrupts must be detected, clock should not be stopped).</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CCLK_ENABLE</name>
              <description>Clock-enable control for SD card clock and MMC card clock
supported.
0: clock disabled
1: clock enabled</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_TMOUT</name>
          <description>Time-out register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0xffffff40</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA_TIMEOUT</name>
              <description>Value for card Data Read Timeout; same value also used for Data
Starvation by Host timeout.
Value is in number of card output clocks cclk_out of selected
card.
Note: The software timer should be used if the timeout value is in
the order of 100 ms. In this case, read data timeout interrupt
needs to be disabled.</description>
              <bitRange>[31:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESPONSE_TIMEOUT</name>
              <description>Response timeout value.
Value is in number of card output clocks &#8211;cclk_out.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_CTYPE</name>
          <description>Card-type register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CARD_WIDTH_8</name>
              <description>Indicates if card is 8-bit:
0: non 8-bit mode
1: 8-bit mode</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CARD_WIDTH</name>
              <description>Indicates if card is 1-bit or 4-bit:
0: 1-bit mode
1: 4-bit mode</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_BLKSIZ</name>
          <description>Block-size register</description>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <resetValue>0x200</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BLOCK_SIZE</name>
              <description>Block size</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_BYTCNT</name>
          <description>Byte-count register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x200</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BYTE_COUNT</name>
              <description>Number of bytes to be transferred; should be integer multiple of
Block Size for block transfers.
For undefined number of byte transfers, byte count should be set
to 0. When byte count is set to 0, it is responsibility of host to
explicitly send stop/abort command to terminate data transfer.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_INTMASK</name>
          <description>Interrupt-mask register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SDIO_INT_MASK</name>
              <description>Mask SDIO interrupts.
When masked, SDIO interrupt detection for that card is disabled.
A 0 masks an interrupt, and 1 enables an interrupt.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_NOBUSY_INT_MASK</name>
              <description>0: data no busy interrupt not masked
1: data no busy interrupt masked</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT_MASK</name>
              <description>Bits used to mask unwanted interrupts. Value of 0 masks
interrupt; value of 1 enables interrupt.
[15]: End-bit error (read)/Write no CRC (EBE)
[14]: Auto command done (ACD)
[13]: Start-bit error (SBE)
[12]: Hardware locked write error (HLE)
[11]: FIFO underrun/overrun error (FRUN)
[10]: Data starvation-by-host timeout (HTO) /Volt_switch_int
[9]: Data read timeout (DRTO)
[8]: Response timeout (RTO)
[7]: Data CRC error (DCRC)
[6]: Response CRC error (RCRC)
[5]: Receive FIFO data request (RXDR)
[4]: Transmit FIFO data request (TXDR)
[3]: Data transfer over (DTO)
[2]: Command done (CD)
[1]: Response error (RE)
[0]: Card detect (CD)</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_CMDARG</name>
          <description>Command-argument register</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMD_ARG</name>
              <description>Value indicates command argument to be passed to card.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_CMD</name>
          <description>Command register</description>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>START_CMD</name>
              <description>Start command. Once command is taken by CIU, bit is cleared.
When bit is set, host should not attempt to write to any command
registers. If write is attempted, hardware lock error is set in raw
interrupt register.
Once command is sent and response is received from SD_MMC
cards, Command Done bit is set in raw interrupt register.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>USE_HOLD_REG</name>
              <description>Use Hold Register
0: CMD and DATA sent to card bypassing HOLD Register
1: CMD and DATA sent to card through the HOLD Register
Note:
a. Set to 1'b1 for SDR12 and SDR25 (with non-zero phase-shifted
cclk_in_drv); zero phase shift is not allowed in these modes.
b. Set to 1'b0 for SDR50, SDR104, and DDR50 (with zero phase-
shifted cclk_in_drv).
c. Set to 1'b1 for SDR50, SDR104, and DDR50 (with non-zero
phase-shifted cclk_in_drv).</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VOLT_SWITCH</name>
              <description>Voltage switch bit.
0: no voltage switching
1: voltage switching enabled; must be set for CMD11 only</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BOOT_MODE</name>
              <description>Boot Mode.
0: mandatory Boot operation
1: alternate Boot operation</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DISABLE_BOOT</name>
              <description>Disable Boot. When software sets this bit along with start_cmd,
CIU terminates the boot operation. Do NOT set disable_boot and
enable_boot together.</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EXPECT_BOOT_ACK</name>
              <description>Expect Boot Acknowledge. When Software sets this bit along with
enable_boot, CIU expects a boot acknowledge start pattern of 0-
1-0 from the selected card.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE_BOOT</name>
              <description>Enable Boot&#8212;this bit should be set only for mandatory boot
mode.When Software sets this bit along with start_cmd, CIU
starts the boot sequence for the corresponding card by asserting
the CMD line low. Do NOT set disable_boot and enable_boot
together.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CCS_EXPECTED</name>
              <description>0: Interrupts are not enabled in CE-ATA device (nIEN = 1 in    ATA
control register), or command does not expect CCS    from device
1: Interrupts are enabled in CE-ATA device (nIEN = 0), and
RW_BLK command expects command completion signal from CE-
ATA device.
If the command expects Command Completion Signal (CCS) from
the CE-ATA device, the software should set this control bit.
Mobile Storage Host Controller sets Data Transfer Over (DTO) bit
in RINTSTS register and generates interrupt to host if Data
Transfer Over interrupt is not masked.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>READ_CEATA_DEVICE</name>
              <description>0: Host is not performing read access (RW_REG or RW_BLK)
towards CE-ATA device
1: Host is performing read access (RW_REG or RW_BLK)
towards CE-ATA device
Software should set this bit to indicate that CE-ATA device is
being accessed for read transfer. This bit is used to disable read
data timeout indication while performing CE-ATA read transfers.
Maximum value of I/O transmission delay can be no less than 10
seconds. Mobile Storage Host Controller should not indicate read
data timeout while waiting for data from CE-ATA device.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UPDATE_CLOCK_REGISTERS_ONLY</name>
              <description>0: normal command sequence
1: do not send commands, just update clock register value into
card clock domain
Following register values transferred into card clock domain:
CLKDIV, CLRSRC, CLKENA.
Changes card clocks (change frequency, truncate off or on, and
set low-frequency mode); provided in order to change clock
frequency or stop clock without having to send command to
cards.
During normal command sequence, when
update_clock_registers_only = 0, following control registers are
transferred from BIU to CIU:    CMD, CMDARG, TMOUT, CTYPE,
BLKSIZ, BYTCNT. CIU uses new register values for new command
sequence to card.
When bit is set, there are no Command Done interrupts because
no command is sent to SD_MMC_CEATA cards.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SEND_INITIALIZATION</name>
              <description>0: do not send initialization sequence (80 clocks of 1) before
sending this command
1: send initialization sequence before sending this command
After power on, 80 clocks must be sent to card for initialization
before sending any commands to card. Bit should be set while
sending first command to card so that controller will initialize
clocks before sending command to card. This bit should not be
set for either of the boot modes (alternate or mandatory).</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STOP_ABORT_CMD</name>
              <description>0: neither stop nor abort command to stop current data transfer
in progress. If abort is sent to function-number currently selected
or not in data-transfer mode, then bit should be set to 0.
1: stop or abort command intended to stop current data transfer
in progress.
When open-ended or predefined data transfer is in progress, and
host issues stop or abort command to stop data transfer, bit
should be set so that command/data state-machines of CIU can
return correctly to idle state. This is also applicable for Boot mode
transfers. To Abort boot mode, this bit should be set along with
CMD[26] = disable_boot.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WAIT_PRVDATA_COMPLETE</name>
              <description>0: send command at once, even if previous data transfer has not
completed
1: wait for previous data transfer completion before sending
command
The wait_prvdata_complete = 0 option typically used to query
status of card during data transfer or to stop current data
transfer; card_number should be same as in previous command.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SEND_AUTO_STOP</name>
              <description>0: no stop command sent at end of data transfer
1: send stop command at end of data transfer
When set, SDMMC Controller sends stop command to SD_MMC
cards at end of data transfer.
a. when send_auto_stop bit should be set, since some data
transfers do not need explicit stop commands
b. open-ended transfers that software should explicitly send to
stop command
Additionally, when "resume" is sent to resume &#8211;suspended
memory access of SD-Combo card &#8211;bit should be set correctly if
suspended data transfer needs send_auto_stop.
Don't care if no data expected from card.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TRANSFER_MODE</name>
              <description>0: block data transfer command
1: stream data transfer command
Don't care if no data expected.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WR</name>
              <description>0: read from card
1: write to card
Don't care if no data expected from card.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_EXPECTED</name>
              <description>0: no data transfer expected (read/write)
1: data transfer expected (read/write)</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CHECK_RESPONSE_CRC</name>
              <description>0: do not check response CRC
1: check response CRC
Some of command responses do not return valid CRC bits.
Software should disable CRC checks for those commands in order
to disable CRC checking by controller</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESPONSE_LENGTH</name>
              <description>0: short response expected from card
1: long response expected from card</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESPONSE_EXPECT</name>
              <description>0: no response expected from card
1: response expected from card</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMD_INDEX</name>
              <description>Command index</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_RESP0</name>
          <description>Response-0 register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RESPONSE0</name>
              <description>Bit[31:0] of response</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_RESP1</name>
          <description>Response-1 register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RESPONSE</name>
              <description>Register represents bit[63:32] of long response.
When CIU sends auto-stop command, then response is saved in
register. Response for previous command sent by host is still
preserved in Response 0 register. Additional auto-stop issued
only for data transfer commands, and response type is always
"short" for them.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_RESP2</name>
          <description>Response-2 register</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RESPONSE2</name>
              <description>Bit[95:64] of long response</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_RESP3</name>
          <description>Response-3 register</description>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RESPONSE3</name>
              <description>Bit[127:96] of long response</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_MINTSTS</name>
          <description>Masked interrupt-status register</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SDIO_INTERRUPT</name>
              <description>Interrupt from SDIO card; SDIO interrupt for card enabled only if
corresponding sdio_int_mask bit is set in Interrupt mask register
(mask bit 1 enables interrupt; 0 masks interrupt).
0: no SDIO interrupt from card
1: SDIO interrupt from card</description>
              <bitRange>[24:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DATA_NOBUSY_INT_STATUS</name>
              <description>Data no busy Interrupt Status</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT_STATUS</name>
              <description>Interrupt enabled only if corresponding bit in interrupt mask
register is set.
[15]: End-bit error (read)/Write no CRC (EBE)
[14]: Auto command done (ACD)
[13]: Start-bit error (SBE)
[12]: Hardware locked write error (HLE)
[11]: FIFO underrun/overrun error (FRUN)
[10]: Data starvation-by-host timeout (HTO) /Volt_switch_int
[9]: Data read timeout (DRTO)
[8]: Response timeout (RTO)
[7]: Data CRC error (DCRC)
[6]: Response CRC error (RCRC)
[5]: Receive FIFO data request (RXDR)
[4]: Transmit FIFO data request (TXDR)
[3]: Data transfer over (DTO)
[2]: Command done (CD)
[1]: Response error (RE)
[0]: Card detect (CD)</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_RINTSTS</name>
          <description>Raw interrupt-status register</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SDIO_INTERRUPT</name>
              <description>Interrupt from SDIO card; Writes to these bits clear them. Value
of 1 clears bit and 0 leaves bit intact.
0: no SDIO interrupt from card
1: SDIO interrupt from card</description>
              <bitRange>[24:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DATA_NOBUSY_INT_STATUS</name>
              <description>Data no busy interrupt status</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT_STATUS</name>
              <description>Writes to bits clear status bit. Value of 1 clears status bit, and
value of 0 leaves bit intact. Bits are logged regardless of interrupt
mask status.
[15]: End-bit error (read)/Write no CRC (EBE)
[14]: Auto command done (ACD)
[13]: Start-bit error (SBE)
[12]: Hardware locked write error (HLE)
[11]: FIFO underrun/overrun error (FRUN)
[10]: Data starvation-by-host timeout (HTO) /Volt_switch_int
[9]: Data read timeout (DRTO)
[8]: Response timeout (RTO)
[7]: Data CRC error (DCRC)
[6]: Response CRC error (RCRC)
[5]: Receive FIFO data request (RXDR)
[4]: Transmit FIFO data request (TXDR)
[3]: Data transfer over (DTO)
[2]: Command done (CD)
[1]: Response error (RE)
[0]: Card detect (CD)</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_STATUS</name>
          <description>Status register</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <resetValue>0x406</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMA_REQ</name>
              <description>DMA request signal state</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DMA_ACK</name>
              <description>DMA acknowledge signal state</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FIFO_COUNT</name>
              <description>Number of filled locations in FIFO</description>
              <bitRange>[29:17]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RESPONSE_INDEX</name>
              <description>Index of previous response, including any auto-stop sent by core</description>
              <bitRange>[16:11]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DATA_STATE_MC_BUSY</name>
              <description>Data transmit or receive state-machine is busy</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DATA_BUSY</name>
              <description>Inverted version of raw selected card_data[0]
0: card data not busy
1: card data busy
default value is 1 or 0 depending on cdata_in</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DATA_3_STATUS</name>
              <description>Raw selected card_data[3]; checks whether card is present
0: card not present
1: card present
default value is 1 or 0 depending on cdata_in</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>COMMAND_FSM_STATES</name>
              <description>Command FSM states:
0: idle
1: send init sequence
2: Tx cmd start bit
3: Tx cmd tx bit
4: Tx cmd index + arg
5: Tx cmd crc7
6: Tx cmd end bit
7: Rx resp start bit
8: Rx resp IRQ response
9: Rx resp tx bit
10: Rx resp cmd idx
11: Rx resp data
12: Rx resp crc7
13: Rx resp end bit
14: Cmd path wait NCC
15: Wait; CMD-to-response turnaround
The command FSM state is represented using 19 bits.
The STATUS Register[7:4] has 4 bits to represent the command
FSM states. Using these 4 bits, only 16 states can be
represented. Thus three states cannot be represented in the
STATUS[7:4] register. The three states that are not represented
in the STATUS Register[7:4] are:
a. Bit 16 &#8211;Wait for CCS
b. Bit 17 &#8211;Send CCSD
c. Bit 18 &#8211;Boot Mode
Due to this, while command FSM is in "Wait for CCS state" or
"Send CCSD" or "Boot Mode", the Status register indicates status
as 0 for the bit field [7:4].</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FIFO_FULL</name>
              <description>FIFO is full status</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FIFO_EMPTY</name>
              <description>FIFO is empty status</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FIFO_TX_WATERMARK</name>
              <description>FIFO reached Transmit watermark level; not qualified with data
transfer</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FIFO_RX_WATERMARK</name>
              <description>FIFO reached Receive watermark level; not qualified with data
transfer</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_FIFOTH</name>
          <description>FIFO threshold register</description>
          <addressOffset>0x4c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMA_MUTIPLE_TRANSACTION_SIZE</name>
              <description>Burst size of multiple transaction; should be programmed same
as DMA controller multiple-transaction-size SRC/DEST_MSIZE.
0: 1 transfers
1: 4
2: 8
3: 16
4: 32
5: 64
6: 128
7: 256
The unit for transfer is the H_DATA_WIDTH parameter. A single
transfer (dw_dma_single assertion in case of Non DW DMA
interface) would be signalled based on this value.
Value should be sub-multiple of (RX_WMark + 1)*
(F_DATA_WIDTH/H_DATA_WIDTH) and (FIFO_DEPTH -
TX_WMark)* (F_DATA_WIDTH/ H_DATA_WIDTH)
For example, if FIFO_DEPTH = 16, FDATA_WIDTH ==
H_DATA_WIDTH
Allowed combinations for MSize and TX_WMark are:
MSize = 1, TX_WMARK = 1-15
MSize = 4, TX_WMark = 8
MSize = 4, TX_WMark = 4
MSize = 4, TX_WMark = 12
MSize = 8, TX_WMark = 8
MSize = 8, TX_WMark = 4
Allowed combinations for MSize and RX_WMark are:
MSize = 1, RX_WMARK = 0-14
MSize = 4, RX_WMark = 3
MSize = 4, RX_WMark = 7
MSize = 4, RX_WMark = 11
MSize = 8, RX_WMark = 7
Recommended:
MSize = 8, TX_WMark = 8, RX_WMark = 7</description>
              <bitRange>[30:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_WMARK</name>
              <description>FIFO threshold watermark level when receiving data to card.
When FIFO data count reaches greater than this number,
DMA/FIFO request is raised. During end of packet, request is
generated regardless of threshold programming in order to
complete any remaining data.
In non-DMA mode, when receiver FIFO threshold (RXDR)
interrupt is enabled, then interrupt is generated instead of DMA
request. During end of packet, interrupt is not generated if
threshold programming is larger than any remaining data. It is
responsibility of host to read remaining bytes on seeing Data
Transfer Done interrupt.
In DMA mode, at end of packet, even if remaining bytes are less
than threshold, DMA request does single transfers to flush out
any remaining bytes before Data Transfer Done interrupt is set.
12 bits-1 bit less than FIFO-count of status register, which is 13
bits.
Limitation: RX_WMark &lt;= FIFO_DEPTH-2
Recommended: (FIFO_DEPTH/2) - 1; (means greater than
(FIFO_DEPTH/2) - 1)</description>
              <bitRange>[27:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_WMARK</name>
              <description>FIFO threshold watermark level when transmitting data to card.
When FIFO data count is less than or equal to this number,
DMA/FIFO request is raised. If Interrupt is enabled, then interrupt
occurs. During end of packet, request or interrupt is generated,
regardless of threshold programming.
In non-DMA mode, when transmit FIFO threshold (TXDR)
interrupt is enabled, then interrupt is generated instead of DMA
request. During end of packet, on last interrupt, host is
responsible for filling FIFO with only required remaining bytes
(not before FIFO is full or after CIU completes data transfers,
because FIFO may not be empty).
In DMA mode, at end of packet, if last transfer is less than burst
size, DMA controller does single cycles until required bytes are
transferred.
12 bits -1 bit less than FIFO-count of status register, which is 13
bits.
Limitation: TX_WMark &gt;= 1;
Recommended: FIFO_DEPTH/2; (means less than or equal to
FIFO_DEPTH/2)</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_CDETECT</name>
          <description>Card-detect register</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CARD_DETECT_N</name>
              <description>Value on card_detect_n input ports; read-only bits. 0 represents
presence of card.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_WRTPRT</name>
          <description>Write-protect register</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_PROTECT</name>
              <description>Value on card_write_prt input port. 1 represents write protection.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_TCBCNT</name>
          <description>Transferred CIU card byte count</description>
          <addressOffset>0x5c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TRANS_CARD_BYTE_COUNT</name>
              <description>Number of bytes transferred by CIU unit to card.
In 32-bit or 64-bit AMBA data-bus-width modes, register should
be accessed in full to avoid read-coherency problems. In 16-bit
AMBA data-bus-width mode, internal 16-bit coherency register is
implemented. User should first read lower 16 bits and then higher
16 bits. When reading lower 16 bits, higher 16 bits of counter are
stored in temporary register. When higher 16 bits are read, data
from temporary register is supplied.
Both TCBCNT and TBBCNT share same coherency register.
When AREA_OPTIMIZED parameter is 1, register should be read
only after data transfer completes; during data transfer, register
returns 0.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_TBBCNT</name>
          <description>Transferred host/DMA to/from BIU-FIFO byte count</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TRANS_FIFO_BYTE_COUNT</name>
              <description>Number of bytes transferred between Host/DMA memory and BIU
FIFO.
In 32-bit or 64-bit AMBA data-bus-width modes, register should
be accessed in full to avoid read-coherency problems. In 16-bit
AMBA data-bus-width mode, internal 16-bit coherency register is
implemented. User should first read lower 16 bits and then higher
16 bits. When reading lower 16 bits, higher 16 bits of counter are
stored in temporary register. When higher 16 bits are read, data
from temporary register is supplied.
Both TCBCNT and TBBCNT share same coherency register.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_DEBNCE</name>
          <description>Card detect debounce register</description>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <resetValue>0xffffff</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DEBOUNCE_COUNT</name>
              <description>Number of host clocks (clk) used by debounce filter logic; typical
debounce time is 5-25 ms.</description>
              <bitRange>[23:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_USRID</name>
          <description>User ID register</description>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <resetValue>0x7967797</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>USRID</name>
              <description>User identification register.
The default value is determined by Configuration Value.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_VERID</name>
          <description>Version ID register</description>
          <addressOffset>0x6c</addressOffset>
          <size>32</size>
          <resetValue>0x5342270a</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VERID</name>
              <description>Version identification register; register value is hard-wired. Can
be read by firmware to support different versions of core.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_HCON</name>
          <description>Hardware configuration register</description>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HCON</name>
              <description>Configuration Dependent.
Hardware configurations selected by user before synthesizing
core. Register values can be used to develop configuration-
independent software drivers.
[0]: CARD_TYPE
0: MMC_ONLY
1: SD_MMC
[5:1]: NUM_CARDS - 1
[6]: H_BUS_TYPE
0: APB
1: AHB
[9:7]: H_DATA_WIDTH
0: 16 bits
1: 32 bits
2: 64 bits
others: reserved
[15:10]: H_ADDR_WIDTH
0 to 7:    reserved
8:    9 bits
9: 10 bits
&#8230;
31: 32 bits
32 to 63: reserved
[17:16]: DMA_INTERFACE
0: none
1: DMA 1
2: DMA 2
3: DMA 3
[20:18]: GE_DMA_DATA_WIDTH
0: 16 bits
1: 32 bits
2: 64 bits
others: reserved
[21]: FIFO_RAM_INSIDE
0: outside
1: inside
[22]: IMPLEMENT_HOLD_REG
0: no hold register
1: hold register
[23]: SET_CLK_FALSE_PATH
0: no false path
1: false path set
[25:24]: NUM_CLK_DIVIDER-1
[26]: AREA_OPTIMIZED
0: no area optimization
1: Area optimization</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_UHS_REG</name>
          <description>UHS-1 register</description>
          <addressOffset>0x74</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DDR_REG</name>
              <description>DDR mode. Determines the voltage fed to the buffers by an
external voltage regulator.
0: non-DDR mode
1: DDR mode
UHS_REG [16] should be set for card.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_RST_n</name>
          <description>Hardware reset register</description>
          <addressOffset>0x78</addressOffset>
          <size>32</size>
          <resetValue>0x1</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>SDMMC_BMOD</name>
          <description>Bus mode register</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PBL</name>
              <description>Programmable Burst Length. These bits indicate the maximum
number of beats to be performed in one IDMAC transaction. The
IDMAC will always attempt to burst as specified in PBL each time
it starts a Burst transfer on the host bus. The permissible values
are 1, 4, 8, 16, 32, 64, 128 and 256. This value is the mirror of
MSIZE of FIFOTH register. In order to change this value, write
the required value to FIFOTH register. This is an encode value as
follows.
0: 1 transfers
1: 4 transfers
2: 8 transfers
3: 16 transfers
4: 32 transfers
5: 64 transfers
6: 128 transfers
7: 256 transfers
Transfer unit is either 16, 32, or 64 bits, based on
HDATA_WIDTH.
PBL is a read-only value and is applicable only for Data Access; it
does not apply to descriptor accesses.</description>
              <bitRange>[10:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DE</name>
              <description>IDMAC Enable. When set, the IDMAC is enabled.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSL</name>
              <description>Descriptor Skip Length. Specifies the number of
HWord/Word/Dword (depending on 16/32/64-bit bus) to skip
between two unchained descriptors. This is applicable only for
dual buffer structure.</description>
              <bitRange>[6:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FB</name>
              <description>Fixed Burst. Controls whether the AHB Master interface performs
fixed burst transfers or not. When set, the AHB will use only
SINGLE, INCR4, INCR8 or INCR16 during start of normal burst
transfers. When reset, the AHB will use SINGLE and INCR burst
transfer operations.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWR</name>
              <description>Software Reset. When set, the DMA Controller resets all its
internal registers.
It is automatically cleared after 1 clock cycle.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_PLDMND</name>
          <description>Poll demand register</description>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PD</name>
              <description>Poll Demand. If the OWN bit of a descriptor is not set, the FSM
goes to the Suspend state. The host needs to write any value into
this register for the IDMAC FSM to resume normal descriptor
fetch operation. This is a write only register.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_DBADDR</name>
          <description>Descriptor list base address register</description>
          <addressOffset>0x88</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SDL</name>
              <description>Start of Descriptor List. Contains the base address of the First
Descriptor.
The LSB bits [0/1/2:0] for 16/32/64-bit bus-width) are ignored
and taken as all-zero by the IDMAC internally. Hence these LSB
bits are read-only.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_IDSTS</name>
          <description>Internal DMAC status register</description>
          <addressOffset>0x8c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FSM</name>
              <description>DMAC FSM present state.
0: DMA_IDLE
1: DMA_SUSPEND
2: DESC_RD
3: DESC_CHK
4: DMA_RD_REQ_WAI
5: DMA_WR_REQ_WAI
6: DMA_RD
7: DMA_WR
8: DESC_CLOSE</description>
              <bitRange>[16:13]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EB</name>
              <description>Error Bits. Indicates the type of error that caused a Bus Error.
Valid only with atal Bus
Error bit&#8212;IDSTS[2] (IDSTS64[2], in case of 64-bit address
configuration) set. This field does not generate an interrupt.
1: Host Abort received during transmission
2: Host Abort received during reception
Others: Reserved</description>
              <bitRange>[12:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>AIS</name>
              <description>Abnormal Interrupt Summary. Logical OR of the following:
IDSTS[2] Fatal Bus Interrupt
IDSTS[4] DU bit Interrupt
Only unmasked bits affect this bit.
This is a sticky bit and must be cleared each time a
corresponding bit that causes AIS to be set is cleared. Writing a 1
clears this bit.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NIS</name>
              <description>Normal Interrupt Summary. Logical OR of the following:
IDSTS[0] Transmit Interrupt
IDSTS[1] Receive Interrupt
Only unmasked bits affect this bit.
This is a sticky bit and must be cleared each time a
corresponding bit that causes NIS to be set is cleared. Writing a 1
clears this bit.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CES</name>
              <description>Card Error Summary. Indicates the status of the transaction
to/from the card; also present in RINTSTS. Indicates the logical
OR of the following bits:
EBE: End Bit Error
RTO: Response Timeout/Boot Ack Timeout
RCRC: Response CRC
SBE: Start Bit Error
DRTO: Data Read Timeout/BDS timeout
DCRC: Data CRC for Receive
RE: Response Error
Writing a 1 clears this bit.
The abort condition of the IDMAC depends on the setting of this
CES bit. If the CES bit is enabled, then the IDMAC aborts on a
"response error"; however, it will not abort if the CES bit is
cleared.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DU</name>
              <description>Descriptor Unavailable Interrupt. This bit is set when the
descriptor is unavailable due to OWN bit = 0 (DES0[31] =0).
Writing a 1 clears this bit.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FBE</name>
              <description>Fatal Bus Error Interrupt. Indicates that a Bus Error occurred
(IDSTS[12:10]) (IDSTS64[12:10], in case of 64-bit address
configuration). When this bit is set, the DMA disables all its bus
accesses. Writing a 1 clears this bit.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RI</name>
              <description>Receive Interrupt. Indicates the completion of data reception for
a descriptor. Writing a 1 clears this bit.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TI</name>
              <description>Transmit Interrupt. Indicates that data transmission is finished
for a descriptor. Writing 1 clears this bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_IDINTEN</name>
          <description>Internal DMAC interrupt enable register</description>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AI</name>
              <description>Abnormal Interrupt Summary Enable. When set, an abnormal
interrupt is enabled.
This bit enables the following bits:
IDINTEN[ 2] Fatal Bus Error Interrupt
IDINTEN[4] DU Interrupt</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NI</name>
              <description>Normal Interrupt Summary Enable. When set, a normal interrupt
is enabled. When reset, a normal interrupt is disabled. This bit
enables the following bits:
IDINTEN[0] Transmit Interrupt
IDINTEN[1] Receive Interrupt</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CES</name>
              <description>Card Error summary Interrupt Enable. When set, it enables the
Card Interrupt summary.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DU</name>
              <description>Descriptor Unavailable Interrupt. When set along with Abnormal
Interrupt Summary Enable, the DU interrupt is enabled.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FBE</name>
              <description>Fatal Bus Error Enable. When set with Abnormal Interrupt
Summary Enable, the Fatal Bus Error Interrupt is enabled. When
reset, Fatal Bus Error Enable Interrupt is disabled.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RI</name>
              <description>Receive Interrupt Enable. When set with Normal Interrupt
Summary Enable, Receive Interrupt is enabled. When reset,
Receive Interrupt is disabled.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TI</name>
              <description>Transmit Interrupt Enable. When set with Normal Interrupt
Summary Enable, Transmit Interrupt is enabled. When reset,
Transmit Interrupt is disabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_DSCADDR</name>
          <description>Current host descriptor address register</description>
          <addressOffset>0x94</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HDA</name>
              <description>Host Descriptor Address Pointer. Cleared on reset. Pointer
updated by IDMAC during operation. This register points to the
start address of the current descriptor read by the IDMAC.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_BUFADDR</name>
          <description>Current buffer descriptor address register</description>
          <addressOffset>0x98</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HBA</name>
              <description>Host Buffer Address Pointer. Cleared on Reset. Pointer updated
by IDMAC during operation. This register points to the current
Data Buffer Address being accessed by the IDMAC.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_CARDTHRCTL</name>
          <description>Card read threshold enable register</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CARDRDTHRESHOLD</name>
              <description>Card Read Threshold size</description>
              <bitRange>[27:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BSYCLRINTEN</name>
              <description>Busy Clear Interrupt generation:
0: Busy Clear Interrupt disabled
1: Busy Clear Interrupt enabled
Note: The application can disable this feature if it does not want
to wait for a Busy Clear Interrupt. For example, in a multi-card
scenario, the application can switch to the other card without
waiting for a busy to be completed. In such cases, the application
can use the polling method to determine the status of busy. By
default this feature is disabled and backward-compatible to the
legacy drivers where polling is used.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CARDRDTHREN</name>
              <description>Card Read Threshold Enable.
0: Card Read Threshold disabled
1: Card Read Threshold enabled. Host Controller initiates Read
Transfer only if CardRdThreshold amount of space is available in
receive FIFO.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_BACK_END_POWER</name>
          <description>Back-end power register</description>
          <addressOffset>0x104</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BACK_END_POWER</name>
              <description>Back end power
0: Off; Reset
1: Back-end Power supplied to card application</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_EMMC_DDR_REG</name>
          <description>eMMC4.5 DDR start bit detection control register</description>
          <addressOffset>0x10c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HALF_START_BIT</name>
              <description>Control for start bit detection mechanism inside Mobile Storage
Host Controller based on duration of start bit; each bit refers to
one slot. For eMMC 4.5, start bit can be:
0: Full cycle (HALF_START_BIT = 0)
1: Less than one full cycle (HALF_START_BIT = 1)
Set HALF_START_BIT=1 for eMMC 4.5 and above; set to 0 for SD
applications.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_FIFO_BASE</name>
          <description>FIFO base address register</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FIFO_BASE_ADDR</name>
              <description>FIFO base address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PCIE</name>
      <version>1.0</version>
      <groupname>PCIE</groupname>
      <baseAddress>0xf8000000</baseAddress>
      <registers>
        <register>
          <name>PCIE_CLIENT_BASIC_STRAP_CONF</name>
          <description>Basic strap configuration register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0xc1</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>Write mask bits
For each served bit
1'b0: write mask
1'b1: write enable</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PCIE_GEN_SEL</name>
              <description>Generation support select
1'b0: Gen1 mode
1'b1: Gen2 mode
This strap input selects the generation of the PCI Express
protocol supported by the core. If Gen1 mode. The core
advertises only Gen1 capability in this mode, and will always
operate at Gen1 speed. If Gen2 mode. The core advertises Gen1
and Gen2 capabilities in this mode, but not Gen3. The link may
operate at Gen1 or Gen2 speed.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE_SELECT</name>
              <description>Controller operation mode select
1'b0: Endpoint operation
1'b1: Root Port operation</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LANE_COUNT</name>
              <description>lane count in
configure the lane count supported
2&#8217;b11: reserved
2&#8217;b10: X4
2&#8217;b01: X2
2&#8217;b00: X1</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARI_EN</name>
              <description>Alternate interpretation enable
1'b0: legacy interpretation of the PCI Routing ID
1'b1: alternate interpretation of the PCI Routing ID
This input is strapped to 0 for legacy interpretation of the PCI
Routing ID (8-bit Bus + 5-bit Device + 3- bit Function). A 1 at
this input enables the alternate interpretation (8-bit Bus + 8-bit
Function).</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SR_IOV_EN</name>
              <description>Single root I/O virtualization feature enable
1'b0: disable SR-IOV feature
1'b1: enable SR-IOV feature
In a core supporting the Single Root I/O Virtualization feature,
this strap input must be tied high to enable the SR-IOV feature.
The ari_en input must also be strapped high to enable the SR-
IOV feature.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LINK_TRAIN_EN</name>
              <description>Link training enable
1'b0: Quite state
1'b1: enable link training
This input must be set to 1 to enable the LTSSM to bring up the
link. Setting it to 0 forces the LTSSM to stay in the Detect Quiet
state.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CONF_EN</name>
              <description>Config enable
1'b0: disable
1'b1: enable
When this input is set to 0 in the EP mode, the core will generate
a CRS Completion in response to Configuration Requests. In
systems where the core configuration registers are loaded from
RAM on power-up, this prevents the core from responding to
Configuration Requests before all the registers are loaded. This
input can be strapped high when the power-on default values of
the Configuration Registers do not need to be modified before
Configuration Space enumeration.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PCIE_CLIENT_POWER_CTRL</name>
          <description>PCIe client power control configuration</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>Write mask bits
For each served bit
1'b0: write mask
1'b1: write enable</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PWR_STCG_ACK_MODE</name>
              <description>Power state change ack mode select
1'b0: select power state change ack source from bit
pwr_stcg_ack
1'b1: select power state change ack source from constant, it
always keeps high.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PWR_STCG_ACK</name>
              <description>Power state change ack
1'b0: keep 0
1'b1: write 1 to generate one high pulse ack to controller
The client must assert this input to the core for one cycle in
response to the assertion of power state change interrupt, when
it is ready to transition to the low-power state requested by the
configuration write request. The client may permanently maintain
this input high if it does not need to delay the return of the
completions for the configuration write transactions causing
power-state changes.</description>
              <bitRange>[8:8]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>HWCLR_EXIT_L1_REQ</name>
              <description>Hardware clear exit L1 request
1'b0: software polling and write clear mode
1'b1: hardware polling and auto-clear mode</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HWCLR_EXIT_L2_REQ</name>
              <description>Hardware clear exit L2 request
1'b0: software polling and write clear mode
1'b1: hardware polling and auto-clear mode</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLT_REQ_EXIT_L1</name>
              <description>Client request exit L1 power state
1'b0: keep
1'b1: request to exit the L1.1 or L1.2.Idle substate
Client request to exit the L1.1 or L1.2.Idle substate. When the
core clock is turned off, the client must activate this input to
request the L1 PM substate state machine to de-assert
CLKREQ_OUT and transition the link out of L1. If the core clock is
not turned off in the L1.1 and L1.2 substates, this input can be
permanently kept low.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REQ_TRN_L23READY</name>
              <description>Request transition to L23_Ready state
1'b0: keep
1'b1: transition the power management state of the core to
L23_READY
When the core is configured as Endpoint, the client may assert
this input to transition the power management state of the core
to L23_READY (see Chapter 5 of PCI Express Specifications for a
detailed description of power management). This is done after
the PCI Functions in the core have been placed in the D3 state
and after the client has acknowledged the PME_Turn_Off
message from the Root Port. Asserting this input causes the link
to transition to the L2 state, and requires a power-on reset to
resume operation. This input can be hardwired to 0 if the link is
not required to transition to L2.
This input is not used in the Root Port mode.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLT_REQ_EXIT_L2</name>
              <description>Client request exit L2 power state
1'b0: keep
1'b1: Exit from L2_IDLE
This input can be asserted by the client only in the short interval
of time after the link enters L2 and before the system is powered
OFF. While the power and clocks are still ON, the client can assert
this input to initiate an exit from L2_IDLE-&gt;DETECT.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PCIE_CLIENT_POWER_STATUS</name>
          <description>PCIe power management status</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PWR_STCG_FC_NUM</name>
              <description>Power state change function number
Function number of the function for which a power state change
occurred.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>L1_PM_SUBST</name>
              <description>L1 power management substate
This output provides the current state of the L1 PM substates
state machine. This output is in the PM_CLK clock domain. Its
encodings are:
3'b000 = LTSSM not in L1 state
3'b001 = L1.0 substate
3'b010 = L1.1 substate
3'b011 = Reserved
3'b100 = L1.2.Entry substate
3'b101 = L1.2.Idle substate
3'b110 = L1.2.Exit substate
3'b111 = Reserved</description>
              <bitRange>[14:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FC_PWR_ST</name>
              <description>Function power state
These outputs provide the current power state of the Physical
Functions. Bits [2:0] capture the power state of Function 0 The
possible power states are:
3'b000: D0_uninitialized
3'b001: D0_active
3'b010: D1
3'b100: D3_hot</description>
              <bitRange>[10:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>LINK_PWR_ST</name>
              <description>Link power state
Current power state of the PCIe link:
4'b0001 = L0
4'b0010 = L0s
4'b0100 = L1
4'b1000 = L2</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PCIE_CLIENT_LEGACY_INT_CTRL</name>
          <description>Legacy interrupt control</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>Write mask
For each served bit
1'b0: write mask
1'b1: write enable</description>
              <bitRange>[17:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>INT_IN</name>
              <description>Legacy interrupt input
1'b0: de-assert
1'b1: assert
When the core is configured as EP, this input is used by the client
application to signal an interrupt from any of its PCI Functions to
the RC using the Legacy PCI Express Interrupt Delivery
mechanism of PCI Express. This input corresponds to INTA of the
PCI bus. Asserting this signal causes the core to send out an
Assert_INTx message, and de-asserting this signal causes the
core to transmit a Deassert_INTx message.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT_PEND_ST</name>
              <description>Legacy interrupt pending status
1'b0: normal
1'b1: pending
When using legacy interrupts, this input is used to indicate the
interrupt pending status of the Physical Functions. The input i
must be set when an interrupt is pending in Function i.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PCIE_CLIENT_ERR_CTRL</name>
          <description>Error control register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>Write mask
For each served bit
1'b0: write mask
1'b1: write enable</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CORR_ERR_CNT_EN</name>
              <description>Enable correctable error counter
1'b0: disable counter
1'b1: enable counter</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NFATAL_ERR_CNT_EN</name>
              <description>Enable non-fatal error counter
1'b0: disable counter
1'b1: enable counter</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FATAL_ERR_CNT_EN</name>
              <description>Enable fatal error counter
1'b0: disable counter
1'b1: enable counter</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CORR_ERR_IN_EN</name>
              <description>Assert a correctable error input to core
1'b0: no error
1'b1: write one to generate one pulse
The client may activate this input for one cycle to indicate a
correctable error detected within the client logic that needs to be
reported as an internal error through the PCI Express Advanced
Error Reporting mechanism. In response, the core sets the
Corrected Internal Error Status bit in the AER Correctable Error
Status Register of all enabled Functions, and in EP mode also
sends an error message if enabled to do so. This error is not
considered Function-specific.</description>
              <bitRange>[1:1]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>UNCORR_ERR_IN_EN</name>
              <description>Assert an uncorrectable error input to core
1'b0: no error
1'b1: write one to generate one pulse
The client may activate this input for one cycle to indicate an
uncorrectable error detected within the client logic that needs to
be reported as an internal error through the PCI Express
Advanced Error Reporting mechanism. In response, the core sets
the Uncorrectable Internal Error Status bit in the AER
Uncorrectable Error Status Register of all enabled Functions, and
in EP mode also sends an error message if enabled to do so. This
error is not considered Function-specific.</description>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PCIE_CLIENT_ERR_CNT</name>
          <description>Error counter</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CORR_ERR_CNT</name>
              <description>Correctable error counter
Correctable error counter, write all one(8'hff) clear the counter.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>NFATAL_ERR_CNT</name>
              <description>Non-fatal error counter
Non-fatal error counter, write all one(8'hff) clear the counter.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>FATAL_ERR_CNT</name>
              <description>Fatal error counter
Fatal error counter, write all one(8'hff) clear the counter.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PCIE_CLIENT_HOT_RESET_CTRL</name>
          <description>Hot reset control</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>Write mask
For each served bit
1'b0: write mask
1'b1: write enable</description>
              <bitRange>[17:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>LINK_DOWN_RST_CLT_MASK</name>
              <description>Mask link down reset client logic
1'b0: disable link down reset client logic
1'b1: enable link down reset client logic</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HOT_RESET_IN</name>
              <description>Assert hot reset to remote device
0: de-assert
1: assert
When this input is asserted in the RC mode, the core initiates a
Hot Reset sequence on the PCIe link. This signal should be driven
synchronous to the CORE_CLK domain. The controller will keep
the
PCIe link in hot reset till the time this signal is driven asserted.
When de-asserted, controller will bring the PCIe link out of hot
reset and initiate link training</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PCIE_CLIENT_SIDE_BAND_CTRL</name>
          <description>Side band control configuration</description>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <resetValue>0x4</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>Write mask
For each served bit
1'b0: write mask
1'b1: write enable</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>RX_STANDBY</name>
              <description>PCIe phy receiver control
Controls whether the PHY RX is active when the PHY is in P0 or
P0s states.
1'b0: Active
1'b1: Standby
In other modes not mentioned above, this signal is ignored. One
bit for each lane.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BYPASS_CODEC</name>
              <description>PIPE bypass codec configuration
Controls whether the PHY performs 8b/10b encode and decode:
1'b0: 8b/10b encode/decode performed normally
1'b1: 8b/10b encode/decode bypassed
Data bus width is 20 bits, TxDataK and RxDataK interfaces are
not used, if encode/decode bypassed, and WIDTH_I shall be set
high.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_DEEMPHASIS_EXT</name>
              <description>PIPE phy extended de-emphasis configuration, it combine with
the standard pipe de-emphasis.</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PWDN</name>
              <description>Power state of the phy
Power up or down the transceiver.
3'b000: P0, normal operation
3'b001: P0s, power saving state
3'b010: P1, lower power state
3'b011: P2, lowest power state, PLL not powered
3'b111: L1SS.2, common mode off
others : L1SS.1, common mode on</description>
              <bitRange>[3:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NON_POSTED_REJ</name>
              <description>PCIe target non posted reject
1'b0: normal operation
1'b1: reject non posted request
This is a single bit input signal which can be asserted by client
logic when it cannot service a non-posted request. The core will
not present any non-posted requests that it receives from the
PCIe Link. It will hold them in the PNP FIFO RAM till the signal is
de-asserted. If a non-posted TLP has already been queued from
the PNP FIFO and this signal is asserted, the core will place it on
the AXI bridge. The client logic must accept the non-posted TLP.
The in-flight non-posted TLPs in the core from the PNP FIFO
cannot be stopped. However, non-posted TLPs that are in the PNP
FIFO RAM when this signal is asserted or come in after the signal
is asserted
will not be forwarded to the AXI interface. The client must assert
this signal when it still can process two or three non-posted TLPs.
This will allow posted TLPs to go past non-posted TLPs at the AXI
master write interface due to client not being able to service non-
posted TLPs.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PCIE_CLIENT_SIDE_BAND_STATUS</name>
          <description>Side band status</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x11f1</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PHY_ST</name>
              <description>PIPE phy status
It indicates completion of several PHY functions including power
management state transition and receiver detection. When this
signal transitions during entry and exit from any PHY state where
PCLK is not provided, then the signaling is asynchronous. When
phy power up, "0" state can indicates pll locked</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DATA_BUS_WIDTH</name>
              <description>PIPE interface data bus width
Reports the width of the data bus that the PHY is configured for:
1'b0: 32-bit mode
1'b1: 16-bit mode
0thers: reserved
When bypass_codec is high, the interface is 20-bit and these two
bits report a value of 2'b01.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_STANDBY_ST</name>
              <description>RX standby status
Indicates PHY's RxStandby state
1'b0: Active
1'b1: Standby
Always high during P1/P2/L1SS state.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_DEEMPHASIS</name>
              <description>PIPE phy de-emphasis status
Transmitter de-emphasis selection, it combined by
tx_deemphasis_ext,tx_deemphasis.
3'b000: -6dB de-emphasis
3'b001: -3.5dB de-emphasis
3'b010: 0dB de-emphasis
3'b011: -5.5dB de-emphasis
3'b100: -6.5dB de-emphasis
3'b101: -4dB de-emphasis
3'b110: -1dB de-emphasis
3'b111: -3dB de-emphasis</description>
              <bitRange>[2:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PCIE_CLIENT_FC_LEVEL_RST_DONE</name>
          <description>Generate function level reset done pulse</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VF_FLR_DONE</name>
              <description>Virtual function level reset done pulse generate
The client must assert bit i of this bus when it has completed the
reset operation of Virtual Function i. This causes the core to de-
assert FLR_IN_PROGRESS for VF i and to re-enable configuration
accesses to the VF.
Write one to generate one high pulse.</description>
              <bitRange>[15:8]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>FLR_DONE</name>
              <description>Physical function level reset done pulse generate
The client must assert bit i of this bus when it has completed the
reset operation of Function i. This causes the core to de-assert
FLR_IN_PROGRESS for Function i and to re-enable configuration
accesses to the Function.
Write one to generate one high pulse.</description>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PCIE_CLIENT_FLR_STATUS</name>
          <description>Function level reset status</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VF_FLR_IN_PROG</name>
              <description>Virtual function level reset in progress
The core asserts bit i of this bus when the host initiates a reset of
Virtual Function i though its FLR bit in the configuration space.
The core continues to maintain the output high until the client
sets the FLR_DONE input for the corresponding VF to indicate the
completion of the reset operation.
One bit for each function
1'b0: normal
1'b1: function level reset in progress</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FLR_IN_PROG</name>
              <description>Function level reset in progress
The core asserts bit i of this bus when the host initiates a reset of
Function i though its FLR bit in the configuration space. The core
continues to maintain the output high until the client sets the
FLR_DONE input for the corresponding Function to indicate the
completion of the reset operation.
1'b0: normal
1'b1: function level reset in progress</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PCIE_CLIENT_VF_STATUS</name>
          <description>Virtual function status</description>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VF_EN</name>
              <description>Virtual function enable
The core sets bit i of this bus when the host has configured the
corresponding Virtual Function i. Client logic must check the state
of this bit before initiating any request from the VF.
1'b0: disable
1'b1: enable
One bit for each function</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VF_BUS_MASTER_EN</name>
              <description>Virtual function bus master enable
Bit i of this bus reflects the setting of the Bus Master Enable bit of
the PCI Command Register of Virtual Function i. Client logic must
check the state of this bit before initiating any memory read or
write transactions from the VF.
1'b0: disable
1'b1: enable
One bit for each function</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PCIE_CLIENT_VF_PWR_STATUS</name>
          <description>Virtual function power status</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VF_PWR_ST</name>
              <description>Virtual function power status
These outputs provide the current power state of the Virtual
Functions. Bits [2:0] capture the power state of Virtual Function
0 , bits [5:3] capture that of Virtual Function 1, and so on. The
possible power states are:
3'b000: D0_uninitialized
3'b001: D0_active
3'b010: D1
3'b100: D3_hot</description>
              <bitRange>[23:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PCIE_CLIENT_VF_TPH_STATUS</name>
          <description>Virtual function TPH status</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VF_TPH_REQR_EN</name>
              <description>Virtual function TPH requester enable
Each of the 16 bits of this output is driven the TPH Requester
Enable bit [8] of the TPH Requester Control Register in the TPH
Requester Capability Structure of the corresponding Virtual
Function.
These bits are active only in the Endpoint mode when SR-IOV is
enabled. They indicate whether the software has enabled the
device to generate requests with TPH Hints from the associated
Virtual Function.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VF_TPH_ST_MODE</name>
              <description>Virtual function TPH steering tag mode
Bits [2:0] of this output reflect the setting of the ST Mode Select
bits in the TPH Requester Control Register of Virtual Function 0.
Bits [5:3] reflect the setting of the same register field of VF 1,
and so on.
These bits are active only in the Endpoint mode. They indicate
the allowed modes for generation of TPH Hints by the
corresponding VF.</description>
              <bitRange>[23:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PCIE_CLIENT_TPH_STATUS</name>
          <description>Physical TPH status</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TPH_REQR_EN</name>
              <description>Physical function TPH requester enable
Bit 0 of this output is drives the TPH Requester Enable bit [8] of
the TPH Requester Control Register in the TPH Requester
Capability Structure of the Physical Function 0.
These bits are active only in the Endpoint mode.
They indicate whether the software has enabled the device to
generate requests with TPH Hints from the associated Physical
Function.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TPH_ST_MODE</name>
              <description>Physical function TPH steering tag mode
Bits [2:0] of this output reflect the setting of the ST Mode Select
bits in the TPH Requester Control Register of Physical Function 0.
These bits are active only in the Endpoint mode. They indicate
the allowed modes for generation of TPH Hints by the
corresponding Physical Function.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PCIE_CLIENT_DEBUG_OUT_0</name>
          <description>Debug information 0</description>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DEBUG_DATA_OUT</name>
              <description>Output data from the debug bus
16-bit output data from the debug bus, described in Appendix A</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>LTSSM_STATE</name>
              <description>Link training and status state
Current state of the Link Training and Status State
Machine within the core. The encodings of this
output are described in Appendix B</description>
              <bitRange>[5:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PCIE_CLIENT_DEBUG_OUT_1</name>
          <description>Debug information 1</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PERF_DATA_OUT</name>
              <description>Performance data out
Each of the bits of this vector is explained below:
Bit[17]:Pulse appears when event happens,described in Appendix
B</description>
              <bitRange>[17:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PCIE_CLIENT_BASIC_STATUS0</name>
          <description>Basic status 0</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <resetValue>0x280</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MAX_PAYLOAD_SIZE</name>
              <description>Max payload size
The maximum payload size field programmed in the PCI Express
Device Control Register. In multiple function cores, this output
provides the minimum of the max-payload-size field in the Device
Control Registers of all the enabled Physical Functions.
The client logic must limit the size of Outgoing Completion
payloads to this value. The 3-bit codes are the same as those
defined in PCIe Specifications:
3'b000 = 128 bytes
3'b001 = 256 bytes
3'b010 = 512 bytes
3'b011 = 1024 bytes
3'b100 = 2048 bytes
3'b101 = 4096 bytes</description>
              <bitRange>[14:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MAX_RDREQ_SIZE</name>
              <description>Max read request size
The maximum request size field programmed in the PCI Express
Device Control Register. In multi?Function cores, this output
provides the minimum of the max-read-request field in the
Device Control Registers of all the Physical Functions. The client
logic must limit the size of outgoing read requests
to this value. The 3-bit codes are the same as those defined in
PCIe Specifications:
3'b000 = 128 bytes
3'b001 = 256 bytes
3'b010 = 512 bytes
3'b011 = 1024 bytes
3'b100 = 2048 bytes
3'b101 = 4096 bytes</description>
              <bitRange>[10:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NEGOTIATED_LINK_WIDTH</name>
              <description>Negotiated link width
Current link width are as follows:
2'b10: x4
2'b01: x2
2'b00: x1
others: Reserved</description>
              <bitRange>[7:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NEGOTIATED_SPEED</name>
              <description>Operation speed after negotiation
Current operating speed of the link is as follows:
1'b0: 2.5GT/s
1'b1: 5GT/s</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RCB_ST</name>
              <description>Read completion boundary status
Provides the setting of the Read Completion Boundary (RCB) bit
in the Link Control Register of each Physical Function. In the
Endpoint mode, bit 0 indicates the RCB for PF 0 and so on. In the
RC mode,
bit 0 indicates the RCB setting of the Link Control Register of the
RC.
For each bit, a value of
1'b0: indicates an RCB of 64 bytes
1'b1: indicates 128 bytes</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>LTR_EN</name>
              <description>Latency tolerance reporting mechanism enable
The state of this output reflects the setting of the LTR Mechanism
Enable bit in the Device Control 2 Register of Physical Function 0.
When the core is configured as an Endpoint, client logic uses this
output to enable the generation of LTR messages.
This output is not to be used when the core is configured as a
Root Complex.
1'b0: disable
1'b1: enable</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OBFF_EN</name>
              <description>Optimized buffer flush and fill enable
This output reflects the setting of the OBFF Enable field in the
Device Control 2 Register
2'b00: OBFF disabled,
2'b01: OBFF enabled using message signaling, Variation A,
2'b10: OBFF enabled using message signaling, Variation B,
2'b11: OBFF enabled using WAKE# signaling.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PCIE_CLIENT_BASIC_STATUS1</name>
          <description>Basic status 1</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <resetValue>0x80001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LINK_ST</name>
              <description>Link status
Status of the PCI Express link.
2'b00 = No receivers detected.
2'b01 = Link training in progress.
2'b10 = Link up , DL initialization in progress.
2'b11 = Link up, DL initialization completed.</description>
              <bitRange>[21:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FC_ST</name>
              <description>Function status
These outputs indicate the states of the Command Register bits
in the PCI configuration space of each Function. These outputs
are used to enable requests and completions from the host logic.
The assignment of bits is as follows:
Bit 0: Function 0 IO Space Enable
Bit 1: Function 0 Memory Space Enable
Bit 2: Function 0 Bus Master Enable
Bit 3: Function 0 INTx Disable
and so on depending on the number of functions.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYS_PAGE_SIZE</name>
              <description>System page size
These bits reflect the setting of the System Page Size Register in
the SR IOV capability of each PF. Bits [15:0] reflect bits [15:0] of
System Page Size register of PF0</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PCIE_CLIENT_INT_MASK</name>
          <description>Interrupt mask</description>
          <addressOffset>0x4c</addressOffset>
          <size>32</size>
          <resetValue>0xffff</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>Write mask
For each served bit
1'b0: write mask
1'b1: write enable</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>LEGACY_DONE_INT_MASK</name>
              <description>Legacy interrupt send done interrupt mask
1'b0: interrupt enable
1'b1: interrupt mask</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MSG_INT_MASK</name>
              <description>Message receive done interrupt mask
1'b0: interrupt enable
1'b1: interrupt mask</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HOT_RESET_INT_MASK</name>
              <description>Hot reset interrupt mask
1'b0: interrupt enable
1'b1: interrupt mask</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPA_INT_MASK</name>
              <description>DPA interrupt mask
1'b0: interrupt enable
1'b1: interrupt mask</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FATAL_ERR_INT_MASK</name>
              <description>Fatal error interrupt mask
1'b0: interrupt enable
1'b1: interrupt mask</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NFATAL_ERR_INT_MASK</name>
              <description>Non-fatal error interrupt mask
1'b0: interrupt enable
1'b1: interrupt mask</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CORR_ERR_INT_MASK</name>
              <description>Correctable error interrupt mask
1'b0: interrupt enable
1'b1: interrupt mask</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INTD_MASK</name>
              <description>INTD interrupt mask
1'b0: interrupt enable
1'b1: interrupt mask</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INTC_MASK</name>
              <description>INTC interrupt mask
1'b0: interrupt enable
1'b1: interrupt mask</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INTB_MASK</name>
              <description>INTB interrupt mask
1'b0: interrupt enable
1'b1: interrupt mask</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INTA_MASK</name>
              <description>INTA interrupt mask
1'b0: interrupt enable
1'b1: interrupt mask</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCAL_INT_MASK</name>
              <description>Local interrupt mask
1'b0: interrupt enable
1'b1: interrupt mask</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UDMA_INT_MASK</name>
              <description>uDMA interrupt mask
1'b0: interrupt enable
1'b1: interrupt mask</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PHY_INT_MASK</name>
              <description>Phy interrupt mask
1'b0: interrupt enable
1'b1: interrupt mask</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HOT_PLUG_INT_MASK</name>
              <description>Hot plug interrupt mask
1'b0: interrupt enable
1'b1: interrupt mask
reserved</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PWR_STCG_INT_MASK</name>
              <description>Power state change interrupt mask
1'b0: interrupt enable
1'b1: interrupt mask</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PCIE_CLIENT_INT_STATUS</name>
          <description>Interrupt status</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LEGACY_DONE_INT</name>
              <description>Legacy interrupt send done interrupt
1'b0: no interrupt
1'b1: interrupt
A pulse on this output indicates that the core has sent an INTx
Assert or Deassert message in response to a change in the state
of one of the int_in</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>MSG_INT</name>
              <description>Message receive done interrupt
1'b0: no interrupt
1'b1: interrupt
When a message received done by Client message FIFO, an
interrupt will generate</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>HOT_RESET_INT</name>
              <description>Hot reset interrupt
1'b0: no interrupt
1'b1: interrupt
When a hot reset send done interrupt generated in RC mode, it
indicates that the Endpoint Device has also received the Hot
Reset, and then the hot_reset_in can be de-assert</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>DPA_INT</name>
              <description>DPA interrupt
1'b0: no interrupt
1'b1: interrupt
The core generates an interrupt when a Configuration Write
transaction writes into the Dynamic Power Allocation Control
Register to modify the DPA power state of the device. A interrupt
indicates such a DPA event for PF 0, and so on. The local
software running on the End Point must read the DPA Control
Register of the corresponding Function to determine the DPA
substate requested by the host and set the power state of the
device accordingly</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>FATAL_ERR_INT</name>
              <description>Fatal error interrupt
1'b0: no interrupt
1'b1: interrupt
In the EP mode, the core activates this output for one cycle when
it has detected a fatal error and its reporting is not masked. In
multi-Function cores, this is the logical OR of the fatal error
status bits in the Device Status Registers of all Functions.
In the RP mode, this output is activated on detection of a local
fatal error, when its reporting is not masked. This signal also gets
activated in response to an error message received from the link
if Fatal Error Reporting is enabled in the Root Error Command
register.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>NFATAL_ERR_INT</name>
              <description>Non-fatal error interrupt
1'b0: no interrupt
1'b1: interrupt
In the EP mode, the core activates this output for one cycle when
it has detected a non-fatal error and its reporting is not masked.
In multi-Function cores, this is the logical OR of the non-fatal
error status bits in the Device Status Registers of all Functions.
In the RC mode, this output is activated on detection of a local
fatal error, when its reporting is not masked. This signal also gets
activated in response to an error message received from the link
if Fatal Error Reporting is enabled in the Root Error Command
register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>CORR_ERR_INT</name>
              <description>Correctable error interrupt
1'b0: no interrupt
1'b1: interrupt
In the EP mode, the core activates this output for one cycle when
it has detected a correctable error and its reporting is not
masked. In multi-Function cores, this is the logical OR of the
correctable error status bits in the Device Status Registers of all
Functions.
In the RC mode, this output is activated on detection of a local
correctable error, when its reporting is not masked. This signal
also gets activated in response to an error message received
from the link if Correctable Error Reporting is enabled in the Root
Error Command register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>INTD</name>
              <description>INTD interrupt
1'b0: no interrupt
1'b1: interrupt
When the core is configured as RC, this interrupt emulate the PCI
legacy interrupts INTD. The core asserts an interrupt output
when it has received an Assert_INTD message from the link, and
deasserts it when it receives a Deassert_INTD message.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INTC</name>
              <description>INTC interrupt
1'b0: no interrupt
1'b1: interrupt
When the core is configured as RC, this interrupt emulate the PCI
legacy interrupts INTC. The core asserts an interrupt output when
it has received an Assert_INTC message from the link, and
deasserts it when it receives a Deassert_INTC message.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INTB</name>
              <description>INTB interrupt
1'b0: no interrupt
1'b1: interrupt
When the core is configured as RC, this interrupt emulate the PCI
legacy interrupts INTB. The core asserts an interrupt output when
it has received an Assert_INTB message from the link, and
deasserts it when it receives a Deassert_INTB message.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INTA</name>
              <description>INTA interrupt
1'b0: no interrupt
1'b1: interrupt
When the core is configured as RC, this interrupt emulate the PCI
legacy interrupts INTA. The core asserts an interrupt output when
it has received an Assert_INTA message from the link, and
deasserts it when it receives a Deassert_INTA message.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>LOCAL_INT</name>
              <description>Local interrupt
1'b0: no interrupt
1'b1: interrupt
Local Error and Status Register Interrupt. This is a level interrupt
till cleared by software
Detail information refers to Local Error and Status Register
description in PCIe Core register section "Local Management
Registers"</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UDMA_INT</name>
              <description>uDMA interrupt
1'b0: no interrupt
1'b1: interrupt
DMA Interrupt to the system processor. Will be asserted on a
"DMA Done" or a "DMA Error" event</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PHY_INT</name>
              <description>Phy interrupt
1'b0: no interrupt
1'b1: interrupt
This interrupt is used by the core in the RP mode to signal one of
the following link training-related events:
1. The link bandwidth changed as a result of the change in the
link width or operating speed and the change was initiated locally
(not by the link partner), without the link going down. This
interrupt is enabled by the Link Bandwidth Management Interrupt
Enable bit in the Link Control Register. The status of this interrupt
can be read from the Link Bandwidth Management Status bit of
the Link Status Register.
2. The link bandwidth changed autonomously as a result of the
change in the link width or operating speed and the change was
initiated by the remote node. This interrupt is enabled by the Link
Autonomous Bandwidth Interrupt Enable bit in the Link Control
Register. The status of this interrupt can be read from the Link
Autonomous Bandwidth Status bit of the Link Status Register.
The phy interrupt is not active when the core is configured as an
EndPoint.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>HOT_PLUG_INT</name>
              <description>Hot plug interrupt
1'b0: no interrupt
1'b1: interrupt
Hot Plug Interrupt Output for Software Notification of Hot Plug
events.
Currently, this interrupt reserved</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PWR_STCG_INT</name>
              <description>Power state change interrupt
1'b0: no interrupt
1'b1: interrupt
The core asserts this output when the power state of a Physical
or Virtual Function is being changed to the D1 or D3 states by a
write into its Power Management Control Register. The core
maintains this output high until the client asserts the
pwr_stcg_ack input to the core. While interrupt remains high, the
core will not return completions for any pending configuration
read or write transaction received by the core. The intent is to
delay the completion for the configuration write transaction that
caused the state change until the client is ready to transition to
the low- power state. When interrupt is asserted, the Function
number associated with the configuration write transaction is
provided on the pwr_stcg_fc_num.
When the client asserts pwr_stcg_ack, the new state of the
Function that underwent the state change will be reflected on the
fc_pwr_st (for PFs) or the vf_pwr_st (for VFs) outputs of the
core.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PCIE_CLIENT_MSG_CTRL</name>
          <description>Message receive control register</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRITE_MASK</name>
              <description>Write mask
For each served bit
1'b0: write mask
1'b1: write enable</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>ALMFULL_WATER_MARK</name>
              <description>Almost full water mark
almost full water mark configuration</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MSG_FIFO_RX_MODE</name>
              <description>Message fifo receive mode select
1'b0: partial mode
1'b1: full mode</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MSG_FIFO_EN</name>
              <description>Message fifo receive enable
1'b0: disable message receive
1'b1: enable client message receive</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PCIE_CLIENT_MSG_STATUS</name>
          <description>Message control status</description>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SPACE2EMPTY</name>
              <description>Space to empty
Data length before empty</description>
              <bitRange>[12:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FIFO_FULL</name>
              <description>Message fifo full
1'b0: non-full
1'b1: fifo full</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FIFO_EMPTY</name>
              <description>Message fifo empty
1'b0: non-full empty
1'b1: fifo_empty</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ALMOST_FULL</name>
              <description>Message fifo almost full flag
1'b0: non-almost full
1'b1: almost full</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PCIE_CLIENT_MSG_CODE0</name>
          <description>Message code 0</description>
          <addressOffset>0x5c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MTPAT4</name>
              <description>Match pattern 4
Pattern4</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MTPAT3</name>
              <description>Match pattern 3
Pattern3</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MTPAT2</name>
              <description>Match pattern 2
Pattern2</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MTPAT1</name>
              <description>Match pattern 1
Pattern 1</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PCIE_CLIENT_MSG_CODE1</name>
          <description>Message code 1</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MTPAT8</name>
              <description>Match pattern 8
Pattern8</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MTPAT7</name>
              <description>Match pattern 7
Pattern7</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MTPAT6</name>
              <description>Match pattern 6
Pattern6</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MTPAT5</name>
              <description>Match pattern 5
Pattern5</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PCIE_CLIENT_MSG_DATA_LEN</name>
          <description>Message data length</description>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LENGTH4</name>
              <description>Length4
Length4, record the 4th recently received message length.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>LENGTH3</name>
              <description>Length3
Length3, record the 3rd recently received message length.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>LENGTH2</name>
              <description>Length2
Length2, record the 2nd recently received message length.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>LENGTH1</name>
              <description>Length1
Length1, record the recently received message length.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
          </fields>
        </register>
        <register>
          <name>PCIE_CLIENT_MSG_FIFO_RD_DATA</name>
          <description>Message fifo read data</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RD_DATA</name>
              <description>Message fifo read data
Message fifo read data</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PCIE_CLIENT_CONF_NU0</name>
          <description>Configuration no used</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
        <register>
          <name>PCIE_CLIENT_CONF_NU1</name>
          <description>Configuration no used</description>
          <addressOffset>0x204</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields/>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PWM</name>
      <version>1.0</version>
      <groupname>PWM</groupname>
      <baseAddress>0xff420000</baseAddress>
      <registers>
        <register>
          <name>PWM_PWM0_CNT</name>
          <description>PWM Channel 0 Counter Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNT</name>
              <description>Timer Counter
The 32-bit indicates current value of PWM Channel 0 counter. The
counter runs at the rate of PWM clock.
The value ranges from 0 to (2^32-1).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWM_PWM0_PERIOD_HPR</name>
          <description>PWM Channel 0 Period Register/High Polarity Capture Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PERIOD_HPR</name>
              <description>Output Waveform Period/Input Waveform High Polarity Cycle
If PWM is operated at the continuous mode or one-shot mode,
this value defines the period of the output waveform. Note that, if
the PWM is operated at the center-aligned mode, the period
should be an even one, and therefore only the bit [31:1] is taken
into account and bit [0] always considered as 0.
If PWM is operated at the capture mode, this value indicates the
effective high polarity cycles of input waveform. This value is
based on the PWM clock.
The value ranges from 0 to (2^32-1).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWM_PWM0_DUTY_LPR</name>
          <description>PWM Channel 0 Duty Register/Low Polarity Capture Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DUTY_LPR</name>
              <description>Output Waveform Duty Cycle/Input Waveform Low Polarity Cycle
If PWM is operated at the continuous mode or one-shot mode,
this value defines the duty cycle of the output waveform. The
PWM starts the output waveform with duty cycle. Note that, if the
PWM is operated at the center-aligned mode, the period should
be an even one, and therefore only the [31:1] is taken into
account.
If PWM is operated at the capture mode, this value indicates the
effective low polarity cycles of input waveform.
This value is based on the PWM clock. The value ranges from 0 to
(2^32-1).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWM_PWM0_CTRL</name>
          <description>PWM Channel 0 Control Register</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RPT</name>
              <description>Repeat Counter
This field defines the repeated effective periods of output
waveform in one-shot mode. The value N means N+1 repeated
effective periods.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCALE</name>
              <description>Scale Factor
This field defines the scale factor applied to prescaled clock. The
value N means the clock is divided by 2*N. If N is 0, it means
that the clock is divided by 512(2*256).</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESCALE</name>
              <description>Prescale Factor
This field defines the prescale factor applied to input clock. The
value N means that the input clock is divided by 2^N.</description>
              <bitRange>[14:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_SEL</name>
              <description>Clock Source Select
0: non-scaled clock is selected as PWM clock source. It means
that the prescale clock is directly used as the PWM clock source
1: scaled clock is selected as PWM clock source</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LP_EN</name>
              <description>Low Power Mode Enable
0: disabled
1: enabled
When PWM channel is inactive state and Low Power Mode is
enabled, the path to PWM Clock prescale module is blocked to
reduce power consumption.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTPUT_MODE</name>
              <description>PWM Output mode
0: left aligned mode
1: center aligned mode</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INACTIVE_POL</name>
              <description>Inactive State Output Polarity
This defines the output waveform polarity when PWM channel is
in inactive state. The inactive state means that PWM finishes the
complete waveform in one-shot mode or PWM channel is
disabled.
0: negative
1: positive</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DUTY_POL</name>
              <description>Duty Cycle Output Polarity
This defines the polarity for duty cycle. PWM starts the output
waveform with duty cycle.
0: negative
1: positive</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM_MODE</name>
              <description>PWM Operation Mode
00: One shot mode.    PWM produces the waveform within the
repeated times defined by PWMx_CTRL_rpt.
01: Continuous mode. PWM produces the waveform continuously
10: Capture mode. PWM measures the cycles of high/low polarity
of input waveform.
11: reserved</description>
              <bitRange>[2:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM_EN</name>
              <description>PWM channel enable
0: disabled
1: enabled. If the PWM is worked in the one-shot mode, this bit
will be cleared at the    end of operation</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWM_PWM1_CNT</name>
          <description>PWM Channel 1 Counter Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNT</name>
              <description>Timer Counter
The 32-bit indicates current value of PWM Channel 1 counter. The
counter runs at the rate of PWM clock.
The value ranges from 0 to (2^32-1).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWM_PWM1_PERIOD_HPR</name>
          <description>PWM Channel 1 Period Register/High Polarity Capture Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PERIOD_HPR</name>
              <description>Output Waveform Period/Input Waveform High Polarity Cycle
If PWM is operated at the continuous mode or one-shot mode,
this value defines the period of the output waveform. Note that, if
the PWM is operated at the center-aligned mode, the period
should be an even one, and therefore only the bit [31:1] is taken
into account and bit [0] always considered as 0.
If PWM is operated at the capture mode, this value indicates the
effective high polarity cycles of input waveform.
This value is based on the PWM clock. The value ranges from 0 to
(2^32-1).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWM_PWM1_DUTY_LPR</name>
          <description>PWM Channel 1 Duty Register/Low Polarity Capture Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DUTY_LPR</name>
              <description>Output Waveform Duty Cycle/Input Waveform Low Polarity Cycle
If PWM is operated at the continuous mode or one-shot mode,
this value defines the duty cycle of the output waveform. The
PWM starts the output waveform with duty cycle. Note that, if the
PWM is operated at the center-aligned mode, the period should
be an even one, and therefore only the [31:1] is taken into
account.
If PWM is operated at the capture mode, this value indicates the
effective low polarity cycles of input waveform.
This value is based on the PWM clock. The value ranges from 0 to
(2^32-1).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWM_PWM1_CTRL</name>
          <description>PWM Channel 1 Control Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RPT</name>
              <description>Repeat Counter
This field defines the repeated effective periods of output
waveform in one-shot mode. The value N means N+1 repeated
effective periods.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCALE</name>
              <description>Scale Factor
This field defines the scale factor applied to prescaled clock. The
value N means the clock is divided by 2*N. If N is 0, it means
that the clock is divided by 512(2*256).</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESCALE</name>
              <description>Prescale Factor
This field defines the prescale factor applied to input clock. The
value N means that the input clock is divided by 2^N.</description>
              <bitRange>[14:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_SEL</name>
              <description>Clock Source Select
0: non-scaled clock is selected as PWM clock source. It means
that the prescale clock is directly used as the PWM clock source
1: scaled clock is selected as PWM clock source</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LP_EN</name>
              <description>Low Power Mode Enable
0: disabled
1: enabled
When PWM channel is inactive state and Low Power Mode is
enabled, the path to PWM Clock prescale module is blocked to
reduce power consumption.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTPUT_MODE</name>
              <description>PWM Output mode
0: left aligned mode
1: center aligned mode</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INACTIVE_POL</name>
              <description>Inactive State Output Polarity
This defines the output waveform polarity when PWM channel is
in inactive state. The inactive state means that PWM finishes the
complete waveform in one-shot mode or PWM channel is
disabled.
0: negative
1: positive</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DUTY_POL</name>
              <description>Duty Cycle Output Polarity
This defines the polarity for duty cycle. PWM starts the output
waveform with duty cycle.
0: negative
1: positive</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM_MODE</name>
              <description>PWM Operation Mode
00: One shot mode.    PWM produces the waveform within the
repeated times defined by PWMx_CTRL_rpt
01: Continuous mode. PWM produces the waveform continuously
10: Capture mode. PWM measures the cycles of high/low polarity
of input waveform.
11: reserved</description>
              <bitRange>[2:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM_EN</name>
              <description>PWM channel enable
0: disabled
1: enabled. If the PWM is worked in the one-shot mode, this bit
will be cleared at the    end of operation</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWM_PWM2_CNT</name>
          <description>PWM Channel 2 Counter Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNT</name>
              <description>Timer Counter
The 32-bit indicates current value of PWM Channel 2 counter. The
counter runs at the rate of PWM clock.
The value ranges from 0 to (2^32-1).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWM_PWM2_PERIOD_HPR</name>
          <description>PWM Channel 2 Period Register/High Polarity Capture Register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PERIOD_HPR</name>
              <description>Output Waveform Period/Input Waveform High Polarity Cycle
If PWM is operated at the continuous mode or one-shot mode,
this value defines the period of the output waveform. Note that, if
the PWM is operated at the center-aligned mode, the period
should be an even one, and therefore only the bit [31:1] is taken
into account and bit [0] always considered as 0.
If PWM is operated at the capture mode, this value indicates the
effective high polarity cycles of input waveform.
This value is based on the PWM clock. The value ranges from 0 to
(2^32-1).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWM_PWM2_DUTY_LPR</name>
          <description>PWM Channel 2 Duty Register/Low Polarity Capture Register</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DUTY_LPR</name>
              <description>Output Waveform Duty Cycle/Input Waveform Low Polarity Cycle
If PWM is operated at the continuous mode or one-shot mode,
this value defines the duty cycle of the output waveform. The
PWM starts the output waveform with duty cycle. Note that, if the
PWM is operated at the center-aligned mode, the period should
be an even one, and therefore only the [31:1] is taken into
account.
If PWM is operated at the capture mode, this value indicates the
effective low polarity cycles of input waveform.
This value is based on the PWM clock. The value ranges from 0 to
(2^32-1).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWM_PWM2_CTRL</name>
          <description>PWM Channel 2 Control Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RPT</name>
              <description>Repeat Counter
This field defines the repeated effective periods of output
waveform in one-shot mode. The value N means N+1 repeated
effective periods.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCALE</name>
              <description>Scale Factor
This field defines the scale factor applied to prescaled clock. The
value N means the clock is divided by 2*N. If N is 0, it means
that the clock is divided by 512(2*256).</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESCALE</name>
              <description>Prescale Factor
This field defines the prescale factor applied to input clock. The
value N means that the input clock is divided by 2^N.</description>
              <bitRange>[14:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_SEL</name>
              <description>Clock Source Select
0: non-scaled clock is selected as PWM clock source. It means
that the prescale clock is directly used as the PWM clock source
1: scaled clock is selected as PWM clock source</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LP_EN</name>
              <description>Low Power Mode Enable
0: disabled
1: enabled
When PWM channel is inactive state and Low Power Mode is
enabled, the path to PWM Clock prescale module is blocked to
reduce power consumption.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTPUT_MODE</name>
              <description>PWM Output mode
0: left aligned mode
1: center aligned mode</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INACTIVE_POL</name>
              <description>Inactive State Output Polarity
This defines the output waveform polarity when PWM channel is
in inactive state. The inactive state means that PWM finishes the
complete waveform in one-shot mode or PWM channel is
disabled.
0: negative
1: positive</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DUTY_POL</name>
              <description>Duty Cycle Output Polarity
This defines the polarity for duty cycle. PWM starts the output
waveform with duty cycle.
0: negative
1: positive</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM_MODE</name>
              <description>PWM Operation Mode
00: One shot mode.    PWM produces the waveform within the
repeated times defined by PWMx_CTRL_rpt.
01: Continuous mode. PWM produces the waveform continuously
10: Capture mode. PWM measures the cycles of high/low polarity
of input waveform.
11: reserved</description>
              <bitRange>[2:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM_EN</name>
              <description>PWM channel enable
0: disabled
1: enabled. If the PWM is worked in the one-shot mode, this bit
will be cleared at the    end of operation</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWM_PWM3_CNT</name>
          <description>PWM Channel 3 Counter Register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNT</name>
              <description>Timer Counter
The 32-bit indicates current value of PWM Channel 3 counter. The
counter runs at the rate of PWM clock.
The value ranges from 0 to (2^32-1).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWM_PWM3_PERIOD_HPR</name>
          <description>PWM Channel 3 Period Register/High Polarity Capture Register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PERIOD_HPR</name>
              <description>Output Waveform Period/Input Waveform High Polarity Cycle
If PWM is operated at the continuous mode or one-shot mode,
this value defines the period of the output waveform. Note that, if
the PWM is operated at the center-aligned mode, the period
should be an even one, and therefore only the bit [31:1] is taken
into account and bit [0] always considered as 0.
If PWM is operated at the capture mode, this value indicates the
effective high polarity cycles of input waveform.
This value is based on the PWM clock. The value ranges from 0 to
(2^32-1).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWM_PWM3_DUTY_LPR</name>
          <description>PWM Channel 3 Duty Register/Low Polarity Capture Register</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DUTY_LPR</name>
              <description>Output Waveform Duty Cycle/Input Waveform Low Polarity Cycle
If PWM is operated at the continuous mode or one-shot mode,
this value defines the duty cycle of the output waveform. The
PWM starts the output waveform with duty cycle. Note that, if the
PWM is operated at the center-aligned mode, the period should
be an even one, and therefore only the [31:1] is taken into
account.
If PWM is operated at the capture mode, this value indicates the
effective low polarity cycles of input waveform.
This value is based on the PWM clock. The value ranges from 0 to
(2^32-1).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWM_PWM3_CTRL</name>
          <description>PWM Channel 3 Control Register</description>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RPT</name>
              <description>Repeat Counter
This field defines the repeated effective periods of output
waveform in one-shot mode. The value N means N+1 repeated
effective periods.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCALE</name>
              <description>Scale Factor
This field defines the scale factor applied to prescaled clock. The
value N means the clock is divided by 2*N. If N is 0, it means
that the clock is divided by 512(2*256).</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESCALE</name>
              <description>Prescale Factor
This field defines the prescale factor applied to input clock. The
value N means that the input clock is divided by 2^N.</description>
              <bitRange>[14:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_SEL</name>
              <description>Clock Source Select
0: non-scaled clock is selected as PWM clock source. It means
that the prescale clock is directly used as the PWM clock source
1: scaled clock is selected as PWM clock source</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LP_EN</name>
              <description>Low Power Mode Enable
0: disabled
1: enabled
When PWM channel is inactive state and Low Power Mode is
enabled, the path to PWM Clock prescale module is blocked to
reduce power consumption.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTPUT_MODE</name>
              <description>PWM Output mode
0: left aligned mode
1: center aligned mode</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INACTIVE_POL</name>
              <description>Inactive State Output Polarity
This defines the output waveform polarity when PWM channel is
in inactive state. The inactive state means that PWM finishes the
complete waveform in one-shot mode or PWM channel is
disabled.
0: negative
1: positive</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DUTY_POL</name>
              <description>Duty Cycle Output Polarity
This defines the polarity for duty cycle. PWM starts the output
waveform with duty cycle.
0: negative
1: positive</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM_MODE</name>
              <description>PWM Operation Mode
00: One shot mode.    PWM produces the waveform within the
repeated times defined by PWMx_CTRL_rpt
01: Continuous mode. PWM produces the waveform continuously
10: Capture mode. PWM measures the cycles of high/low polarity
of input waveform.
11: reserved</description>
              <bitRange>[2:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM_EN</name>
              <description>PWM channel enable
0: disabled
1: enabled. If the PWM is worked in the one-shot mode, this bit
will be cleared at the    end of operation</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWM_INTSTS</name>
          <description>Interrupt Status Register</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH3_POL</name>
              <description>Channel 3 Interrupt Polarity Flag
This bit is used in capture mode in order to
of the input waveform when interrupt is generated. When bit is 1,
please refer to PWM3_PERIOD_HPR to know the effective high
cycle of Channel 3 input waveform. Otherwise, please refer to
PWM3_PERIOD_LPR to know the effective low cycle of Channel 3
input waveform. Write 1 to CH3_IntSts will clear this bit.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CH2_POL</name>
              <description>Channel 2 Interrupt Polarity Flag
This bit is used in capture mode in order to identify the transition
of the input waveform when interrupt is generated. When bit is 1,
please refer to PWM2_PERIOD_HPR to know the effective high
cycle of Channel 2 input waveform. Otherwise, please refer to
PWM2_PERIOD_LPR to know the effective low cycle of Channel 2
input waveform. Write 1 to CH2_IntSts will clear this bit.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CH1_POL</name>
              <description>Channel 1 Interrupt Polarity Flag
This bit is used in capture mode in order to identify the transition
of the input waveform when interrupt is generated. When bit is 1,
please refer to PWM1_PERIOD_HPR to know the effective high
cycle of Channel 1 input waveform. Otherwise, please refer to
PWM1_PERIOD_LPR to know the effective low cycle of Channel 1
input waveform. Write 1 to CH1_IntSts will clear this bit.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CH0_POL</name>
              <description>Channel 0 Interrupt Polarity Flag
This bit is used in capture mode in order to identify the transition
of the input waveform when interrupt is generated. When bit is 1,
please refer to PWM0_PERIOD_HPR to know the effective high
cycle of Channel 0 input waveform. Otherwise, please refer to
PWM0_PERIOD_LPR to know the effective low cycle of Channel 0
input waveform. Write 1 to CH0_IntSts will clear this bit.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CH3_INTSTS</name>
              <description>Channel 3 Interrupt Status
0: Channel 3 Interrupt not generated
1: Channel 3 Interrupt generated</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CH2_INTSTS</name>
              <description>Channel 2 Interrupt Status
0: Channel 2 Interrupt not generated
1: Channel 2 Interrupt generated</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CH1_INTSTS</name>
              <description>Channel 1 Interrupt Status
0: Channel 1 Interrupt not generated
1: Channel 1 Interrupt generated</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CH0_INTSTS</name>
              <description>Channel 0 Raw Interrupt Status
0: Channel 0 Interrupt not generated
1: Channel 0 Interrupt generated</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWM_INT_EN</name>
          <description>Interrupt Enable Register</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH3_INT_EN</name>
              <description>Channel 3 Interrupt Enable
0: Channel 3 Interrupt disabled
1: Channel 3 Interrupt enabled</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CH2_INT_EN</name>
              <description>Channel 2 Interrupt Enable
0: Channel 2 Interrupt disabled
1: Channel 2 Interrupt enabled</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CH1_INT_EN</name>
              <description>Channel 1 Interrupt Enable
0: Channel 1 Interrupt disabled
1: Channel 1 Interrupt enabled</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CH0_INT_EN</name>
              <description>Channel 0 Interrupt Enable
0: Channel 0 Interrupt disabled
1: Channel 0 Interrupt enabled</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWM_PWM_FIFO_CTRL</name>
          <description>PWM Channel 3 FIFO Mode/PWM Channel 3 FIFO Mode Control Register</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIMEOUT_EN</name>
              <description>FIFO Timeout Enable</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_MODE_EN</name>
              <description>DMA Mode Enable
1'b1: enable
1'b0: disable</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALMOST_FULL_WATERMARK</name>
              <description>Almost Full Watermark Level</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WATERMARK_INT_EN</name>
              <description>Watermark Full Interrupt</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW_INT_EN</name>
              <description>FIFO Overflow Interrupt Enable
When high, an interrupt asserts when the channel 3 FIFO is
overflow.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FULL_INT_EN</name>
              <description>FIFO Full Interrupt Enable
When high, an interrupt asserts when the channel 3 FIFO is full.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FIFO_MODE_SEL</name>
              <description>FIFO MODE Sel
When high, PWM FIFO mode is activated</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWM_PWM_FIFO_INTSTS</name>
          <description>FIFO Interrupts Status Register</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FIFO_EMPTY_STATUS</name>
              <description>FIFO Empty Status
This bit indicates the FIFO is empty</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TIMEOUT_INTSTS</name>
              <description>Timeout Interrupt</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>FIFO_WATERMARK_FULL_INTSTS</name>
              <description>FIFO Watermark Full Interrupt Status
This bit indicates the FIFO is Watermark Full</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>FIFO_OVERFLOW_INTSTS</name>
              <description>FIFO Overflow Interrupt Status
This bit indicates the FIFO is overflow</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>FIFO_FULL_INTSTS</name>
              <description>FIFO Full Interrupt Status
This bit indicates the FIFO is full</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PWM_PWM_FIFO_TOUTTHR</name>
          <description>FIFO Timeout Threshold Register</description>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIMEOUT_THRESHOLD</name>
              <description>FIFO Timeout Value(unit pwmclk)</description>
              <bitRange>[19:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
  </peripherals>
</device>
